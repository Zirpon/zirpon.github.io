<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>高质量C++读书笔记</title>
    <url>/2023/05/31/C++/</url>
    <content><![CDATA[<p><a href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference.com</a></p>
<h1 id="高质量C"><a href="#高质量C" class="headerlink" title="高质量C++"></a>高质量C++</h1><h2 id="1-C-C-程序-基本概念"><a href="#1-C-C-程序-基本概念" class="headerlink" title="1. C++&#x2F;C 程序 基本概念"></a>1. C++&#x2F;C 程序 基本概念</h2><p>内存页<br>缺页中断 页面调度 页面交换</p>
<p>动态内存分配 运行时搜索</p>
<p><code>ocrmypdf  --sidecar test4.txt -l chi_sim+eng --deskew --jobs 4 -s 高质量程序设计指南_C++_C语言_第三版_扫描版.pdf test4.pdf</code></p>
<p>内部名称 <code>_main</code></p>
<p>C的连接规范<br>C语言中<br>编译单元（文件作用域） static函数<br>extern 连接类型 global 作用域的 全局函数</p>
<p>C++<br>作用域：编译单元 class struct union namespace<br>同一个作用域同名函数 —— 重载函数</p>
<p>name-manglin </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample_1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> m_name[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>* newName)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sample_1_foo@pch@<span class="number">1</span> </span><br><span class="line">Sample_1_foo@<span class="type">int</span>@<span class="number">1</span> </span><br><span class="line">Sample <span class="number">2</span>_foo@pch@<span class="number">1</span></span><br><span class="line">Sample_2_foo@<span class="type">int</span>@<span class="number">1</span></span><br><span class="line">Lippman的《inside The C++ object model》</span><br></pre></td></tr></table></figure>
<p>连接规范 linkage specification</p>
<p>关系到编译器采用什么样的name-mangling方案重命名这些标识符的问题</p>
<p>同一个标识符在不同的编译单元或模块中具有不一致的连接规范 就会产生不一致的内部名称 导致程序连接失败</p>
<p>通用连接规范属 C连接规范 extern “C”</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类型 函数 变量 常量 指定连接规范</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">WinMainCRTStartup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">const</span> CLSID CLSID_DataConverter;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;......&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> Student g_Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码限定连接规范</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明指定某个标识符 连接规范为 exter&quot;C&quot; 其对应定义也要指定extern &quot;C&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> _cdecl <span class="title">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*, <span class="type">sizt_t</span>)</span></span>; <span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> _cdecl <span class="title">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">void</span>* a , <span class="type">sizt_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	....<span class="comment">//功能实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>C++&#x2F;C 中 ， 全 局 变量 (extern或 static 的 ) 存放 在 程序 的 静态数据 区<br>全 局 变量 提供 初 值 编 译器会 自动 地将 0 转换 所 需要 的 类 型 来 初始 化 它们</p>
<p>无 法 决定 当两 个 编译 单元连接 在 一 起 时 哪 一 个 的 全 局 变量 的 初始 化 于 另 一 个 编译 单元 的 全 局变量 的 初始 化</p>
<p>启动 函数 、IO 系统 函 数 存储 管理 、RTTI、 动态决议 动 态 链接 〈DLL) 等 都 会 调用 C 运行 时 库中 的 函数<br>C 运行 时 有 多 线程 和 单线 程</p>
<p>编译 预 处 理 、 编译 和 连接 器 工作 的 阶段 合 “ 编 译 ”。</p>
<p>预 编译 伪 指令 类 〈 型 定义 外部 对 象 声 、 函 数 原型、 标识符 、 各 种修饰符号 (const、static 等 ) 及 类 成 员 的访问说 明 符 (public、private、protected) 和 连接 规范 调 用 规范 等仅在 编译 器进行 语法检查 、 语 义 检查 和 生成 目标文件 〈.obj 或 .o 文件 ) 及 连接 的 时 候起 作用 的</p>
<p>容器 越界，访问 虚 函数 ，动态 决议 ，函 数 动态 连接 、 动 内 存 分 配 异 常 处 和 RTTI等则 是在 运行 时 才 会 出 和 发 作用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *pInt = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">pint += <span class="number">100</span>;                         <span class="comment">// 越界 但 是 还 没有 形成 越界 访问</span></span><br><span class="line">cout &lt;&lt; *pInt&lt;&lt;endl;          <span class="comment">// 越界 访问 ! 可 能 行 也 可 能 不 !</span></span><br><span class="line">*pInt = <span class="number">1000</span>;                      <span class="comment">// 越界访问 ! 即使偶尔 不 出问题 但 不能 确保永远不 出问题 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123; cout&lt;&lt; <span class="string">&quot;Base::Say() was invoked!\n&quot;</span>; </span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>: / 改变 访问 权限 合 法但 不 是好 风格 !</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span>&#123; cout &lt;&lt; “Derived::<span class="built_in">Say</span>() was invoked!\n”;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">p-&gt;<span class="built_in">Say</span>(); <span class="comment">//输出: Derived::Say() was invoked !</span></span><br><span class="line"><span class="comment">// 出 乎 意料 地绑 定 到 了 一 private 函数 身上 </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>独立编译技术<br>每 一 个 源代| 码 文件 〈 源 文件 及 其 递归 包含 的 有 头 文件 展开 ) 就 是 一 个 最小 的 编译 单元 每 个 编译 单元 可 以独立 编译 而不 需要 知道 他 编译 单元 的 存在 及 其 编译 结果 。</p>
<p>32位 操作 系统 上 ，int 类 型 的 变量 就 拥有 4 字 节 的 内 存单 元 而 double 类 型 的 变量 占 8 字 节 的 内 存单</p>
<pre><code>标准 C 语言 支持 基本 〈 内 ) 数据 类 有 int、long、float、double、char、void， 以 及 它们 和 signed、unsigned、*、&amp; 等 的 组 《 有些组 合 是 不 支持 的 例 如 void&amp; )。 标准 C++ 在 这 些 类 型 的 基础 上 增加 了 bool 类 型 并 同时 增加 了 两 内 置 的 符号 常量 true All false (Se).
</code></pre>
<p> 标准 C 中 ，int 为 默认 类 型 也 就 是 说 如果 你 明确 指定 函数 的 形 类 型 或函数返回值类型 则它们的类型为 int,<br>标准C++不支持默认类型，但在模板中 有 “默认 类 型 参数 ”的 概念 。</p>
<p>某些 基于 RISC《〈 精 简 指令 集计 算 机 ) 的 CPU 比如 SPARC、PowerPC 等<br>对 内存 中 基本 数据类 型 变量 采用<br>高 字 节 (BYTE) 和 高 (WORD) 在 低地 址 存放 、 低字节 和 低 字 在 地 址 存放 的<br>Big Endian 存储格式 〈 即 高 字 节 、 高 字 在 前 或 地 址 大的 字 节 结尾 ),<br>并 且 把 最 高 字节 的 地 址 作为 变量 的 首 地址</p>
<p>。在 这 种 自然 的 存储 格式 中 ，<br>| 要求 变 量在 内 存 中 的 存放 位 必须 自然 对 ,否则 CPU 会 报告 异常 所 谓 自然 对齐 ，<br>| 就 基本数据 类 〈 主 要 short、int 和double) 的 变量 不 能 简单 地 存储 于 内 存 中 的<br>任意 地 址 处 它 们 的 起 地 址 必须 能 够 被 它们 的 大 小 整除</p>
<p>在 32 位 平台 下 ，int 和 指针 类 型 变量 的 地 址 应 该 能 4 整除，而 short 变量 的 地 址 都应 该 是 偶数 ，bool和 char 则 没有 特别 要 求</p>
<p><img src="/../img/C++/Pasted%20image%2020230531104928.png"></p>
<p>Intel 系列 CPU 采用 Little Endian 存储 格式 来 存放 基本 类 型 变量 即 低 字节和低字 在 低地 址 存放 、 高 字 节 和 高 字 在 地 址 存放 《〈 即 低 字 节 、 低 字 在 前 或地 址 小 的 字 节 结尾 )， 并 且 把 最低 字节 的 地 址 作为 变量 的 首 地 址</p>
<p><img src="/../img/C++/Pasted%20image%2020230531105144.png"></p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p> 显 地 使 用 强制 类 型 转换由 此 可 能 造成 的 安全 隐患 由 程序 员 负 责<br> 这 里 安全 性 主要包括 两 个 方面 内 存单 元访问 的 安全 和 转换 结果 的 安全 性<br> 主要 表现<br> 内 存 访问 范围 的 扩张<br> 内 存 的 截断<br> 尾 数 的 截断<br> 值 的 改变 和<br> 溢出<br> 一 个 低级 数据 类 型 对 象 总 是 优先 转换 为 能 够 容纳 得 下 它 的 大 值 的、 占用 内 存;最少 的 高 级 类 型 对 象</p>
<p>示例 4-5 中 的 转换 是 安全 的 并 不 需要 强制 编 译 器 </p>
<p>首先 隐 式 地 100 提升: double《〈 作 为 它 的 整数 部 分 的 一 个 临时 变量<br>然 才 将这 个 临时 变量 赋值 dl;<br>同样 ，i 也 会 首先 隐 式 地 提升 double《〈 其 值作为 它 的 整数 部 ) 的 一 个 临时 变量 ，<br>| 然后 才 赋值 d2。<br>当 编译 器 认为 这 些 临时 变量 不再 需要 时 就 适时 地 把 它们 销毁 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">4</span>-$</span><br><span class="line"><span class="type">double</span> di = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> i= <span class="number">100</span>;</span><br><span class="line"><span class="type">double</span> d2 = i</span><br></pre></td></tr></table></figure>

<p> 直接 将派生 类对 象 转换 基 类 对 ，这 虽然 会 生 内 存 截断 但 是 无 从 内 存 访问 还 从 转换 结果 来说 都是 安全 </p>
<p><img src="/../img/C++/Pasted%20image%2020230531114341.png"><br><img src="/../img/C++/Pasted%20image%2020230531114341.png"></p>
<p><a href="#%E6%96%B0%E7%89%B9%E6%80%A7.md">新特性</a></p>
<p> C 语言 环境 中 我们 可 以 先 把 一 种 具体 类 型 指针<br> 如 int* 转 换 void* 类 型 然<br> 再 把void* 类 型 转换 double* 类 型<br> 而 编译 器 不 认为 这 是错误 。 然 这样的 做 法 确实 存在 着 不 易 察 党 的 安全 问题<br> ( 内 存 扩张 和 截断 )， 这 是 标准C 语 言 的 一 个 缺陷 </p>
<h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> d3 = <span class="number">1.25e+20</span>;</span><br><span class="line"><span class="type">double</span> d4 = <span class="number">10.25</span>;</span><br><span class="line"><span class="type">int</span> i2 = (<span class="type">int</span>)d3;</span><br><span class="line"><span class="type">int</span> i3 = (<span class="type">int</span>)d4;</span><br><span class="line"></span><br><span class="line">按照 从 浮 点 数 到 整 型 数 的 转换 语义 结 果 应 是 截 去 浮 点 数 的 小 数部分而 保留其 整数 部分</span><br><span class="line">因 此 i 会得 到 <span class="number">10</span>，</span><br><span class="line"></span><br><span class="line">d3 的 整数 部 分远远 超 了 一 个<span class="type">int</span> 所 能 表示 的 范围 </span><br><span class="line">i2 会 溢出</span><br></pre></td></tr></table></figure>

<h3 id="指针转换"><a href="#指针转换" class="headerlink" title="指针转换"></a>指针转换</h3><p>基本 数据 类 型 间 的 <strong>指针转换</strong> 一 般 说 必然 造成 内 存 截 断 或 内 存 访问 范围扩张<br>在 32 位 系统 ，int、long、float 都 具有 4 字 节 的 空间<br>虽 然 不 会 造成 内 存 截断 内 存 扩张<br> 它们 之间 的 <strong>指针 转换</strong><br>改变 了 <strong>编译 器</strong>对 指针 所指向 的 内 存单 元 的 <strong>解释方式</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">4</span><span class="number">-8</span></span><br><span class="line"><span class="type">double</span> d5 = <span class="number">1000.25</span>;</span><br><span class="line"><span class="type">int</span> *pInt = (<span class="type">int</span>*)&amp;d5;</span><br><span class="line"><span class="type">int</span> i4 = <span class="number">100</span>;</span><br><span class="line"><span class="type">double</span> *pDbl = (<span class="type">double</span>*)&amp;i4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从 内 存 访问 角度 来 , 你 通过 pInt 访问 它 指向 <span class="type">double</span> 类 型 变量 d5 是 安全 的</span><br><span class="line">(后面的 <span class="number">4</span> 字 节 “截断 ”了 ， 可访问 内 存 范围 缩小 )，但 是 其 值 绝对 不 会 d5 的 整数部分<span class="number">1000</span>， </span><br><span class="line">而 是 位 d5 开头 <span class="number">4</span> 字节 中 的 内 容 并 解释 <span class="type">int</span> 类 型 数 </span><br><span class="line">这 个 数 是 不可预料 的 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过 pDbl 访问 <span class="type">int</span> 类 型 变量 这 ， 得 到 的 数据 不一 定 就 <span class="number">100</span>， 况 且造成 了 可 访问 内 存 范围 “扩张 &gt;。 </span><br><span class="line">如 果 你往 里 面 写 数据 就 会 产生 运行 时 错误</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230531131558.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base objB2;</span><br><span class="line">Derived *pD2 = (Derived *)&amp;objB2;</span><br><span class="line"></span><br><span class="line">存在 的问题 : 通过 pD2 能 够 访问 的 内 存范围 “扩张 ”了 <span class="number">4</span> 字节 ,如果 访问 m_c可 能 引发 运行 时 错误 ,因为 pD2 指向 的 对 象 根本 就 没有 成 m_e 的 空间</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230531131959.png"></p>
<p>(1) 不 可 以 <strong>基 类</strong> 对 象 直接 转换 为 <strong>派生 类</strong> 对 象 无 论 直接 <strong>赋值</strong> 还 是<strong>强<br>制 转换</strong> 因 为 这 不 “自然 的 ”;<br>(2) 对 于 <strong>基本 类 型</strong> 的<strong>强制 转换</strong> 一 定 要 区 分 <strong>值的截断</strong> 与 <strong>内 存 截断</strong> 的 不 同;<br>(3) 如 果 你 坚持 要使 用强制 转换 必 须 同时 确保 <strong>内存访问的安全性</strong> 和 <strong>转换结果的安全性</strong> ;<br>(4) 如 果 确信 需 要 数据 类 型 转换 请 尽量使 显 式 ( 即强制 ) 数据 类型 转换 让 人 们 知道 发 了 什么 事 避 免让 编译 器 静 悄悄地 进行 隐 式 的数据 类 型 转换 。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标 识 符 可 以 任意 长<br>但 是 标准 C 语言规定 编 译器 只 取 前 31 个字符 作为 有 效 的 标识符<br>而 标准 C++ 则 取 前 255 个 字符 作为 有 效 的 标识 。</p>
<p>每 一 个 标识 符 都 具有 如 下 的 几 个 属性<br>值<br>值 类 型<br>名 字 、<br>存 储 类 型<br>作 用域范围<br>连 接 类 型 （可 见 性)、<br>生 存 期 等</p>
<p>C 函数 函 数 名 其 实 就是<br>函数 代码<br>在 内 存 中 的 首 地 址 在 编译 时 就 可 以 确定 其 值 因 此 是 一 个 常量 这 是 它 的 值<br>值的 类 型 是 函数 指针 类 型<br>存 储 类 型 默认 extern， 除 非 声明 为 static;，<br>作 用 域 范围为 文件 作用域 ;<br>连接 类 型 默认 为 外 连接 , 除非 声明 为 static;<br>生存 期 为 永久 〈 即 静态 )。</p>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符-关系运算符-逻辑运算符"><a href="#算术运算符-关系运算符-逻辑运算符" class="headerlink" title="算术运算符 关系运算符 逻辑运算符"></a>算术运算符 关系运算符 逻辑运算符</h4><h4 id="函数调用-类型转换-成员选择"><a href="#函数调用-类型转换-成员选择" class="headerlink" title="函数调用 类型转换 成员选择"></a>函数调用 类型转换 成员选择</h4><p>类型转换运算符<br>运行时类型识别运算符（typeid）<br>作用域解析(::)<br>动态内存分配 释放<br>类成员指针运算符</p>
<h4 id="运算符基本特性就是优先级和结合律"><a href="#运算符基本特性就是优先级和结合律" class="headerlink" title="运算符基本特性就是优先级和结合律"></a>运算符基本特性就是优先级和结合律</h4><p><img src="/../img/C++/Pasted%20image%2020230531133944.png"></p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h3 id="常量表达式-算术表达式-关系表达式-逻辑表达式-复合表达式-逗号表达式-条件运算符表达式-位运算表达式"><a href="#常量表达式-算术表达式-关系表达式-逻辑表达式-复合表达式-逗号表达式-条件运算符表达式-位运算表达式" class="headerlink" title="常量表达式 算术表达式 关系表达式 逻辑表达式 复合表达式 逗号表达式 条件运算符表达式 位运算表达式"></a>常量表达式 算术表达式 关系表达式 逻辑表达式 复合表达式 逗号表达式 条件运算符表达式 位运算表达式</h3><p>常量表达式在编译时就可求值</p>
<p>能 够 在 编译 时 求 的 程序 元 素 是 否需要 分 配 运行 时 的 存储 空间 呢 ?</p>
<ol>
<li><p>基本 数据 类 型 的 字面常量 枚举常量 、sizeof()、 常 量 表达 式 等 就 不需要分配存储 空间 ， 因 此 也 没有 存储 类型</p>
</li>
<li><p>字符 串 常 量 、const 常量 (尤其 ADTUDT 的 const 对 ) 都 要 分配 运行 时 的 存储 空间 即 有 特定 的 存储 类 型</p>
</li>
</ol>
<p>在 用 运算 “&amp;&amp;” 的 表达 式 ， 要 尽量 把 有 可 能 FALSE 的 表达 式 放在 “&amp;&amp;” 的 左边<br>在 用 运算 “||” 的 表达 式 中 要 尽量把 有可 能 TRUE 子表达式 “||” 左边.</p>
<h3 id="基本控制结构"><a href="#基本控制结构" class="headerlink" title="基本控制结构"></a>基本控制结构</h3><h3 id="选择判断结构"><a href="#选择判断结构" class="headerlink" title="选择判断结构"></a>选择判断结构</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">假设 有 两 个浮 点 变量 x 和 y， 精 度 定义 EPSILON = le<span class="number">-6</span>， 则 错误 的 比较 方式</span><br><span class="line">如下:</span><br><span class="line">	<span class="keyword">if</span>(x = y) / 隐 含 错误 的 比较</span><br><span class="line">	<span class="keyword">if</span>(x != y) / 隐 含 错误 的 比较</span><br><span class="line">应 该 转化 为 正确 的 比较 方式 :</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span>(x - y) &lt;= EPSILON) Ux Fy</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span>(x - y) &gt; EPSILON) Ux BEF y</span><br><span class="line">同 理 ，x 与 零 值比较 的 正确 方式 :</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span> (x) &lt;= EPSILON) /x 等 <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span> (x) &gt; EPSILON) Ix REF <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>if (NULL &#x3D;&#x3D; p)</p>
<p><img src="/../img/C++/Pasted%20image%2020230531135348.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230531135436.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230531135630.png"></p>
<p>数组 元 素 的 访问 是 真正 的 随机 访问 〈 直 接地 址 计算 )。 如 果 整个 数组 能 在 一<br>内 存 页 中 容纳 ， 那 么 在 对 整个 数组 进行操作 的 过 中 至少不 会 了 访问 数组 元 素<br>而 出 现 缺 页 中 断 页 面 调度 和 页 交换 等 情况 只 需要 一次 外 存 读取 操作 就 可 以<br>数组 所 在 的 整个 页 面 入 内 存 然 后 直接 访问 内 存 可 了 </p>
<p>在 示例 4-14 中 ， 左 边 的 写法 比 右边 的 写法 多 执行 Nr] 次 逻辑 判断 并 且前 者<br>的 还 辑 判断 打 了 循环 “流水 线 ” 作 ， 使 得 编译 器 不 能 对 循环 进行 优化 处 ，<br>降低 了 效率 如 果 和 非常 大 最好 采用 右边 的 写法 可 以 提高 效率 如 果 N 非常 小 ，<br>两 者 效率 差别 并不 明显 采 用 左边 的 写法比较 ， 因 为 程序 更 加 简洁 。</p>
<p><img src="/../img/C++/Pasted%20image%2020230531140922.png"></p>
<h2 id="2-第五章-常量"><a href="#2-第五章-常量" class="headerlink" title="2. 第五章 常量"></a>2. 第五章 常量</h2><h3 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x = <span class="number">-100.25f</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN SUCCESS 0x00000001</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *pChar = <span class="string">&quot;abcdef&quot;</span>; / 取 字 符 串常量的地址</span><br><span class="line">intt *pint = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">保存在符号表里 无法取地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译链接环境支持常量合并的 请打开</p>
<h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><p><code>#define</code> 预编译伪指令 字面常量<br>const 分配存储空间 外连接</p>
<h3 id="C-中-，const定义-的-常量-要-具体情况-具体-对-待"><a href="#C-中-，const定义-的-常量-要-具体情况-具体-对-待" class="headerlink" title="C++ 中 ，const定义 的 常量 要 具体情况 具体 对 待"></a>C++ 中 ，const定义 的 常量 要 具体情况 具体 对 待</h3><p>对 于 <strong>基本数据 类 型 的 常量</strong> 编 译 器 把 它 放 到 符号 表 中 而不 分 配 存 储空间 ,<br>而 ADITVUDT 的 <strong>const 对 象</strong> 则 需要 分配 存储 空间 (大对象)。<br>还 有 一 些情况 下也 需要 分 配 存储空间 ，<br>	例如 强制 声明 为 extern 的 符号常量<br>	或者 取 符号常量的地址 等 操作 ，<br>	都 将强迫 编译 器 为 这 些 常量 分 配 存储 空间 以 满足 用 户 的 要 求 </p>
<p>对于 <strong>基本 数据 类 型 const 常量</strong> 编 译器 重新 在 内 存 中 创建 它 的 一 个 <strong>拷贝</strong><br>你 通过 其 地 址 访问 到 的 就 这 个 拷贝 而 非 原始的 符号 常量</p>
<p> 对 于 构造 类 型 const 常量 实 上 它 是 编译 时不 允许修改 的 变量 ，<br>因此 如 果 你 能 绕 过 <strong>编译 器 的 静态 类 型 安全 检查机 制</strong> 就 可 以 在 运行 时 修改 内 存单 元，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> Ing = <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> *pl = (<span class="type">long</span>*)&amp;lng; / 取 常 量 的 地 址</span><br><span class="line">*pl = <span class="number">1000</span>; <span class="comment">//迂回修改</span></span><br><span class="line">cout &lt;&lt; *pl &lt;&lt; endl; / <span class="number">1000</span>， 修 改 的 是 拷贝 内 容 !</span><br><span class="line">cout &lt;&lt; Ing &lt;&lt; end]; / <span class="number">10</span>， 原 始 常量 并 没有 变 !</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Integer</span>() : <span class="built_in">m_Ing</span>(<span class="number">100</span>) &#123; &#125;</span><br><span class="line">	<span class="type">long</span> m_Ing;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> Integer int_1;</span><br><span class="line">Integer *pInt = (Integer*)&amp;<span class="type">int</span> <span class="number">1</span>; <span class="comment">// 去除常数属性</span></span><br><span class="line">pint-&gt;m_Ing = <span class="number">1000</span>;</span><br><span class="line">cout &lt;&lt; pInt-&gt;m_Ing &lt;&lt; endl; <span class="comment">// 1000, 修改const 对象</span></span><br><span class="line">cout &lt;&lt; int_].m_Ing &lt;&lt; endl; <span class="comment">// 1000, 迂回修改成功</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol>
<li><p>在 标准 C 语言 中 ，const 符号 常量 默认 是 外 连 楼 〔 分 配 存储 )，<br>也 就是说你不能在两个或以上编译单元中同时定义一个同名的const符号常量<br>也不能 把 一 个const 符号 常量 定义 放 在 一 个头文件 中 而 在 多 个 编译 单元 中 同时 包含 头 文件 </p>
</li>
<li><p>但 是 在 标准 C++ const符号 常量默认 是 内 连接 的 因 此 可 以 定义 在 头 文件 。<br>当 在 不 同 的 编译单元 中 同时 包含 头 文件 时 编 译 器 认为 它们 是 不 同 的 符号 常量<br>因 此每 个 编译 单元独立 编译 时 会 分 别 为 它们 分配 存 储 空间 ，<br>而 在 连接 时 进行常量 合并</p>
</li>
</ol>
<h3 id="契约性常量"><a href="#契约性常量" class="headerlink" title="契约性常量"></a>契约性常量</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">5</span><span class="number">-3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n= <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ReadValue</span>(n); <span class="comment">// 契约性 const, n 被 看 做 const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举常量"><a href="#枚举常量" class="headerlink" title="枚举常量"></a>枚举常量</h3><p>标 C++规定 枚 举 常量 的 值 可 以 扩展 的 并 非 受 限 于 一 般 的 整 数 的 范围</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gigantic</span></span><br><span class="line">&#123;</span><br><span class="line">	SMALL = <span class="number">10</span>,</span><br><span class="line">	GIGANTIC = <span class="number">300000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于 底层 如 何 实现 则 依赖 于 具体 的 环境 和 编译 器 厂商 可 能 会 不 同 的 语义 ，<br>请 查看 编译 器 文档 </p>
<p>以 C++ 程序 中 应 尽量 使 const 来 定义 符号 常量 包 括 字符 串 常量 。</p>
<p>非 静态 const 数据 成 员 是 属于 每 一对 象 的 成 员 <strong>只在某个对象生存期内是常量</strong><br>而 对 于 整个 类 来 说 它 是 可 变 ，<br>除非 static const。</p>
<p>因 为 类 可 以 创建 多 个 对 象 不 同 的 对 象 const 数据 成员 的 可以 不 同</p>
<p>不 能 在类声明 中初始 化 非 静态 const 数据 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100</span>;   / 错误 企 图 在 类 声明 中初始 <span class="type">const</span> 数据 员</span><br><span class="line">	<span class="type">int</span> array[SIZE];           / /错误 未 知 SIZE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非 静 const 数据 员 的初始化 只 能 在 类 的 构造 函数 的初始 化 列表 中 进行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> size); / 构造 函数</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> SIZE ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> size) : <span class="built_in">SIZE</span>(size) / 构造 函数 的初始 化 列表</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">A all00);   <span class="comment">// HR a HK SIZE (AA 100</span></span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">200</span>)</span>   <span class="comment">// AR b HY SIZE &#123;4% 200</span></span></span><br></pre></td></tr></table></figure>
<p>怎样才能 建立 在 整个 类 中 都 恒定 的 常量 ? 别 指望 const 数据 成员 了 ，<br>应该 用 类 中 的 枚 举 常 量 来 实现<br>枚举 常 量 不会 占用 对 象 的 存储 空间 它 们 在 编译 时 被 全 部 求 值<br>更 何况 它 定义的 是 一 个 匿名 枚 举 类 型<br>枚 举 常 量 的 缺点 是 不 能 表示 浮 点数 〈 如 PI-&#x3D;3.14159) 和 字符串</p>
<p> 可 以 用 另 一 种 方法 来 定义 类 的 有 对 象 共享 的 常量 ，即 static const，</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">5</span><span class="number">-8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>: <span class="comment">// 有 些语言 实现 可 能 不 支持 这样 的初始 化 如 Visual C++</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> SIZE1 = <span class="number">100</span>; / 静态常量 员</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> SIZE2 = <span class="number">200</span>; / 静态 常量 员</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> array <span class="number">1</span>[SIZE1]; <span class="comment">// 普通 员</span></span><br><span class="line">	<span class="type">int</span> array2[SIZE2]; <span class="comment">// 普通 员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实际-用-中-如-何-定-义-常量"><a href="#实际-用-中-如-何-定-义-常量" class="headerlink" title="实际 用 中 如 何 定 义 常量"></a>实际 用 中 如 何 定 义 常量</h3><h4 id="1-C程序"><a href="#1-C程序" class="headerlink" title="1. C程序"></a>1. C程序</h4><h5 id="1-1-多个编译单元或模块公用"><a href="#1-1-多个编译单元或模块公用" class="headerlink" title="1.1 多个编译单元或模块公用"></a>1.1 多个编译单元或模块公用</h5><p>1.1.1 在某个公用头文件中将符号常量<strong>定义为static并初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CommonDef.h </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX+LENGTH =<span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>然后每一个使用它的编译单元 <code>#include</code> 该头文件即可；<br>1.1.2 在头文件中使用 <strong>宏定义</strong><br>1.1.3 在 某个公用的头文件中将符号常量声明为<strong>extern</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CommonDef.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> MAX_LENGTH;</span><br></pre></td></tr></table></figure>
<p>并且在某个源文件中<strong>定义一次</strong>; </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>然后每个使用它的编译单元<code>#include</code> 上述头文件即可<br>1.1.4 整形常量 在某个公用<strong>头文件</strong>定义<strong>enum</strong>类型 然 后 每 一 个使 用 它 的 编 详单 <code>#include</code> 该头 文件 即 可 </p>
<h5 id="1-2-只为一个编译单元使用"><a href="#1-2-只为一个编译单元使用" class="headerlink" title="1.2 只为一个编译单元使用"></a>1.2 只为一个编译单元使用</h5><p>1.2.1 直接于编译单元开头位置将符号常量定义为static 并初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">foo.c</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>1.2.2 同1.1.1<br>1.2.3 同1.1.3 或在编译单元开头定义enum类型</p>
<h4 id="2-C-程序"><a href="#2-C-程序" class="headerlink" title="2. C++程序"></a>2. C++程序</h4><h5 id="2-1-多个编译单元或模块公用"><a href="#2-1-多个编译单元或模块公用" class="headerlink" title="2.1 多个编译单元或模块公用"></a>2.1 多个编译单元或模块公用</h5><p>2.1.1 在某 个 公用 的 头 文件 中 直接 在 某 名 字 空间 中 或者 全 局 名 字 空间 中 定义 符号常量 并 初始 化 有 无static无 所 谓 )， 例 :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CommonDef.h</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXLENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>

<p>每一个使用它的编译单元 <code>#include</code> 该 头 文件 即 可<br>2.1.2 在 某 公用 头 文件 中 并 且 在 某 名 字 空 间 中 或全 局 名 字 空 间 中 将 符号 常量 声明为 extem 的 例 :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CommonDef.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> MAX LENGTH;</span><br></pre></td></tr></table></figure>
<p>并 且在 某 个 源 文件 中 定义 一次 并 初始 :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>然后 每 一 个使 用 它 的 编 详 单元 机 nclude 上 述 头 文件即可<br>2.1.3 同1.1.3<br>2.1.4  定义 为 某 一 个 公用 类的 static const 数据成 员 并 初始<br>或 者定义为 类 内 的 枚 举 类 型 例 如 :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Utility.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX LENGTH;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">TIME_OUT= <span class="number">10</span></span><br><span class="line">hs</span><br><span class="line"><span class="comment">// Utility.cpp</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Utility:: MAX LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>然后 每 一 个使 用 它 的 编 详 单元 机 nclude 上 述 头 文件即可 </p>
<h5 id="2-2-只为一个编译单元使用"><a href="#2-2-只为一个编译单元使用" class="headerlink" title="2.2 只为一个编译单元使用"></a>2.2 只为一个编译单元使用</h5><p>2.2.1 同2.1.1<br>2.2.2 直接 于 该 编译 单元 〈 源 文件 开头 定义 符号<br>量 并 初始 〈 有 无 static 无所 谓 )， 例 如 :</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.C</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXLENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>2.2.3 同1.2.3</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 C 程序 中 ，const 符号 常量 定义 的默认 连接 类 (Linkage) 是 extern 的 即 外连接 (external linkage)， 就 全 局 变量 一 样<br>因 此 ， 如 果 要 在 头 文件 中 定义 必 须使用 static 关键字 ，<br>这 样 每 一 包含 头 文件 的 编译 单元 就会 分 别 有 该 常量 的 一份独立定 义 实体 〈 如 同 直接 在 每 一 个源 文件 中 分 别 定义 一 )，<br>否则会 导致 “redefinition”的 编译 器诊断 信息 ;<br>如果 在源 文件 中 定义 除 非 明确 改变 它 的 连接 类 型 static 〈 实际 上 是 存储 类 型 static, 连接 类 型 内 连接 ) 的 ,<br>否则 其他 编译 单元 可 以通过 extern声明 来访问 </p>
<p> C++ 程序 ，const 符号 常量定义 的 默认 连接 类 型 却 static 的 即 内 连(Cinternal linkage)，<br> 就 class 的 定义 一 样 这就是在 头 文件 中 定义 而 不 需要 static关键 字 的 原因 </p>
<p>字符 串 常量 的 定义 和 整 型 常量 的 定义 差不多 ， 但 是其类 型 <code>const char *</code>， 因 此<br>们 常常 这样 定义 它们 ;</p>
<p>const char* const ERR_DESP NO_MEMORY &#x3D; “There is no enough memory!”;</p>
<p>可 以 在头 文件 中 定义 并初始 ， 也 可 以 在 源 文件 中 定义 并 初始 化 但 是 二 者 差别 大 :</p>
<ol>
<li><p>如 果 在 头 文 件 中 定义 并 初始 化 那 包含 了 该 头 文件 的 每 一 个 编译 单元<br>不仅 会 为 一个 常量 指针 常量 (const char * const) 创建 一 个独立 的 拷贝项 ，<br>而 且 也 会 为 那个 长长 的 字符 串 字 面 量 创建 一 个独立 的 拷贝 项<br>就 相当 于在 每 一 个 编译单元 内 分 别 定 和 初 始化每 一 个 常量 ， 一次 一 个 样<br>这是与 整 型 或浮点 型 常量 的 定义 不 同 〈 它 们 在初始化 完 后 不 再 需要 那个 字面<br>营 )。<br>因 此 ， 每 一 个 编译单元 内 访问的 字符 串 常量 都 是它 自己 单独 创建 :<br>拷贝 衬间 的 开销 就 体现 在每 一 字符 串 字 面 量 的独立拷贝 上 ;</p>
</li>
<li><p>如 果 采 用 方法 ， 在 头 文件 中 声明 所有 常量 指针 常量 而在 源 文 中 定义并初始化 它们 ，<br>则 每 一 包含 头 文件 的 编译 单元 访问 的 不 仅 是 常量 指针常量 的 唯一 实体<br>而 且 字 符 串 字面 常量 也 是 唯一 的实体<br>这就 大 节约 了内 存 而卫 不 失效 率。<br>当然 我 们 完全 可 以 把 常量 合并 的 优化 交 给 编译 和 连接 器 来 完成 但 是 我 们</p>
</li>
</ol>
<p>还 是 提倡 由 自己 来 优化 常量 的 定义 。</p>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h2><p>对 于** 静态 链接 库** 的 函数 库 或 类 库 如 果 你 调用 了 其 中 的 函数 《无 论 是 直接 调用<br>还 是 间接 调用 )，<br>那 么 连接 器 从 相应 的 中 提取 这 些 函数 的 实现 代码 并 把它们 连接到 你 的 用 程序 ;<br>如 果 你 没有 调用 库 中 的 某 些 函数 则 连接 器 是不 会把 它们 的 实现代 码 连接 进来 的 即 使 该 包含 了 成 上 万 个 函数</p>
<p>如 果 你 用 的 是 动态 链接(DLL)， 则 运行 时 必须 将 有 DLL 都 找 到 运行 环境 的 相应 目录 下</p>
<p>如 果 程 中 任何 地 方 都 没有 调用 你 自己 编写 的 某 个 函数 的 话<br>编译器也不 会 为 函数 生成 可 执行 代码</p>
<h3 id="函数原型-定义"><a href="#函数原型-定义" class="headerlink" title="函数原型 定义"></a>函数原型 定义</h3><p>早先 C 语言 存在 函数 <strong>前 置 声明</strong> 的 概念<br>因 为 C 语言 环境 中 同 一 作用 域中 不 能 出 现 同名 的 全 局 函数</p>
<p>有 了 函数 前 声明 ， 即 把 函数 的 定义 体 放 在 函数 调用 后 面 的 任何 地 方 也 无 ，连接 器在 连接 时 能 够 找到 。</p>
<p>是 函数 前 置 声明 并 没有 给 出 函数 可 接受 的 参数 类 型和 个 数<br>于 是 编译 器 无 法对 函数 调用 语句 执行静态 类 型 安全 检查<br>〈 即 检查 实 参与参 的 个 数 类 型 及 顺序 等 是 呈 配 )。</p>
<p>导致 正确 的 参数 传递 从 而 出 现 运行时 错误 甚至 破坏 堆栈</p>
<p>解决 这 一问题 的 方法 就 是使 用 函数 原型 (ANSIISO C 从 C++ 借鉴 了 函数 原型 )。</p>
<p>{ 作 用 域 [函数 的 连接规范 ] 返回 类 [函数 的 调用 规范 ] 函数 (类 1 [ 形 参 1]，类型 2 [形参 2], …);</p>
<p>函数调用 中 参数 传递 本 质 就 用 实参 来 <strong>初始 化 形 参</strong> 而 不 是 替换 形参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *p)</span></span>; dni p 是 形参</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">C</span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *q = “abcd”;</span><br><span class="line">	<span class="built_in">f</span>(<span class="number">5</span>, q); /<span class="number">5</span> 和 q 是 实参</span><br><span class="line">	C&lt;<span class="type">int</span>&gt; a; /<span class="type">int</span> 是实 参</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数堆栈"><a href="#函数堆栈" class="headerlink" title="函数堆栈"></a>函数堆栈</h3><p>函数 堆栈 实际 上 使 用 的 是 程序 的 堆栈 内 存 空间 ， 虽 然 程序 的 堆栈 段 是 系统程序 分 配 的 一 种 静态 数据 ， 但 是 函数 堆栈 却 是 在 调用 到 它 的 时 候 才 动 态 分 配 </p>
<p>函数 堆栈 却 是 在 调用 到 它 的 时 候 才 动 态 分 配</p>
<p><img src="/ebooks-copy/desktop/%E7%AC%AC5%E7%AF%87_C_C_%20%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%A0%88%20-%20%E7%9F%A5%E4%B9%8E%20(2023_6_1%2002_50_50).html"></p>
<p><a href="https://www.zhihu.com/column/c_1277937360727257088">C&#x2F;C++ 修道院 - 知乎 (zhihu.com)</a></p>
<p><img src="/ebooks-copy/desktop/%E6%B5%85%E8%B0%88%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%20(2023_6_1%2002_57_45).html"></p>
<p><img src="/../img/C++/Pasted%20image%2020230601024956.png"></p>
<p><strong>栈段：</strong></p>
<p>　　1. 为函数内部的局部变量提供存储空间。<br>　　2. 进行函数调用时，存储“过程活动记录”。<br>　　3. 用作暂时存储区。如计算一个很长的算术表达式时，可以将部分计算结果压入堆栈。</p>
<p><strong>堆：</strong></p>
<p>　　堆能够根据需要自动增长。堆区域是用来动态分配的内存空间，用 malloc 函数申请的，用free函数释放。calloc、realloc和malloc类似：前者返回指针的之前把分配好的内存内容都清空为零；后者改变一个指针所指向的内存块的大小，可以扩大和缩小，它经常把内存拷贝到别的地方然后将新地址返回。</p>
<p><strong>数据段（静态存储区）：</strong></p>
<p>　　包括BSS段（Block Started by Symbol）的数据段。BSS段存储未初始化或初始化为0的全局变量、静态变量，具体体现为一个占位符，并不给该段的数据分配空间，只是记录数据所需空间的大小。数据段存储经过初始化的全局和静态变量。</p>
<p><strong>代码段：</strong></p>
<p>　　又称为文本段。存储可执行文件的指令；也有可能包含一些只读的常数变量，例如字符串常量等。</p>
<p>　　.**rodata段：**存放只读数据，比如printf语句中的格式字符串和开关语句的跳转表。也就是你所说的常量区。例如，全局作用域中的 const int ival &#x3D; 10，ival存放在.rodata段；再如，函数局部作用域中的printf(“Hello world %d\n”, c);语句中的格式字符串”Hello world %d\n”，也存放在.rodata段。</p>
<p>　　但是注意并不是所有的常量都是放在常量数据段的，其特殊情况如下：</p>
<p>　　1）有些立即数与指令编译在一起直接放在代码段。</p>
<p>　　2）对于字符串常量，编译器会去掉重复的常量，让程序的每个字符串常量只有一份。</p>
<p>　　3）用数组初始化的字符串常量是没有放入常量区的。</p>
<p>　　4）用const修饰的全局变量是放入常量区的，但是使用const修饰的局部变量只是设置为只读起到防止修改的效果，没有放入常量区。<br>　　5）有些系统中rodata段是多个进程共享的，目的是为了提高空间的利用率。</p>
<p>　　注意：程序加载运行时，.rodata段和.text段通常合并到一个Segment（Text Segment）中，操作系统将这个Segment的页面只读保护起来，防止意外的改写</p>
<h3 id="函数调用规范-调用约定-〈CallingConvention-。"><a href="#函数调用规范-调用约定-〈CallingConvention-。" class="headerlink" title="函数调用规范  调用约定 〈CallingConvention)。"></a>函数调用规范  调用约定 〈CallingConvention)。</h3><p>函 数 调用 规范 决定 了 函数 调用 的 **实 参 压 栈 退 栈 及 堆栈 释放 的 方式 **</p>
<p> Windows 环境 下 常用 的 调用 规范 :<br>(1) <code>_cdecl</code>: 这 是 CHHC 函数 的 默认 调用 规范 ,参数 从右 向 左 依次 传递 并 压 入<br>堆栈 由 调用 函数 负责 堆栈 的 清 退 </p>
<p>(2) <code>_stdcall</code>， 这 是 Win API 函数使 用 的 调用 规范 。 参 数 从右 向 左 依次传递 并 压 入 堆栈 外 被 调用 函数 负责 摊栈 的 清 退<br>该 规范 生成 的 函数 代码“cdecl 更 小， 但 当 函 有 可 变个 数 的 参数 时 会 转 为 <code>_cdecl</code> 规范<br>(3) <code>_thiscall</code>: 是 C++ 非 静态 员 函 数 的 默认 调用 规范 不 能 用 个 数可 变 参数<br>(4) <code>_ fastcall</code>: 该规范 所 修饰 的 函数 的 实 参 将 直接 传递 到 CPU 寄存 器 中 而 不<br>是 内 存 堆栈 不能 用 于 成 员 函 数</p>
<p>凡是 接口 函数 必须 显 式 地 指定 其 调用 规范 除 接口 函数 类 的 非态 员 函 non-static member function)。</p>
<h3 id="函数的连接规范"><a href="#函数的连接规范" class="headerlink" title="函数的连接规范"></a>函数的连接规范</h3><p>只 要 它们使 用 一 的 员 对 齐 方式 和 布局 方案 、 一 的 函数 调用 规范 、 一 致 virtual function 实现 方式 总 之就 是 一 致 C++ 对 象 模型</p>
<h3 id="参数传递规则"><a href="#参数传递规则" class="headerlink" title="参数传递规则"></a>参数传递规则</h3><p>C 语言 , 函数 的 参数 和 返回 的传递式 有 两 : 值传递 (pass by value) 和 地 址传递 〈 即 指针 传递 ，pass by pointer)</p>
<p>C++语言 中 增加 了 引用 传递 〈pass by reference)。 </p>
<p>如 果 函 数 有 参数 那使 void 而 不 要 空 着<br>这 是 因为 标准 C 把 的 参数 列表 解释 为 可 以 接受任何 类 和 个 数 的 参数<br>而 标准 C++ 则 把 空 的 参数 列表 解释 为 可 以 接受任何 参数<br>在 移植 C+HC 程序 时 尤其 要 注意 这 方面 的 不 同</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span></span>; / 良好 的 风格</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; / 不 良 风格</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetValue</span><span class="params">(<span class="type">void</span>)</span></span>; / 良好 的 风格</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetValue</span><span class="params">()</span></span>; / 不 良 的 风格</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230601050908.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230601051429.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String <span class="keyword">operator</span> + (<span class="type">const</span> String &amp;lh, <span class="type">const</span> String &amp;rh)</span><br><span class="line">| &#123;</span><br><span class="line">	| String temp;</span><br><span class="line">	temp.m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strljen</span>(s<span class="number">1.</span>m_data) + <span class="built_in">strlen</span>(s<span class="number">2.</span>m_data) + <span class="number">1</span>]];</span><br><span class="line">	<span class="built_in">strcpy</span>(temp.m_data, s<span class="number">1.</span>m_data);</span><br><span class="line">	<span class="built_in">strcat</span>(temp.m_data, s<span class="number">2.</span>m_data);</span><br><span class="line">	retumtemp; /执行 string 对 象 及 其 字符 串 内 容 的 拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 于相 加 函数 应 当 用 “返回 对 象 值 的 方式 返回 String 对 象 这 将把 局 部 对 temp 及 其 真正 的 字符 串 值 拷贝 一 给 调用 环境 的 接收 者 如 果 改 “返回 引用 ” 那 么 函数 返回值 是一 个指向 局 部 对 ttmp 的 “引用 ”( 即 地 址 )， 而 temp 在函数 结束 时 被 自动 销毁 将 导致 返回 “引用 ”无效</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">Func</span><span class="params">(<span class="type">void</span>)</span> &quot; </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>; /str 数组 创建 在 函数 堆栈 上 ， 并 用 字符 串 / 常量 来 初始 化 在 末尾 自动 添加 ^<span class="number">0</span>” </span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(str) &lt;&lt; endl; </span><br><span class="line">	HA2 cout &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; end]; </span><br><span class="line">	#<span class="number">11</span> <span class="keyword">return</span> str; / 该 语句 存在 隐患 ，str 指向 的 内 存单 元 将 被 释放 &#125; 但 下 程序 则 是 正确 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">Func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *p = <span class="string">&quot;hello world&quot;</span>; / 字符 串 常量 存放 在 程序 的 静态 数据 区</span><br><span class="line">	/ 来 尾 自动 添加 \<span class="number">0</span>&#x27;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl; HA</span><br><span class="line">	cout &lt;&lt; <span class="built_in">strlen</span>(p) &lt;&lt; endl; HWA</span><br><span class="line">	<span class="keyword">return</span> p; / 返回 字符 串常量 的 地 址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230601053851.png"><br>“创建 一个 临时 对 并 返回 它 ” 的 过程 是 不 同 的，<strong>编 译 器</strong>可 以 直接 把 临时 对 象 创 建 并初始 化 <strong>外 部 存储 单元</strong> 中 省 了 拷贝 和 析 构 开销 提 高 了 效率 </p>
<h3 id="存储类型以及作用域规则"><a href="#存储类型以及作用域规则" class="headerlink" title="存储类型以及作用域规则"></a>存储类型以及作用域规则</h3><h3 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h3><p>extern 、auto 、static、register，</p>
<p>extern 和 static 用 来标识永久 生存 期 限 的 变量 和 函数<br>而 auto 和 register 则 用 来 标识 临时 生存 期 限 的 变量</p>
<p>全 局 变量 和 全 局 函数 的 存储 类 型 extern 能 够 定义 在 它们之 后 的 同一个 编译 单元 内 的 函数 所 调用<br>变 量和 函数 显 式 地 加 上 exterm 声明 ，那么 其他 编译 单元 中 的 函数 也 能 调用 它们</p>
<p>显式生命为static的全局变量和全局函数具有static存储类型 只能被同一个编译单元内的函数调用</p>
<p>局 部 变量 默认 具有 auto 存储 类 型 除 非 static 或 register 来 定义<br>它们 的作用 域 是程序 块作用 域 连 接 类 型 都 内 连接 在 进入 函数 的 时候 创建 ，在 函数退出 的时 候 销毁<br>register 和 auto 只 能 用 于 声明 局 部 变量 和 局 部 常量 </p>
<p>全局常量默认 存储类型 static<br>除非在定义了它的编译单元之外的其他编译单元中 显式的用extern声明 否则不能被访问<br>（就是拿过来用的时候 加个extern 声明一下）</p>
<p>局 部 符号 常量 (注意 不是 函数 内 出 现 的 字面 常量 ) 的 默认 存储 类 型 auto，<br>除非 显式 地 定义 static 或 register.</p>
<p>把 那些 经 常 用 的 变量 例如 循环 计数 器 直接 放 到 CPU 寄存 器 ， 可 以避免 在 寄存 和 内 存 之 间 频 地 交换 数据 因 此 能 提高 程序 的 运行 效率 </p>
<h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p>在 标准 C 语言 ， 这 些 范围包括 文件 函 数 程 序 和 函数 原型</p>
<p>标准 C++中 除了 这 4 种 外 有 两 作用 域 类 型 类 和 名 字 空 间 其 中 名 字 空 间 是 可 以 跨 文 件 +</p>
<p>S (label) 是 具有 函数 作用 域 的 惟一 一 种 标识 符 这 就 是 说 不 论 你 的 标号定义 在 函数 中 的 哪 一行 ， 也 不 论 定义 在 函数 内 撕套得 多 么 深 的 程序 块 内 它 都能够在 函数 体内 任何 一 个地 方 访问 , 因此 也 叫做 函数 级 的 标识 。 标号 一 般 用 在 goto| 语句 ， 如 果 goto 语句 没有 使 用 到 该 标号 那 么 该 标号 将 忽略</p>
<p>即 使部 变量 的 存储 类 型 声明 static， 它 仍然 具有 程序 作 用 </p>
<p>在 函数 中 毁套 的 程序 块 可 以 定义相同 名 字 的 变量 在 内 层 的 变量 玫 蔽外 层 的 同名 变量<br>当局 部 变量 与 某一 个全 局 变量 同名 ， 在 函数 内 部将史 蔽 全 局 变量<br>如 果 某 一 个 员 函 数 内 定义 了 与 类 的 某 一 个 数据员 同 名 的 局部 变量 ， 那么 这个 局 部 变量 将 遮蔽 该 同名 数据 成 。</p>
<p>如果 一 个 标识 符 能 够 在 其他 编译 单元 中 或 者 在 定义 它 的 编译单元 中 的 其 他 范围内 被 调用 ， 那 么 它 就 外 连接 的 外 连接 的 标识 符 需要 分 配 运行 时 的 存储 空间</p>
<p>如 果 一 个标识符 能 在 定义 它 的 编译单元 中 的 其他 范围 内 被 调用 但 是 不 能 在他 编译 单元 中 被 调用 那 么 它 就 内 连接</p>
<p>一个仅 能 够 在 声明 它 的 范围 内 被 调用 的名 字 是 无 连接 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> f0</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a; /a 是 连接 的</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123; ... &#125;; / 局 部 类 是 连接 的 具 有 程序 作用 域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230601062801.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230601062725.png"></p>
<p>对 ADT&#x2F;UDT 的 输入 参数 应该 “ 值 传递 改 “const 公 传 递 “， 目的 提高 效率 例 如 ， 将 void Func(Aa) 7H void Func(const A &amp;a).<br>对 于 基本 数据 类 型 的 输入 参数 不 要 “ 值 传递 ”的 方式 改 “const 信传递 “， 否 则 既 达 不 到 提高 效率 的 目的 又让 人 费解<br>例如， 不 要<br>void Func(const int x) 改 void Func(const int 人 x)。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(constA &amp;a)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutputString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pStr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StringCopy</span><span class="params">(<span class="type">char</span> *strDest, <span class="type">const</span> <span class="type">char</span> *strSrc)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = <span class="built_in">GetString</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-指针-数组-字符串"><a href="#4-指针-数组-字符串" class="headerlink" title="4. 指针 数组 字符串"></a>4. 指针 数组 字符串</h2><p>int* a,b,c; 《&#x3D;》int <code>*a</code>, b,c;</p>
<p>取 地 址 〈&amp;) 和 反 引 用 〈(<code>*</code>)。</p>
<p>准确的说，与 编译器的目标平台 有关。<br>如果目标平台是32位的，那么sizeof (void*)就是<strong>4</strong>，<br>如果是64位的，那么sizeof就是8，<br>如果是16位的，就是2。 sizeof (void*)的含义就是获取一个指针的大小。<br>指针的本质就是内存地址，因此指针的大小和内存空间有关。<br>32位的机器内存空间是2G（windows系统），<br>因此指针的大小必须是 log_2 (2times 1024^3) &#x3D; 31 ，凑个整数那就是32bit。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在 语义 上 ， 下 标 操作 符返 回 的 是一 个 元 素 的 引用 。a[3] &#x3D; 100;<br>编译器 计算地 址 a + 3 * sizeof (inb， 得 到 0x004284FC， 并 返回 地 址 所 指 对的 引用 而不是 返回 “45” 这 个<br>a[3] &#x3D; 100; &#x2F; 转换 为 *a+ 3) &#x3D; 100;<br>cout &lt;&lt; a[3] &lt;&lt; endl， &#x2F; 转换 cout &lt;&lt; *(a + 3) &lt;&lt; endj;</p>
<p>组 名 字本 身 是 一 个 指针 ， 是 一 个 指针 常量 即 a 等价 int * const a，<br>因 此你 不 能 试图 修改 数组 名 的 值 </p>
<p>a &#x3D;&#x3D; &amp;a[0]</p>
<p>int a[10] &#x3D; {0};<br>int b[10] &#x3D;{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>a&#x3D;b; &#x2F;不仅语义 不 对 何 a 也 不 能 被修改</p>
<p>int b[100]; &#x2F; sizeoftb) &#x3D; 400 bytes， 未初始<br>int c[ ]&#x3D; {1, 2,3, 4,5}; I FBP RA S, sizeof(c) &#x3D;20 bytes, 初 始<br>int d[5] &#x3D; {1, 2, 3, 4,5, 6, 7}; &#x2F; 错误 ! 初始 值 越界<br>int e[10] &#x3D; {5, 6, 7, 8, 9}; &#x2F; 元 素 个 数 10， 指 了 前 5 个 元 素 的初始 值 剩<br>VW 下 的 元 素全 部 自动 初始 化 0<br>int [10] &#x3D; {5,, 12,,2}; &#x2F; 错误 ! 不 能 跳 过 中 间 的 某些 元 素</p>
<p>C++&#x2F;C 可 以 在 运行 时 进行 数组 的 越界 访问 检查<br>这 是 因为 数组 大小 的 信息 保存 在程序 中 的 某 地 方 一 般<br>就 是 放 在 数组 第 一 个元 素 位 置 的 <strong>前 面</strong> 占用 一 int 变量 的 字节数 ,<br>它 地 址 a-sizeof(int)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] &lt;&gt; <span class="type">int</span>* <span class="type">const</span> a;</span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>] &lt;&gt; <span class="built_in">int</span> (* <span class="type">const</span> b)[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>] &lt;&gt; <span class="built_in">int</span> (* <span class="type">const</span> c)[<span class="number">4</span>][<span class="number">5</span>]:</span><br></pre></td></tr></table></figure>

<p>数组 是 不 能 从 函数 return 语句 返回<br>数组 可 以作为 函数 的 参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a[ ], <span class="type">int</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(a)&lt;&lt;endl; <span class="comment">// 是 4 而 不 400</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">100</span>] = &#123; <span class="number">0</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; endl; <span class="comment">// 400</span></span><br><span class="line"><span class="built_in">output</span>( x, <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a[ ][<span class="number">20</span>], <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; line; i++ ) &#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span>; | &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">			cout &lt;&lt; a[i][j] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>][<span class="number">20</span>] = &#123; &#123; <span class="number">100</span> &#125; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; endl; <span class="comment">// 800</span></span><br><span class="line"><span class="built_in">output</span>( x, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a[ ][<span class="number">20</span>], <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function">cout &lt;&lt; <span class="title">sizeof</span><span class="params">(a)</span> &lt;&lt; endl</span>; <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; line; i++ ) &#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span>; | &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">			cout &lt;&lt; a[i][j] &lt;&lt; endl; <span class="comment">// a 是 一 个 指向 一 维 数组 的 指针a+l 就 是 指向 二 行 的 指针</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>][<span class="number">20</span>] = &#123; &#123; <span class="number">100</span> &#125; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; endl; <span class="comment">// 800</span></span><br><span class="line"><span class="built_in">output</span>( x, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">const</span> <span class="type">int</span> (*a)j[<span class="number">20</span>], <span class="type">int</span> line)</span> </span></span><br><span class="line"><span class="function"> a[i][j] 访问转换为 *<span class="params">(a + (i * <span class="number">20</span> + j) * <span class="keyword">sizeof</span>(<span class="type">int</span>))</span>.</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>char *p &#x3D; new char[1025]; &#x2F; 分 配 空间<br>delete []p; &#x2F; 删除 数组 空间</p>
<p>它 不 会删除 不 属于 它 内 存单 元 也不 会 泄漏 哪怕 是 一 字 节 的 内 存单 元<br>因为你 明白 地 告诉 了 编译 : 这 是 在 释放 一 个 字符 数组 ,<br>“ 请 ” 它 去 p 指向 的 字符 数组 大小 信息 《数组 的 元 素 个 数 它 被 编译 器 保存 在 程序 的 某 个 地 方 )，<br>然 后 按照 这 个 大 小 来 释放 动态 内 存 这 就 是 数组 的 释放 (delete[]) 的语义 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">char</span> (*p3)[<span class="number">4</span>] = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">5</span>][<span class="number">4</span>]; /OK! 退化 第 一 维 语 义 等</span><br><span class="line"><span class="built_in">int</span> (*p4)[<span class="number">5</span>] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>][<span class="number">5</span>]; /OK! 退化 第 一 维 语 义 等</span><br><span class="line"><span class="built_in">char</span> (*p5)[<span class="number">5</span>][<span class="number">7</span>] = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>][<span class="number">5</span>][<span class="number">7</span>]; OK! 退化 第 一 维 语 义 等 价</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> [jp3; <span class="comment">// 删除 p3</span></span><br><span class="line"><span class="keyword">delete</span> []p4; <span class="comment">// 删除 p4</span></span><br><span class="line"><span class="keyword">delete</span> []p5; <span class="comment">// 删除 p5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> arrChar_1[ ] = &#123;<span class="string">&#x27;a’,’b&#x27;</span>,\<span class="number">0</span><span class="string">&#x27;,&#x27;</span>d<span class="string">&#x27;,’e&quot;&#125;;</span></span><br><span class="line"><span class="string">char arrChar_2[ ] = &quot;hello&quot;;</span></span><br><span class="line"><span class="string">char *p = “hello”;</span></span><br><span class="line"><span class="string">cout &lt;&lt; sizeof(arrChar_1) &lt;&lt; endl; /S$， 表 示该 数组 $ 字 节</span></span><br><span class="line"><span class="string">cout &lt;&lt; strlen(arrChar 1) &lt;&lt; endl; 2， 表示 字符 串 长 度 2</span></span><br><span class="line"><span class="string">cout &lt;&lt; sizeof(arrChar_2) &lt;&lt; endl; /6， 表 示 数 组 6 字节</span></span><br><span class="line"><span class="string">cout &lt;&lt; strlen(arrChar_2) &lt;&lt; endl; WS, RARER BREA 5</span></span><br><span class="line"><span class="string">cout &lt;&lt; sizeof(p) &lt;&lt; endl; / 4， 表示 指针 p 占 4 字 节</span></span><br><span class="line"><span class="string">cout &lt;&lt; strlen(p) &lt;&lt; endl; /5， 表 示字符 串 长 度 $</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">默认 char * 表 示 字 符 。 例 如 :</span></span><br><span class="line"><span class="string">char ch =&#x27;</span>a’; / 用 字符 <span class="string">&#x27;a来 初始 化 字符变量 ch</span></span><br><span class="line"><span class="string">char *pChar = &amp;ch; / 字符 指针 指向 字符变量</span></span><br><span class="line"><span class="string">cout &lt;&lt; pChar &lt;&lt; endi; / 错 把 字符 指针 当做 字符 串</span></span><br><span class="line"><span class="string">正确 用 法 :</span></span><br><span class="line"><span class="string">cout &lt;&lt; *pChar &lt;&lt; endl; / 取 一 个 字符</span></span><br></pre></td></tr></table></figure>

<p>某 些 字符 串 函 数 并 不 会 自动 目标 字符 串 结 尾 追 加 ‘\0’，<br>例 如 strncpy和 strncat， 除 非你指定 于 值 比 源 串 的 长 度 大1<br>strcpy 和 strcat 会 把 源串 的 结束 符 一 并 拷贝 到 目标串 中 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> _cdecl (* FuncPtr)( <span class="type">const</span> <span class="type">char</span>*); / 定义 一 种 函数 指针 类</span><br><span class="line">FuncPtr fp_1= strlen ;</span><br><span class="line">FuncPtr fp_2 = puts ;</span><br><span class="line"><span class="type">double</span> _cdecl (*fp_3)( <span class="type">double</span> ) = sqrt ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">fp_1</span>(‘I am a software engineer.”) ;</span><br><span class="line"><span class="type">double</span> d = ( *fp_3 )( <span class="number">10.25</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> _cdecl (* fp[<span class="number">5</span>])( <span class="type">double</span> ) = &#123; sqrt, fabs, cos, sin, exp &#125;;</span><br><span class="line"><span class="keyword">for</span> (intk = <span class="number">0</span>;k &lt;<span class="number">5</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Result :&quot;</span> &lt;&lt; fp[k]( <span class="number">10.25</span> )&lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般 的 函数 调用 语句 可 以 在 编译 时 就 完成 这 个 绑 定《叫做 静态 决议 或 静态 连接 )<br>运行 时 连接</p>
<p>类 的 员 函 有 4 种 类 型 inline、virtual、static、normal。</p>
<p>inline 函数 在 运行 时会 展开 ， 虽 然 语 言 允许 取 其 地 址 但 是 没有 太 大 意义 。virtual 成 员 函 数 的 地 址 指 的其 vtable 中 的 位 置 ，<br>static成员 函 数 的 地 和 普通 全 局 函数 的 地 址 没有 任何 区 别 ;<br>普通 成 员 函 数 的 地 和 一 般 函 数 的 地 址 也 没有 区 别<br>就 是 函数 代码 在 内 存 中 的 真实地址，<br>但 是 由 于它 的 调用 要绑 定到 一个 实 实在 在 的 对 象 ，<br>因 此无 论 是其 函数 指针的 声明 方式 还 是 其 地 址 的 获取 方法 都 比较 特别</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">7</span><span class="number">-14</span>。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( <span class="type">void</span> )</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CTest::f0&quot;</span> &lt;&lt; endl; &#125; / 普通 员 函</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">g</span><span class="params">( <span class="type">void</span> )</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CTest::2()&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// HAR RA</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">( <span class="type">void</span> )</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CTest::hQ)&quot;</span> &lt;&lt; endl; &#125; /W 虚拟 员 函</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">///...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*GFPtr)</span><span class="params">( <span class="type">void</span> )</span></span>; / 定义 一 个全局 函数 指针 类</span><br><span class="line">	GFPtr fp = CTest::g ; </span><br><span class="line">										</span><br><span class="line">	<span class="built_in">fp</span>();                </span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(CTest::*MemFuncPtr)</span><span class="params">( <span class="type">void</span>)</span></span>; <span class="comment">// 声明 类 成 员 函 数 指针 类</span></span><br><span class="line">	MemFuncPtr mfp_] = &amp;CTest::f; <span class="comment">// 声明 成 员 函 数 指 针 变 并 初始</span></span><br><span class="line">	MemFuncPtr mfp2 = &amp;CTest::h; / /注意 获取 成 员 函 数 地 址 的 方法</span><br><span class="line">	CTest theObj ;</span><br><span class="line">	(theObj .*mfp_1)() ; / 使 用 对 和 成 员 函 数 指 针 调 用 成 员 函</span><br><span class="line">	(theObj .*mfp_2)() ;</span><br><span class="line">	CTest *pTest = &amp;theObj ;</span><br><span class="line">	(pTest-&gt;*mfp_1)(); / 使 用 对象 指针 和 成 员 函 数 指针 调用 成 员 函</span><br><span class="line">	(pTest-&gt;*mfp_2)() ;</span><br><span class="line">&#125;</span><br><span class="line">输出 结果 </span><br><span class="line">CTest::<span class="built_in">g</span>()</span><br><span class="line"><span class="function">CTest::f0</span></span><br><span class="line"><span class="function">CTest::hO</span></span><br><span class="line"><span class="function">CTest::f0</span></span><br><span class="line"><span class="function"><span class="title">CTest::h</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>为 了 与 静态 员 函数 区 别<br>取 virtual 函数 和 普通 员 函 数 的 地 址 需要 使用 “&amp;” 运 算<br>〈 取 静态 成 员 函 数 地址 也 可 以 使 用 它 但 是 没有 必要 )。</p>
<p>由 于 纯 虚 函数 没有 实现 体 而 非纯 虚 函 有 实现 体<br>且 虚 函数 都是 通过 vptr 和 vtable 来 间接 调用 的<br>因 此 取 虚 函数 的 地 址 将 得 到该虚 函 数 实现体 vtable 中 的 索引号<br>要 想得到 虚 函 数 实现 体 的 真实 地 址 ,还需要 首先 从 对 象入手 ，<br>找到 vptr 的 位 置 进 而 找到 vtable 的 所 在<br>然 后 根据 函数 指针 的 大 和虚 函 数 的索引 ， 取 出 虚 函 数 的 真实 地 址 </p>
<h3 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h3><p>int m;<br>int&amp; n&#x3D;m;<br>n 既 不 是m 的 拷贝 也 不 是指向 m 的指针 ， 其实n 就 m 自己 </p>
<p>引用 在 创建 的 同时 必须初始 化 即 引用 到 一个 有 效 对象</p>
<p>const int&amp; rint &#x3D; 0;</p>
<p>创建 一 个 临时 的 int 对象 用 0 来 初始它 然 后 再 用 它 来 初始 化 引用 rint，<br>而 该 临时 对 象 将 一 直 保 到 rint 销毁 的 时 候 才 会 销毁。<br>所以，不 要 用 字面 常量 来 初始化引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">给 引用 赋值 并 不 是 改变 和 原始 对 象 的 绑 定 关系</span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b= <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span>&amp; rInt =a; /rint 引用 到 a，rInt 等 <span class="number">10</span></span><br><span class="line">rInt = b; <span class="comment">// rInt Al a 都 变 成 1000</span></span><br></pre></td></tr></table></figure>

<p>引用 的 创建 和 销毁 并 不 会 调用 类 的 拷贝 构造 函数 和 析构 函 数<br>在 语言 层面 引 用 的 用 和对 象 一 样<br>在 二 进 制 层面 引 用 一 般 都 是 通过指针 来 实现 的 只 不过 编译 帮 我 们 完成 了 转换 </p>
<p>引 用 的 主要 用 途修饰 函数 的 形参 和 返回 值</p>
<h2 id="5-第八章-C-c高级数据类型"><a href="#5-第八章-C-c高级数据类型" class="headerlink" title="5. 第八章 C++&#x2F;c高级数据类型"></a>5. 第八章 C++&#x2F;c高级数据类型</h2><p> C 语言 stuct， 有 时 也 称 用户 自 定义 数据 类 (User defined Type, UDT)。<br> 抽象 数据 类 型 (Abstract Data Type, ADT)，<br> 在 C++ 环境 ， 我 们 把 C 风格 struct 叫做 POD (Plain Old Data) 对象</p>
<p> structyclass 当做 参数 传递 给 函数 ， 默 认为 值 传 递 其 中的 数组 将 全 部 拷贝 到 函数 堆栈<br> 当 你 UDTADT 中 包含 数组 员 的 时 候 最 好使 指针 或 引用传递该 类 型 对 象<br> 并 且 一 定 要 防 让 数组 元 素 越界 否 则 它 覆盖 后的 结构成 员 </p>
<p>memset (&amp;s, 0x00, sizeof (Student))<br>&#x2F;&#x2F; 可 以 仅指 定 第 一成 员 的初 值 来初始 POD 对 象 后面 的 员 将 全 部 自动初始 化 为0， 就 数组 的始 化 一样<br>Student s &#x3D; {0};</p>
<p>一</p>
<p>对 象 间 的 包含 指 一 类 型 对 象 充当 了 另 一 个 类 型 定义 的 数据 成 ，:从 而 也 就 充当 了 它 的 对 象 的 成 ， 即 两 对 象 间 存 has-a 关系<br>虽然 对 象 不 能 自 包含 但 可 以 自 引用 ， 而 且 两 个 类 型 可 以 交叉 引用 ， 这种 关系称 holds-a 关系<br>| 个 对 象 不能 自 包含 无 论 是 直接 的 还 间接 的 因 为 编译 器 无法 为 计算 sizeof 值 ， 也 就 不 知道 给这 样 对 象 分 配 多 少 存储 空间<br><img src="/../img/C++/Pasted%20image%2020230601161745.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230601161855.png"></p>
<p>而 于对 齐 〈 将 大 小 调整 到 机器 字 的 整数<br>) 的 考虑 每 对 象 的 存储 空间 中 可 能 会 存在 填补 字 节 ， 这 些 字 节 单元 不 会 初始<br>化 而 具有 上 次 用 留 下 “ 脏 值 ”( 随 机 值 )。 显 然 每 对 象填补 字节 的 内 容 是<br>,会 相同 的 这就是 说 如 果编译 器 支持使用 逐 位 比较 的默认 方法 来 比较同类型 对象<br>结果 肯 定 是 不 对</p>
<h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>C 语言 位 各成 员 的 类 型 必须 int、unsigned int、signed int 等 类 型 ，C++ 还 允 许 使 char、long 等 类 型<br>不 允许 用 指针 类 型 或 浮 点 类 型 作为 位 域 的 成 员 类 ，| 因为 它们 可 能 导致 无效 的 值 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DateTime</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> year ;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> month :<span class="number">4</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> day  :<span class="number">5</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hour  :<span class="number">5</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> minute : <span class="number">6</span>;</span><br><span class="line"><span class="number">6u</span>nsigned <span class="type">int</span> second : <span class="number">6</span>;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span> (DateTime) &lt;&lt; endl; <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>可 以 定义 非 具 名 的 位 域 成 ， 其 作用 是 相当 于 占 位 符 可 用 来 隔离 两 相 邻 的<br>位 域 成 。 如 示例 8-7， 由 于 第 二 个 位 域 员 没有 名 字 ， 因 此 不 能 直接访问 它 所 在 的位</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct DateTime</span><br><span class="line">&#123;</span><br><span class="line">	//...</span><br><span class="line">	unsigned int day :5;</span><br><span class="line">	unsigned int :2</span><br><span class="line">	unsigned int hour :5;</span><br><span class="line">	//...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可 以 定义 长 度 0 的 位 域 成 ， 其作用是 迫使 下一 个 员 从 下 一 个 完整 机 器 字 〈Word) 开始 分 配 空间</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DateTime</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> day <span class="number">25</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> :<span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hour <span class="number">255</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(DateTime) &lt;&lt; endl; <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>即使位 域 有 成 员 的位 数总 和 达 不 到 整 字 节 的倍数 位 对 象 也会 对 齐 到 机 器 字 长<br>不 能使 用 访问 数组 元 素 的 方法(<code>[]</code>) 来访问位 域 员 的 单个 位<br>如 果 有 这 种 需要 ， 请使 用 位运算 (~、区 、|、&gt;&gt;、&lt;&lt;、^ 及 其 &#x3D; 的组 合 运算 ) 或 者使 <code>std::bitset&lt;N&gt;。</code></p>
<h3 id="成员对齐"><a href="#成员对齐" class="headerlink" title="成员对齐"></a>成员对齐</h3><p>对 于 复合 类 〈 一 般 指 结构 和 类 ) 的 对 象 如 果 它 的 起 始 地 址 能 够 满足 其 中 要求 最 严格 〈 或 最 高 的 那个 数据 员 的 自然 对齐 要 求 那 么 它 就 是 自然 对 齐 的<br>如果 那 个 数据 员 又 是一 个 复合 类 型 对 象 则 依次 类 推 直 到 最 后 都 基本 类 型数据 成 员 </p>
<p>在 C++&#x2F;C 的 基本数据 类 型 中 如 果 不 考虑 enum 可 能 的 大 值 所 需 的 内 存 字节 数 ，double 就 对 齐 要 求最 严格 的 类 型 ， 其 次 int 和 float， 然 后 short、bool 和 char。</p>
<p>直接 依照 声明 顺序 来 存放 ， 即 复合 类 型 中 存在 多 个 访问 〈 即 C++ 类 中 的 每public. private 和 protected 访问 限定 )， 至 少 也 会 保证 每 个 内 的 有 数据 员 是| 按照 声明 顺序 来 存放 </p>
<p>至 于 先 声明 的 员 会 放 在 地 址 还 是 低地 址 处 完 全 是由 编译 器 实现 来 决定 的 而且 – 般 都 采用 “按照 声明 的 先后 顺序 从 低地 址 到 高 地址 依次 放 各 个 成 ” 的 方案</p>
<p>为了对象数组 要实现自然对齐</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>&#123; RED = <span class="number">0x01</span>, BLUE, GREEN, YELLOW, BLACK&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sedan</span> <span class="comment">// 私家 车</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> m_hasSkylight; RRARS</span><br><span class="line">	Color m_color; / 颜色</span><br><span class="line">	beol m_isAutoShift; / 是 否 是 自动 档</span><br><span class="line">	<span class="type">double</span> m_price; / 价格 〈 元 )</span><br><span class="line">	BYTE m_seatNum， / 座位数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230601165034.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230601165745.png"></p>
<p>使 offsetof 宏 这 个 宏 专 门 用 来计算 数据 员 相 对 于 对 象 起始地址 的 真实 含 移 量 它 会 把 有 隐 含 员 也 计算 进去 比 如庶 函 表 指针vptr。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::cout &lt;&lt; “<span class="built_in">offsetof</span>(Sedan, m_hasSkylight) =” &lt;&lt; <span class="built_in">offsetof</span>(Sedan, m_hasSkylight) ;</span><br><span class="line">std::cout &lt;&lt; “<span class="built_in">offsetof</span>(Sedan, m_color) = ” &lt;&lt; <span class="built_in">offsetof</span>(Sedan, m_color) ;</span><br><span class="line">std::cout &lt;&lt; “<span class="built_in">offsetof</span>(Sedan, m_isAutoShift) = ” &lt;&lt; <span class="built_in">offsetof</span>(Sedan, m_isAutoShift) ;</span><br><span class="line">std::cout &lt;&lt; “<span class="built_in">offsetof</span>(Sedan, m_price) =” &lt;&lt;&lt; <span class="built_in">offsetof</span>(Sedan, m_price) ;</span><br><span class="line">std::cout &lt;&lt; “<span class="built_in">offsetof</span>(Sedan, m_seatNum) = ” &lt;&lt; <span class="built_in">offsetof</span>(Sedan, m_seatNum) ;</span><br></pre></td></tr></table></figure>

<p>编 译器 不 会 随便 地 在 任意 一 个 逻辑 内 存 地址 上来 创建 C++&#x2F;C的 变量 和 对 象<br>它们 在内 存 中 的 起 地 址 需要 满足 一 定 的 条 件 数 据 成 员 也 并 一 定 是 挨 在一起 的<br>而且每个 数据 员 的 地 址 也 不是 随便 安排 的 都 需要 经 过 编译器的 精心 规划 和 计算<br>这 才能提高 对 及 其 员 的 访问 效率</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sedan s;</span><br><span class="line">std::cout &lt;&lt; “Address of s =” &lt;&lt; (<span class="type">void</span>* )&amp;s ;</span><br><span class="line">std::cout &lt;&lt; “offset of m_hasSkylight =” &lt;&lt; ((<span class="type">char</span>*)&amp;s.m_hasSkylight — (<span class="type">char</span>*)&amp;s) ;</span><br><span class="line">std::cout &lt;&lt; “offset of m_color = ” &lt;&lt; ((<span class="type">char</span>*)&amp;s.m_color — (<span class="type">char</span>*)&amp;s) ;</span><br><span class="line">std::cout &lt;&lt; “offset of m_isAutoShift =” &lt;&lt; ((<span class="type">char</span>*)&amp;s.m_isAutoShift — (<span class="type">char</span>*)&amp;s) ;</span><br><span class="line">std::cout &lt;&lt; “offset of m_price =” &lt;&lt; ((<span class="type">char</span>*)&amp;s.m_price — (<span class="type">char</span>*)&amp;s);</span><br><span class="line">std::cout &lt;&lt; “offset of m_seatNum = ” &lt;&lt; ((<span class="type">char</span>*)&amp;s.m_seatNum — (<span class="type">char</span>*)&amp;s);</span><br></pre></td></tr></table></figure>

<p>综上 所 述 类 的 数据 成 员 类 型 的 选择 声 明 顺 序 即 排列 采 用 的 员 对 齐 方式<br>都 将影响对 象 的 实际 大小 和 访问 效率 </p>
<h3 id="联合-union"><a href="#联合-union" class="headerlink" title="联合 union"></a>联合 union</h3><p>联合 的 另 一 个 妙用 就 用 来 解析 一 个 寄存 器 或 多 字 节 内 存 变量 的 高 字 节 的 值<br>而 不 需要 我 们 手工 用 位 运算 符 来 解析 它们 。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">KeyCode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> keyNum ;</span><br><span class="line">	<span class="type">char</span> byteArr[<span class="number">2</span>] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚 举 类 型还 可 以 是 匿名</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件 控制 块 (FCB) 的 数组</p>
<h2 id="6-第九章-编译预处理"><a href="#6-第九章-编译预处理" class="headerlink" title="6. 第九章 编译预处理"></a>6. 第九章 编译预处理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(1) #include &lt; &gt;</span><br><span class="line">(2) #Hinclude &quot; &quot;</span><br></pre></td></tr></table></figure>
<p>第 一 种 形式 一 般 用 来 包含 开发 环境 提供 的 库 头 文件 它 指示 编译 预 处 理 器 开发 环境 设 定 的 搜索 路 中 查找 所 需 的 头 文件<br>第 二 种 形式 一 般 用 来 包含 自己 编写 的头 文件 它 指示 编译 预处 理 器 首先 在 当前 工作 目录 下 搜索 头 文件 如 果 找 不 到 的 话再 到 开发 环境 设 定 的 路 径 中 去 查找 。</p>
<p>内 部 包含  卫 哨<br> 为了 避免 同一 个 编译 单元 包含 同一 个 头 文件 内 容 超 过 一次</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// stddef.h</span></span><br><span class="line">#ifndef_STDDEF H INCLUDED_</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDDEF_H INCLUDED _</span></span><br><span class="line">					/ / 头 文件 内 容</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    /!STDDEF H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “stddef.h”</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “stddef.h” /! No problem!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>外 部 包含 卫  哨</p>
<p>当 一 个 头 文件 被 一 个源 文件 反 复 包 含 多 次 避免 多 次 查找 和 打开 头 文件 的 操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined ( INCLUDED_STDDEF_H_)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INCLUDED_STDDEF_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//!_ INCLUDED _STDDEF_H_</span></span></span><br></pre></td></tr></table></figure>

<p>在 头 文件 中 :<br>(1) 包含 当前 工程 中 所 需要 的 自 定义 头 文件 〈 顺 序 自 );<br>(2) 包含 第 三 方程 序库 的 头 文件 ;<br>(3) 包含标准 头 文件 。<br>在 源 文 中 :<br>(1) 包含 源 文件 对 应 的 头 文件 《如 果 存 );<br>(2) 包含 当前 工程 中 所 需要 的 自 定义 头 文件 ;<br>(3) 包含 第 三 方程 序 库 的 头 文件 ;<br>(4) 包含 标准 头 文件 </p>
<p>宏 定义 具有 文件作用</p>
<p>宏定义 <code>#define</code> 关键 字 后 出现 的 第一 个 连续字符 序列 作为 宏 名<br>剩 下 的 部 作为 宏体</p>
<p>宏 不 会 进入 符号<br>即 宏替换 后 出 了 语法 错误 编 译 器 也 会 将 错误<br>定位 到 源 程序中<br>而 不 是 定位 到 具体的 某个 宏 定义 </p>
<p>定义 带 参数 的 宏 ， 宏 和 左 括号 之 间 不 能 出 现 空格 否 则 使 用 时 会 出问题<br>但 是 编译 器 不 检查 出 这 种 错误</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">define <span class="title">OUTPUT</span><span class="params">(word)</span> cout &lt;&lt; <span class="meta">#word &lt;&lt; endl</span></span></span><br><span class="line"><span class="function"><span class="title">OUTPUTI</span><span class="params">( like swimming very much.)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I like swimming very much.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT (str)#str</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">TEXT</span>(Hello World);</span><br><span class="line">(str)<span class="meta">#str(Hello World);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PL 2 (2 * PI)</span></span><br><span class="line"></span><br><span class="line">带 参数 的 宏 体 和 各个形 参 应 该 分 别 用 括号 括 起 来</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x)((x) * (x))</span></span><br><span class="line"></span><br><span class="line">不 要 在 引用 宏 定义 的 参数 列表 中 使 用 增 和 减 量 运算 符 否则 将 导致 变量的 多 次 求值</span><br><span class="line"><span class="type">int</span> n=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">SQUARE</span>(n++&#125;;</span><br><span class="line"><span class="type">int</span> x = ((n++) * (n++));</span><br><span class="line"></span><br><span class="line">其结果 将 <span class="number">30</span> 而 不 是 期 望 <span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>用 宏 来 构造 一 些 重复 、 数据 和 函数 混合 的 功 能 较 特 殊 的代码 段 时候 其 优点就显示 出 来 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE DYNAMIC(class_name) \</span></span><br><span class="line"><span class="meta">protected: \</span></span><br><span class="line"><span class="meta">static CRuntimeClass* PASCAL _GetBaseClass(); \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">static const AFX_DATA CRuntimeClass class##class_name; \</span></span><br><span class="line"><span class="meta">virtual CRuntimeClass* GetRuntimeClass() const;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE _DYNCREATE(class_name) \</span></span><br><span class="line"><span class="meta">DECLARE_DYNAMIC(class_name) \</span></span><br><span class="line"><span class="meta">static CObject* PASCAL CreateObject();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> TEXT</span></span><br></pre></td></tr></table></figure>

<p>不 要 使 用 宏 来 定义 新 类 型 名 应 该 使 typedef， 否则 容易 造成错误<br>给 宏 加 注释 时 请 使 块 注释 〈<code>/* */</code>)， 而 要 使 用 行 注释 </p>
<p>对 于 较 长 的 用 频率 较高 的 重复 代码 片段 建 议 用 函数 或 模板<br>对 于 较 短 的 重复代码 片段 可 以 用 带 参数 的 宏 定义</p>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#if 0</span><br><span class="line">	… / 希望 禁止 编译 的代码</span><br><span class="line">	... / 希望 禁止 编译 的 代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>编译 伪 指 <code>#error</code> 用 于 输出 与 平台 、 环 境 有 关 的 信息</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(WIN32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> ERROR: Only Win32 platform supported!</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> MFC requires C++ compilation (use a .cpp suffix)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>编译伪指令#pragma 用于执行语言实现所定义的动作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">pragma <span class="title">pack</span><span class="params">(push, <span class="number">8</span>)</span> <span class="comment">/* 对 象 员 对 齐 字 节数 所</span></span></span><br><span class="line"><span class="comment"><span class="function">#pragma pack(pop)</span></span></span><br><span class="line"><span class="comment"><span class="function">#pragma warning(disable:4069)  /*不要产生C4069警告 */</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>构 串 操作符 # 只 能修饰 带 参数 的 宏 的 形 参 它 将 实 参 的 字符 序列<br>转换 字符 串 常量<br>而 不 是 实 参代表 的值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRING(x) #x #x #x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT(x) <span class="string">&quot;class&quot;</span> #x <span class="string">&quot;Info&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>合并 操作符 ## 将 出现在 其 左右 的 字符 序列 合并 成 个新 的标识</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS NAME(name) class##name</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MERGE(x, y) x##y#x</span></span><br><span class="line"></span><br><span class="line">classSysTimer</span><br><span class="line">meTome</span><br></pre></td></tr></table></figure>
<p><img src="/../img/C++/Pasted%20image%2020230602074658.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> * <span class="type">const</span> pDouble = <span class="built_in">new</span>(nothrow) <span class="type">double</span>[ <span class="number">10000000</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>( pDouble == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot;allocate memory failed on line&quot;</span>&lt;&lt;(_ LINE <span class="number">-2</span>)</span><br><span class="line">&lt;&lt; <span class="string">&quot;in file&quot;</span> &lt;&lt; FILE &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-文件结构-程序板式"><a href="#C-文件结构-程序板式" class="headerlink" title="C++文件结构 程序板式"></a>C++文件结构 程序板式</h3><p> 头 文件 的 有 内 容 最 终都 会 被 合并 到 某 一 个 或 几 个 源 文件 ，<br> 如 此 将 一 个 包含 的 头 文件 递归 地 展开 后 形成 的 源 文件 叫 编译单元<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> *x，y; / 此 y 不 会 误解 为 指针</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* PINT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp; RINT;</span><br><span class="line">PINT pl, p2; / 两 个 指针</span><br><span class="line">RINT ril=i r2=j; /两 引用</span><br></pre></td></tr></table></figure></p>
<h3 id="C-命名规则"><a href="#C-命名规则" class="headerlink" title="C++命名规则"></a>C++命名规则</h3><h2 id="7-C-面向对象程序设计方法"><a href="#7-C-面向对象程序设计方法" class="headerlink" title="7. C++面向对象程序设计方法"></a>7. C++面向对象程序设计方法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">继承</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Funcl</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func2</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func4</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">Funcl</span>(); </span><br><span class="line">b.<span class="built_in">Func2</span>();</span><br><span class="line">b.<span class="built_in">Func3</span>();</span><br><span class="line">b.<span class="built_in">Func4</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++ 虚函数，抽象基类， 动态绑定 (Dynamic binding) 多态 (Polymorphism)<br>构成 了 出 色 的 动态 特性</p>
<p>为 了 使 这 种 行为 可 行 我 们 把基类 Shape 中 的 函数 Draw0O 声 明 为 虚 函 数<br>然 后在 派生 类 中 重新定义 Draw()<br>使 之绘制 正确 的 形状 这 种 方法叫覆盖 〈Override)。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">// Draw() </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">void</span>)</span></span>; / /Draw0O 为 虚 函数 不写<span class="keyword">virtual</span> 也会变成虚函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽 象 类 的唯 – 目 的 是 让 其派生 类 继承 并 实现 它 的 接口 方法 (Method)，<br>因 此 它 通 也 被 称 为抽象 基 类 〈Abstract Base Class) </p>
<p>如 果 将 基 类 的 虚 函 数 声明 为 纯虚 函数 那 么 类 就 定义 了 抽象 基类 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123; <span class="comment">// Shape 是 抽象 基类</span></span><br><span class="line">ublic:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>; / <span class="built_in">Draw</span>(<span class="number">0</span> 为 纯 虚 函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将一 个 函数初始 化 0 意味 着 函数 地 址 将为 0，<br>这就是 在 告诉 编译 器 不 要 为 函数 编 址 从 而阻止 类 的 实例 化行为<br>C++ 中 只 有虚 函 数 才可 以 被 初始 化 0</p>
<p>一般 的 信息 隐藏 是 把类 的 有 数据 员 声 明 private 或 protected 的<br>并 提供 相应 get set 函数 来 访问 对象 的 数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> [Rectangle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">IRectangle</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetLength</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span> </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetLength</span><span class="params">( <span class="type">float</span> newLength)</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">virtual</span> <span class="type">float</span> GetWidthQ <span class="type">const</span> = <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetWidth</span><span class="params">(<span class="type">float</span> <span class="keyword">new</span> Width)</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> RGB <span class="title">GetColor</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span> ; <span class="comment">// RGB : unsigned long</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetColor</span><span class="params">(RGB newColor)</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">CalculateArea</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span> DrawQ) = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> IRectangle* _stdcall CreateRectangleQ; /入 口 函数</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleImpl</span> : <span class="keyword">public</span> [Rectangle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RectangleImplQ : <span class="built_in">m_length</span>(<span class="number">1</span>), <span class="built_in">m_width</span>(<span class="number">1</span>), <span class="built_in">m_color</span>(OxOOFFEC4D)&#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">RectangleImpl</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetLength</span><span class="params">( <span class="type">const</span> &#123; <span class="keyword">return</span> m_length; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> SetLength(<span class="type">float</span> newLength) &#123; m_length = newLength; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> GetWidth() <span class="type">const</span> &#123; <span class="keyword">return</span> m_width; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> SetWidth(<span class="type">float</span> newWidth) &#123; m_width = newWidth; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> RGB GetColor() <span class="type">const</span> &#123; <span class="keyword">return</span> m_color; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> SetColor(RGB newColor) &#123; m_color = newColor; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> CalculateArea() <span class="type">const</span> &#123; <span class="keyword">return</span> m_length * m_width; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> +Draw() &#123; cout &lt;&lt; <span class="string">&quot;RectangleImpl::Draw(Q)&quot;</span> &lt;&lt; endl; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">private</span>:</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">float</span> m_length;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">float</span> m_width;</span></span></span><br><span class="line"><span class="params"><span class="function">	RGB mcolor;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">	IRectangle* stdcall IRectangle::CreateRectangleO</span></span></span><br><span class="line"><span class="params"><span class="function">	&#123;Return <span class="keyword">new</span>(nothrow) RectangleImpl;&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>每 一 个 具有 虚 函 数 的 类 都 叫做 多 态 类，<br>这 个 虚 函 数 或者是 从基 类 继承 来 或者是 自己 新 增加<br>C++ 编译 器 必须 为 每 一 多 态 类 至 少 创建 一 个 虚 函 数 表 (vtable )，<br>它 实 就 是一 个 函数 指针 数组<br>其 中 存放 着这 个类 所 有 的 虚 函 数 的 地 址 及 该 类 的 类、型信息<br>其 中 也 包括 那些 继承但 未 改写 《Overrides) 的 虚 函 数</p>
<p>每一 个 多 态 对有 一 个 隐 含 的 指针 成 ， 它 指向 所 属 类 型 vtable， 这就 vptr。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">(*(p-&gt;_vptr[slotNum]))(p, arg-list); <span class="comment">// 指针 当 作 数组 来 用 最 后 改写 为 指针 运算</span></span><br></pre></td></tr></table></figure>

<p>派生 类 定义 中 的 名 字 〈 对 象 函数 ) 将 义无反顾 地 遮 项 〈( 即 隐藏 )掉 、<br>基 类 中 任何 同名 的 对 象 函数</p>
<p>基 于 这 样 的 规则 ， 如 果 派生 类 定义 了 一 个 与 基类 的 虚 函 数 同名 的 虚 函 数<br>但 是 <strong>参数 列表 有 所 不 同</strong><br>那 这就 不 会 编译 器 认为 是对 基 类 虚 函 数 的 改写 (Overrides)， 而 是 <strong>隐藏</strong><br>所 以 也 不 可 能 生 运行 时 绑 定</p>
<p>要 想 达成 运行 时 <strong>绑 定</strong> 的 效果 ，<br>派 生 类 和 基 类 中 同名 的 虚 函 数 必须 具有 相同 的 原型 ，<br>也 即 相同 Signature〈 返 回 类 型可 以 不 同 这是 C++ 的 一 个 特征 一 协 变)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IRectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">IRectangle</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">()</span> </span>= <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleImpl</span> : <span class="keyword">public</span> [Rectangle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RectangleImplQ) : <span class="built_in">m_length</span>(<span class="number">1</span>), <span class="built_in">m_width</span>(<span class="number">1</span>), <span class="built_in">m_color</span>(Ox0OFFEC4D) &#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">RectangleImpl</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">int</span> scale)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;RectangleImpl::Draw(int)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// (1)</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;RectangleImpl::Draw()&quot;</span> &lt;&lt; endl; &#125; (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">float</span> m_length;</span><br><span class="line"><span class="type">float</span> m_width;</span><br><span class="line">RGB mcolor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IRectangle *pRect = [Rectangle::<span class="built_in">CreateRectangle</span>();</span><br><span class="line"><span class="keyword">if</span> (pRect == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">pRect-&gt;<span class="built_in">Draw</span>(); <span class="comment">// FA-F pRect MatAS2R HW TRectangle*, ATLAH IRectangle::</span></span><br><span class="line">/Draw0 执行 静态 类 型 检查 但 由 pRect 指向 的 对 象实际 是</span><br><span class="line">/&#123; Rectanglelmpl <span class="number">9</span>, <span class="function">FAM hse Fl <span class="title">Rectanglelmpl::Draw</span><span class="params">()</span>!</span></span><br><span class="line"><span class="function">pRect-&gt;<span class="title">Draw</span><span class="params">(<span class="number">200</span>)</span></span>; /W 同 理 由 于 下 ectangie 类 并 没有 此 类 原型 的 函数 因 此 拒绝</span><br><span class="line">/ 编译 除 pRect 的 类 型 RectangleImpl* 。 此 <span class="built_in">Draw</span>(<span class="number">0</span>) 非 彼</span><br><span class="line">/DrawgO</span><br><span class="line">pRect-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line">pRect = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如 果 RectangleImpl 不 重 定义 Draw0O 函 数 那 下 面<br>代码 ， </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">RectangleImpl *pRectImpl = <span class="keyword">new</span> RectangleImpli</span><br><span class="line">pRectImpl-&gt;DrawQ); /<span class="built_in">f</span> (<span class="number">3</span>)</span><br><span class="line">pRectImpl-&gt;<span class="built_in">Draw</span>(<span class="number">200</span>); <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure>
<p> 将 无法 编译 因 为 (3) 处 调用 的 Draw0 是 基 类 的 函数 它 RectangleImpl 中 的 同名<br>| BR Drawn eT, BRT!</p>
<h3 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Shape *pShape)</span> <span class="comment">// SAHA</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pShape-&gt;<span class="built_in">Draw</span>(); / 或 : (*pShapej.<span class="built_in">Draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">Circle aCircle;</span><br><span class="line">Cube aCube;</span><br><span class="line">Sphere aSphere;</span><br><span class="line">:<span class="built_in">Draw</span>(&amp;aCircle); <span class="comment">// 绘制 一 circle</span></span><br><span class="line">:<span class="built_in">Draw</span>(&amp;aCube); /W 绘制 一 cube</span><br><span class="line">:<span class="built_in">Draw</span>(&amp;aSphere); / 绘制 一 Sphere</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RTTI也是一种运行时多态 dynamic_cast&lt;&gt; 和 typeid 运算 符<br>依赖 RTTI 会 导 致 严重 的 效率 低下</p>
<p>如 果 确 实 需要使 用 多 态 数 组 请使 STL 容器 配合 普通 指针 或者 智能 指针 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SmartPtr&lt;Shape&gt; ShapeSmartPtr;</span><br><span class="line">ShapeSmartPtr shapes[<span class="number">3</span>];</span><br><span class="line"><span class="function">ShapeSmartPtr <span class="title">p</span><span class="params">(<span class="keyword">new</span> Shape(Point(<span class="number">1</span>, <span class="number">1</span>)))</span></span>;</span><br><span class="line"><span class="function">ShapeSmartPtr <span class="title">q</span><span class="params">(<span class="keyword">new</span> Circle(Point(<span class="number">2</span>, <span class="number">2</span>), <span class="number">5</span>))</span></span>;</span><br><span class="line"><span class="function">ShapeSmartPtr <span class="title">r</span><span class="params">(<span class="keyword">new</span> Rectangle(Point(<span class="number">3</span>, <span class="number">3</span>), Point(<span class="number">4</span>, <span class="number">4</span>)))</span></span>;</span><br><span class="line">shapes[<span class="number">0</span>] = p;</span><br><span class="line">shapes[<span class="number">1</span>] = q;</span><br><span class="line">shapes[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span> &lt; <span class="number">3</span>; ++i)</span><br><span class="line">shapes[i]-&gt;<span class="built_in">Draw</span>();</span><br></pre></td></tr></table></figure>
<h3 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h3><p><img src="/../img/C++/Pasted%20image%2020230602093920.png"></p>
<p>如 果 基 类 已 经 插入 了 vptr， 则 派生 类 将 继承 和 重用 vptr;</p>
<p>如 果 派 生 类 是 从 多 个 基 类 继承 或 有 多 个 继承 分 《从 所 有根类 开始 算起 )，<br>而 中 若干 个 继承 分 上 出 了 多 态 ，<br>则 派生 类 将 从 这些 分 中 的每 个 分 上 继承 一 个vptr，<br>编 译 器 也 将 为 它 生 成 多 个 vtable，<br>有 几 vptr 就生成 几 个 vtable (每 vptr 分 别 指向 中 一 )，<br>分 别 与它 的 多 态 基 类 对 应 ;</p>
<p>vptr 在 派生 类 对 象 中 的 相对 位 置 不 会 随 着 继承层次 的 逐渐 加 深 而 改变<br>并且现在 的 编译 器 一 般 都 vptr 放 在 有 数据 员 的 最 前 </p>
<p>为 了 支持 RTTI， 为 一 多 态 类 创建 一 type_info 对 象<br>并 把 地 址 保存在 vtable 中 的 固定 位</p>
<p><img src="/../img/C++/Pasted%20image%2020230602094557.png"></p>
<p>vtable 也 是一 个 函数 指针 数组 按 理 说 也 只 能 存放 类 型 相同 的 函数 指针 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__cdecl *PVFN)</span><span class="params">(<span class="type">void</span>)</span></span>; / 通用 的 虚 函 数 指针 类</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	type_info *_pTypelnfo;</span><br><span class="line">	PVFN _arrayOfPvfn&#123;]; / 虚 函 数 个 数 由初始 化 语句 确定</span><br><span class="line">&#125; VIABLE;</span><br></pre></td></tr></table></figure>

<p>如 果派 生 类 改写 了 基 类 的 虚 函 数<br>则 这 个 函数 的 地址 在派生 类 vtable 中 的位 置 它 在其 基类 vtable 中 的 位 置 一致<br>(覆盖)</p>
<p>虚 函 数 第一 次 出现时 它 vtable 中 的 位 置 旦 确定 就 不随 派生 层次 的 增加 而 改变<br>除 非 改 了 它 和 其 他 虚 函 数 class 中 第 一 次声明 的 顺序 </p>
<p>派生 类 没有 改写 基 类 虚 函 数 被 继承 下来并 插入派生 类 vtable 中<br>(与 该函数 所 在 基 类对 应 下 来 的 那个 vtable)，<br>且 在 派生 类 vtable 中 的 位 置 其基 类 vtable 中 的 位 相 同 </p>
<p><img src="/../img/C++/Pasted%20image%2020230602102846.png"></p>
<p> 类的 静态 数据 员 可 以 class 的 定义 中 直接 初始 化<br> 但 是要 清楚 : 这 只 是声明并 给 它 提供 了 一 个 初 值 而 已<br> 还 必须 在 某 一 个 编译 单元 中 把 它 定义 一 次〈 即 分 配 内存)。</p>
<h2 id="8-对象的初始化-拷贝-析构"><a href="#8-对象的初始化-拷贝-析构" class="headerlink" title="8. 对象的初始化 拷贝 析构"></a>8. 对象的初始化 拷贝 析构</h2><p>”初始 化 是 在 对 象 创建 的 同时 使 初 直接 填充 对 象 的 内 存单 元 因 此<br>不 有 数据 类 型 转换 中 间 过 程 也 就 不 会 产生 临时 对 象</p>
<p>赋值 则 是在 对 象 创建 好 后 任何 时 候 可 以 调用 的 而 且 可 以 多 次 调用 的 函数<br>由 于它 调用 的 “&#x3D;” 运 算 符<br>因 此 可 能 需要 进行 类 型 转换 即 会 产生 临时 对象</p>
<p>如果程序员没有为一个多态类显式地定义 默认构造函数 拷贝构造函数 析构函数或拷贝赋值函数<br>那么 编译 器会 自动 地 生成 相应 的 函数 它 们 都public inline的 ,<br>并 在 其中 插入 正确 初始 化 或 修改 vptr 数 据 员 值 代码 ，<br>从 而 确保基 类 对 和 派生 类 对 象 构造 时 及 在 它们 之 间 拷贝时<br>vptr 能 够向 重新 指向 恰当 的 vtable.<br>这样 四 个 函数 就 分 别 叫 做<br>非 平凡 默认 构造函数<br>非 平凡 拷贝 构造 函数<br>非 平凡 析 构 函数 和<br>非 平凡 拷贝 赋值 函数 </p>
<p>在 构造 函数 体内 来 初始 化 数据 不 是 真正 意义 上 的初始化 而 是 赋值</p>
<p>由 于 构造 函数 是 创建 一 对象 时 自动 调用 的 第 一 个 成员 函数<br>因 此 我 们也 愿意 把 构造 函数 体内 的 赋值 语句 当成 初始 化 来 看</p>
<p>真正 的 初始 化 是 用 所 谓 “初始 化表达式表”( 简称 初始 化 列表 ) 进行<br>初始 化 列表 位 于 构造 函数 参数 表 之 后 在 函数 {} 之 前</p>
<p>如 果 类 存在 继承 关系 派 生类可 以 直接 在其 初始 化 列表 里<br>调用 基 类 的 特定构造 函数 以 向 它 传递 参数<br>因 为 我们 不 能 在 初始 化 对 象 时 访问 基 类 的 数据 成 员</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x); /A 的 构造 函数</span><br><span class="line">vas B : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> x, <span class="type">int</span> y); /B 的 构造函数</span><br><span class="line">Buin x, <span class="type">int</span> y) : <span class="built_in">A</span>(x) / 在 初始 化 列表 里 调用 A 的 构造 函数</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 的 非 静 const 数据 成 和 引用 成 员 只 能 在 初始 化 列表 里 初始 化<br>因 为它们 只 存在 初始 化 语义 而 不 存在 赋值 语义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int m;</span><br><span class="line">int &amp;n=m;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">A(void); BRA</span><br><span class="line">A(const A&amp; other); / 拷贝 构造 函数</span><br><span class="line">A&amp; operator =( const A&amp; other); / 赋值 函数</span><br><span class="line">&#125;;</span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">B(const A&amp; a); /B 的 构造 函数</span><br><span class="line">Private:</span><br><span class="line">A ma; / 成 员 对</span><br><span class="line">&#125;;</span><br><span class="line">/ (1) 采用 初始 化 列表 的 方式初始</span><br><span class="line">B::B(const A&amp; a) : m_a(a)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">(2) 采用 函数 体内 赋值 的 方式 初始</span><br><span class="line">B::B(const A&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">m_a=a; // 〈 调 了 A 的 默认 构造 函数 )， 再 调用类 A 的 赋值 函数 才 将 参数 a赋 m_a。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 对于 内 部 数据 类 型 的 数据 员 而 言 两 种 初始 化 方式 的 效率 几乎 没有 区别<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">F</span>(<span class="type">int</span> x, <span class="type">int</span> y); / 构造 函数</span><br><span class="line">Private:</span><br><span class="line"><span class="type">int</span> m_x;</span><br><span class="line"><span class="type">int</span> m_y;</span><br><span class="line">&#125;</span><br><span class="line">CL) 采用初始 化 列表 的 方式初始</span><br><span class="line">F::<span class="built_in">F</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">m_x</span>(x), <span class="built_in">m_y</span>(y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">2</span>) 采用 函数 体内 赋值 的 方式初始</span><br><span class="line">F::<span class="built_in">F</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">m_x=x;</span><br><span class="line">my=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>初始化顺序序 并不 一 定 与 你在 初始 化 列表 中 为 它们 安排 的 顺序 一 致<br>编 译 器 总 是按照 它们 在 类 中 <strong>声明 的 次序</strong> 来 初始 化 的<br>所以最 好 是 按照 它们 的 声明 顺序 书写 员 初 始 化 列表 </p>
<p>如 果 各 个 员 的 初始 化 存在依赖 关系<br>要 注意 顺序 问题<br>可 以 调整 下 数据员 的 <strong>声明 顺序</strong> 避免 这 个 问题</p>
<p>构造 函数首先 调用每 一 个基类 的 构造 函数<br>然 后 调用成 员 对 象 的 构造 函数<br>而 每 一 基类 的构造 函数 又 将 首先 调用 它们 各 自 基类 的 构造 函数 直 到 最 根 。 </p>
<p>析 构 会 严格 按照 对 象 构造 相反 的 次 序 执行 该 次 序 是 唯一 的 否 则 编译 器 将 无 法 自动 执行 析 构 过 ;</p>
<p>数据 员 的 初始 化 次 序 完全 不 受 它们 在 初始 化 列表 中 出 现 次 序 的 影响<br>只由 它们 在 类 中 声明 的 次 序 决 定 因 为 这 个 顺序 是 唯一 的</p>
<p>如 果 数 据 员 按照 初始 化 列表 的次序 进 行 构造 将 导致 析 构 函数 无法得到唯一的逆序。</p>
<p>拷贝 构造 函数 的 参数 必须 是 同类 对 象 的 引用 ， 而 不 能 是 对 象 值</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"> 拷贝构造 函数</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(A copy)&#123;...&#125; “#Q)陷入 不 地 分 配 堆栈 的 无 限 递归</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; other) &#123;...&#125; (<span class="number">2</span>)</span><br><span class="line">MN...</span><br><span class="line">上</span><br><span class="line">Aa;</span><br><span class="line">Ab=a;</span><br></pre></td></tr></table></figure>

<p>不 主 动 编写 拷贝 构造 函数 和 拷贝 赋值 函数 编 译 器<br>将 “ 按 员 拷贝 ”的 方式 自动 生成 相应 的默认 函数<br>倘 类 中 含有 指针 员 或 引用 成员 ， 那 这 两 个默认 的 函数 可 能 隐 含错误</p>
<p><img src="/../img/C++/Pasted%20image%2020230602112452.png"></p>
<p>拷贝 构造 函数 是在对 象 被 创建 并 用 另 一 个 已 经 存在 的 对 象 来 初始 化 它 时 调用<br>赋值函数只能把一个对象 赋值 给 另 一 个 已 经 存在 的 对 象<br>使 得 经 存在 的 对 象 有 和 源 对 象 相同 的 状态 。</p>
<p><img src="/../img/C++/Pasted%20image%2020230602112740.png"></p>
<p>只 需 将 拷贝 构造 函数 和 拷贝 赋值 函数 声明 private， 并 且 不 实现 它们<br>显 式 声明 的 这两 个函数 会 阻止 编译 器 自动 生成 相应 的 默认 函数</p>
<p>甚至 可 以 把 类 的 有 构造 函数 和 赋值函数 都 声明 为 private，<br>这 样 就 彻底 阻止 了类 的 实例 化 </p>
<p>或 者 把 默认 构造 函数 声明为 private，<br>而 把 其 他 带 参 数 的 构造 函数明 public，<br>这 样 强 用 户 使 用 带 参数 的 构造 函数 来 声明 和 定义 对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">fe.</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">GetType</span><span class="params">()</span></span>; / 未 实现</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; a); / 私有 的 拷贝 构造 函数</span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a); / 私有 的 拷贝 赋值 函数</span><br><span class="line">is</span><br><span class="line">如 果 有 人 试图 编写 如下 程序 :</span><br><span class="line">A ba); UBF T AAA See DFE</span><br><span class="line">b=a; / 调用 了 私有 的 赋值 函数</span><br></pre></td></tr></table></figure>


<p>派生 类 的 构造函数 应 在其 初始 化 列表 里显式 地 调用 基 类 的 构造 函数</p>
<p>如 果 基 类 是 多 态 ， 那 么 必须 把 基 类 的 析 构 函数 定义 为 虚 函 数<br>这 样 可以 其 他虚 函 数 一 实现 动态 绑 定 否则 有可 能 造成 内 存 泄漏<br>delete 基类指针 不会释放派生类</p>
<p>基关 的 构造函数 、 析 构 函 数 赋信函 数都 不 能被 派生 类 继承<br><img src="/../img/C++/Pasted%20image%2020230602114921.png"></p>
<h2 id="9-C-函数-高级特性"><a href="#9-C-函数-高级特性" class="headerlink" title="9. C++函数 高级特性"></a>9. C++函数 高级特性</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>编译 器 根据 参数列表 为 个 重 载 函 数 产生 不 同的 内 部 标识 符 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> _cdeci <span class="title">foo</span><span class="params">(intx, inty)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该 函数 被 C 编译 器 编译 后 在 库 中 的 名 字 为 foo，<br>而 C++ 编译 器 则 会 产生 像 | <code>_foo_int_int</code> 之 类 的 内 部 名 字 用 来 支持 函数 重 载<br>由 于 编译 后 的 名 字 不 同 ，C++ 程 序 | 不能 直接 调用 编译 后 C 函数 。<br>C++ 提 供 了 一 C 连接交换 指示 符 extern “C” 来 解决 这 个 问题</p>
<p>这就 是连接 规范 的 概念</p>
<p>上 述代码 是 在 告诉 C++ 编译 器 函 foo 是 C 连接<br>函数 应 该 为 生成 名 字 <code>_foo</code> 而 不 <code>_foo_int_int</code>，<br>并 指示连接 器 到 C 程序 库 中 去 找该函数 的 定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">( intx )</span></span>; / 函数 声明</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">( <span class="type">float</span> x )</span></span>; / 函数 声明</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">( <span class="type">int</span> x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot; output int &quot;</span>&lt;&lt; x &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">( <span class="type">float</span> x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot; output float &quot;</span> &lt;&lt; x &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="type">float</span> y = <span class="number">1.0</span>;</span><br><span class="line"><span class="built_in">output</span>(x); <span class="comment">// output int1</span></span><br><span class="line"><span class="built_in">output</span>(y); <span class="comment">// output float 1</span></span><br><span class="line"><span class="built_in">output</span>(<span class="number">1</span>); <span class="comment">// output int 1</span></span><br><span class="line"><span class="built_in">output</span>(<span class="number">0.5</span>); / 错误 ! 不 明确 的 调用 ， 因 为 自动 类 型 转换</span><br><span class="line"><span class="built_in">output</span>(<span class="built_in">int</span>(<span class="number">0.5</span>)); <span class="comment">// output int 0</span></span><br><span class="line"><span class="built_in">output</span>(<span class="built_in">float</span>(<span class="number">0.5</span>)); /f output <span class="type">float</span> <span class="number">0.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员函数的重载-覆盖与隐藏"><a href="#成员函数的重载-覆盖与隐藏" class="headerlink" title="成员函数的重载 覆盖与隐藏"></a>成员函数的重载 覆盖与隐藏</h3><p>成 员 函 数被<strong>重载</strong> 的 特征 ：<br>具 有 相同 作用域 〈 即 同一 个 类 定义 );<br>函数名字相同<br>参数 类 型 顺序 或数目 不 同〈 包 const 参数 和 非 const 参数 );<br>virtual 关键字 可有可无</p>
<p><strong>履 盖</strong> 是 指派 生 类 重新 实现 〈 或 者 改写 了 基 类 的 员 函 数 其 特征 :<br>不 同 的作用域 〈 分 别 于派生 类 和 基 类 中 );<br>函数名称相同<br>参 数列 表完 全 相同 ;<br>基 类 函数 必须 是 虚 函 数 <strong>只能覆盖 同名同参 虚函数</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(int) &quot;</span>&lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">float</span> x)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(float) &quot;</span>&lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span>)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Base::g(void)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">b</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span>)</span></span>&#123; cout &lt;&lt; “Derived::<span class="built_in">g</span>(<span class="type">void</span>)<span class="string">&quot; &lt;&lt; endl; &#125;</span></span><br><span class="line"><span class="string">上</span></span><br><span class="line"><span class="string">void main(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">Derived d;</span></span><br><span class="line"><span class="string">Base *pb = &amp;d;</span></span><br><span class="line"><span class="string">| pb—&gt;f(42); // Base::f(int) 42</span></span><br><span class="line"><span class="string">pb 一 &gt;f3.140; ——_‘// Base::f(float) 3.14</span></span><br><span class="line"><span class="string">pb 一 &gt;gO; / Derived::g(void)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>函数 Base::fint) Base::f(float)构成重载<br>Base::g(void) 被 Derived::g(void) 覆盖</p>
<p>虚 函 数 的 覆盖 有 两 种 方式 : 完全 重 和 扩展 。<br>扩展 是 指派 生 类 诬 数 首先 调用 基 类的 虚 函 数 然 后 再 增加 新 的 功能 。</p>
<p>“隐藏 ”是 指派 生 类 的 员 函 数 遮 了 与 其 同名 的 基 类 成 员 函 数：</p>
<ol>
<li>派 生 类 的 函数 基类 的 函数 同名 ， 但 是 <strong>参数 列表 有所 差异</strong><br>不轮 有无 virtual 关键 ， 基 类 的 函数 在 派生 类 中 将 隐藏</li>
<li>派生类的函数与基类的函数同名，<strong>参 数列表也相同</strong> 但 基类函数 没有virtual 关键字。<br>此 时 , 基类的函数在派生类中将隐藏 (注意 别 与 覆盖 混淆 )。</li>
</ol>
<p>解释：<br>对于第一点 同名不同参 同作用域为重载 不同作用域为隐藏<br>对于第二点 同名同参 是虚函数 则覆盖 不是虚函数则隐藏</p>
<p><img src="/../img/C++/Pasted%20image%2020230602133459.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> *str)</span></span>;</span><br><span class="line">上</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived *pd = <span class="keyword">new</span> Derived;</span><br><span class="line">pd—&gt;<span class="built_in">f</span>(<span class="number">10</span>);—_<span class="comment">// error!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; Base::<span class="built_in">f</span>(x); &#125; / 调用传递</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>void Foo(int x &#x3D; 0, int y &#x3D; 0); &#x2F; 正确 默 认值 出现在 函数 的 声明 中<br>如 果 函 有 多 个 参数 参 数 只 能 从 后 向 前 依次 默认 </p>
<p><img src="/../img/C++/Pasted%20image%2020230602134849.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230602135659.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230602135956.png"></p>
<p>C++ 标准 规定 当 为 一 类 型 重 “++”&#x2F;“–” 的 前 置 本 时 不需要 参数<br>当 为 一 个 类 型 重 “++”&#x2F;“–” 的 后 置 本 时 ， 需 要 一 int 类 型 的 参数 作为标志 〈 即 哑 元 非 具名 参数 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Integer</span>(<span class="type">long</span> data) : <span class="built_in">m_data</span>(data)&#123; &#125;</span><br><span class="line">Integer&amp; <span class="keyword">operator</span>++() &#123; /W 前 置 版 : 返回 引用</span><br><span class="line">cout&lt;&lt; “Integer::<span class="keyword">operator</span>++() called!” &lt;&lt; end];</span><br><span class="line">m_datat++ ;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Integer <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="comment">// 后 置 版 : 返回 对 象 的</span></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;Integer::operator++(int) called!&quot;</span> &lt;&lt; end];</span><br><span class="line">Integer temp = *<span class="keyword">this</span> ;</span><br><span class="line">m_data++ ; <span class="comment">// BR: ++(*this) ;</span></span><br><span class="line"><span class="keyword">return</span> temp; / 返回 <span class="keyword">this</span> 对 象 的 旧 值</span><br><span class="line">&#125;</span><br><span class="line">/ 其 他 成 员</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">long</span> m_data; / 对 <span class="type">long</span> 的 封装</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Integer x = <span class="number">1</span>; <span class="comment">// call Integer(long)</span></span><br><span class="line"><span class="number">+4</span>x ; <span class="comment">// call operator++Q)</span></span><br><span class="line">xtt+ <span class="number">3</span> <span class="comment">// call operator++(int)</span></span><br><span class="line">&#125;</span><br><span class="line">输出 结果 :</span><br><span class="line">Integer::<span class="keyword">operator</span>++() called!</span><br><span class="line">Integer::operatort++(<span class="type">int</span>) called!</span><br></pre></td></tr></table></figure>

<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(intx, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo</span><span class="params">(intx, <span class="type">int</span> y)</span> <span class="comment">// inline 与 函数 定义 体 放 在 一</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义 在类 声明 之 中 的 员 函 数 将 自动地 成 内 联 函数</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ... &#125; / 自动 地 成 内 联 函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyString</span>(<span class="type">size_t</span> size, <span class="type">char</span> c =</span><br><span class="line">fhe.</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *m_data;</span><br><span class="line">Point pl = <span class="number">10.5</span>;</span><br><span class="line">pi = <span class="number">20.5</span>;</span><br><span class="line">\<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString strName = <span class="number">20</span>;</span><br><span class="line">strName = <span class="number">40</span>; / 莫名 其妙 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(MyString str)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">100</span>);</span><br><span class="line">如果 当 前程序 中 没有 其 他 重 载 恕 函数， 编译 器 就 将 它暗 中 转换 :</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">MyString</span>(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p>当你的类定义中出现类似的情况时，可以在构造函数前面添加关键字 explicit<br>将其 声明 为 显 式 的 意 为要 求 用 户 必须 显 式 地 调用 该 构造 函数 来 初始 对 象<br>以 明确 表明 他 的 意图 </p>
<p><img src="/../img/C++/Pasted%20image%2020230602141650.png"></p>
<ol>
<li><p><code>static_cast&lt;desttype&gt;(src_obj)</code>， 作 用 相当 于 C 风格 的强制 转换 ,<br>但 是 在 多 重继承 的情况 ， 它 会 正确 地 调整 指针 的 值<br>而 C 风格 的强制 转换 则 不 会调整<br>它 可 以 遍历继承 树 来 确定 src_obj 与 dest_type 的 关系 ,<br>但 是 只 在 编译 时进行 〈 此 所 谓 静 )，<br>如 果使 用 它 来 downcast 操作 ， 则 会 存在 隐患 。</p>
</li>
<li><p><code>const_cast&lt;dest_type&gt;(src_obj)</code>， 用 于去除 一 个对 象 const&#x2F;volatile 属性 </p>
</li>
<li><p><code>reinterpret_cast&lt;desttype&gt;(src_obj)</code>, 我 们 可 以借助 它 把 一 个 整数 转换 成 一地 址 或 者 在任何 两 种 类 型 的 指针 之闻 转 。 使 用 该 运算 符 的 结果 很 危险 ，请你 要 轻易使 </p>
</li>
<li><p><code>dynamic_cast&lt;dest_type&gt;(src_obj)</code>， 在 运行 时 台历 继承 〈 类 层次 结构 ) 来确定 src_obj 与 desttype 的 关系</p>
</li>
</ol>
<p>在 C++ 程序 中 尽量 不 要 再 使 C 风格 的 类 型 转换<br>除 非 源 对 和 目标 类型 都 <strong>基本 类 型</strong> 的对 象 指针 ， 否 则 很 不 安全 。<br>C++ 的 类 型 转换 运算 符在 需要 的 时 候 会 进行<strong>指针 调整</strong> 因 此 结果 比较 安全 。</p>
<h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>任何 不 会修改 数据 员 的 员 函 数 都应 该 声明 为 const 类</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> elem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pop</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetCount</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>; <span class="comment">// const A AB</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line"><span class="type">int</span> m_data[ <span class="number">100</span>&#125;;</span><br><span class="line"><span class="function">I</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::GetCount</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">t</span></span><br><span class="line"><span class="function">++m_num</span>; / 编译 错误 企 图修改 数据 成 <span class="function">m_num</span></span><br><span class="line"><span class="function"><span class="title">Pop</span><span class="params">()</span></span>; / 编译 错误 企 图 调用非 <span class="type">const</span> 成 员 函</span><br><span class="line"><span class="keyword">return</span> m_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Static KA BRA RANA const 的 这 是 因为 static 成 员 函 数 只 是 全 局 函 数 的 一 个 形式 上 的 封装 而 全 局 函数 不 存在 const 一 ; 何况 static 成 员 函数 不 能 访问 类 的 非 静态 成 (没有 this 指针 )， 修 改 非 静态 数据 员 又 从 何说 起 ? </p>
<h2 id="10-C-异常处理-和-RTTI"><a href="#10-C-异常处理-和-RTTI" class="headerlink" title="10. C++异常处理 和 RTTI"></a>10. C++异常处理 和 RTTI</h2><p>何 一 种 类 型 可 以 当做 异常 类 型 因 此 任何 个 对 象 可 以 当做异常 对 ，<br>包括 基本 数据 类 型 的 变量 常量、 任何 类 型 的 指针 、 引 用 、 结 构 等 甚 至 空 结构类 的 对象<br>这 是 因为 异常 仅仅通过 类 型 而不是 通过 值 来 匹配 的 否 则 就 又 退回 到<br>了 传统 的 错误 处 理 技术 上 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> x = <span class="number">100</span>, y = <span class="number">20.5</span>;</span><br><span class="line"><span class="type">int</span> x[<span class="number">20</span>] = &#123; <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Devide</span>(x, y) &lt;&lt; endl; / 可 能 抛 出 异常 <span class="function">DevidedByZero</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(index &gt;= <span class="number">20</span>)</span> <span class="keyword">throw</span> <span class="title">OverFlow</span><span class="params">()</span></span>; <span class="number">1</span>) iE EGLF <span class="number">4</span> <span class="function">Bil <span class="keyword">try</span> RA</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(index &lt; <span class="number">0</span>)</span> <span class="keyword">throw</span> <span class="title">UnderFlow</span><span class="params">()</span></span>; / 抛 出 点 位 于 当前 <span class="keyword">try</span> 块 内</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">const</span> DevidedByZero&amp; ex) &#123;</span><br><span class="line">cerr &lt;&lt; ex.<span class="built_in">description</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">const</span> OverFlow&amp;) &#123; / 省 略 参数 名 称</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot;Overflow occurred!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">const</span> UnderFlow&amp;) &#123;</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot;Underflow occurred!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...) &#123; / 捕获 他所 有 可 能 的 异常</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot;Unexpected exception occurred!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由 于 异常 处理 机 制 采用 类 型 匹配 而 不 是 值 判 断 因 此 catch 块 参数<br>可 以 没有 参数 名 称 只 需要 参数 类 型 除 非 确实 要 使 用 那个 异常 对 </p>
<p>虽然 异常 对 象 上 去 局 部 对 象 但 是 并 非 创建 在 函数 堆栈 上 ，<br>而 是创建 在 专用 的 <strong>异常 堆栈</strong> 上 ， 因 此 它 才 可 以 跨接 多 个 函数 而 传递 上 层 ，<br>否则 在 堆栈 清 退 的 过 程 中 就 会 销毁 .<br><strong>不 要</strong> 企图 把 <strong>局 部 对 象 地 址</strong> 作为异常 对 象 <strong>抛 出</strong><br>因 为 局 部 对 象 会 蜡 常 出 后 函数 堆栈 清 退 的 过 程 中销毁 </p>
<p><img src="/../img/C++/Pasted%20image%2020230602161511.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Devide</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> <span class="title">throw</span><span class="params">(DevidedByZero)</span></span>;  <span class="comment">// 只 可 能 出 一种 异常</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span> <span class="title">throw</span><span class="params">(T1, T2,T3)</span></span>; <span class="comment">// 可 能 抛 3 种 异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// (3) 不抛出任何异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">k</span><span class="params">()</span></span>;  <span class="comment">// 可 能 出 任何 异常 也 可能 不 出 任何异常</span></span><br></pre></td></tr></table></figure>

<p>所 有从try 到 throw 语句 之间 构造 起 来 的 局 部对 象 的析 构 函数将被 自动 调用<br>(以 与构造相 反 的 顺序 )， 然 后 清 退 堆栈 (就像 函 数 正 退出 那样 )。</p>
<p>如 果 一 个 函数 在 运行 时 抛 了 异常<br>于 是 异常 处 理 机制 调用 局 部 对 象 析构 函数 〈 清退 扒 )，<br>而如 果 此 时 某 一 析 构 函 数 恰 也 要 抛 出一 个 异常 那 这个 异常 由 谁 处 理 ?<br>没有 办 法 异 常 处 理 机 制 只 好 调用;terminate0。</p>
<p>如 果 你 真 的 不 得 不 从 析 构 函数 内 抛 出 异常 的 话 你应 该<br>首先 检查一 下 看 当前 是 有 一 个 未 捕获 的 异常 要 被 处 理 如 果 没有 ，<br>说 明 该 析 构 函数 的用 并 非 由 一 外 部 异常 引起 而 是 正常 的 销毁<br>于是 你 可 以 出 一 个 异常 上 层:程序 来 捕获</p>
<p>一 些 编译 器可 以 设 异 常 处 理 支持 开关 ， 当 关闭 异常 理 支持 后 附加 的 数据 结构 查 找表 、 额 外 的 代码 都 不 生成</p>
<p>要 合理 安排 异常 处 理 的 层次 : 一 要 把 派生 类 的 异常 .<br>获 放 在 基 类 异常 捕获 的 前 面 否 则派生 类 异常 匹配 永远 也 不 会执行到 </p>
<p>如 果实 在 无 法判断 到 底 有什么 异常 抛 出 那 就 使 “一 打 尽”的 策<br>略 了 : catch(void*) 和 catch(…)。 但 要 记 住 catch(void*) 和 catch(..)<br>必须 放 在 异常 组 合 的 最 后 面 并 且 cateh(void*) 放 在 catch(…) 的 前 </p>
<p><img src="/../img/C++/Pasted%20image%2020230602165212.png"></p>
<p>为 了 支持 dynamic_cast&lt;&gt; 运 算 符 ，RTTI 机 制 必须 维 护 一 棵 继承 ，<br>即 base class table 模型 ( 或 类 似 的 索引 表格 )</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeviceControllor::ControlThem</span><span class="params">(HomeElectricDevice&amp; device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Command cmd = <span class="built_in">GetCommand</span>();</span><br><span class="line"><span class="keyword">switch</span>(cmd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> OPEN:</span><br><span class="line"><span class="keyword">case</span> PLAY VCD:</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Television tv = <span class="built_in">dynamic_cast</span>&lt;Television &amp;&gt;(device);</span><br><span class="line">tv.PlayVCDQ; <span class="comment">// PRCERESE ADEE Television WRAEAIE BCH!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(std::bad_cast&amp;) &#123;</span><br><span class="line"><span class="built_in">MsgBox</span>(<span class="string">&quot;This device cannot play VCD!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h2 id="11-16章-内存管理"><a href="#11-16章-内存管理" class="headerlink" title="11. 16章 内存管理"></a>11. 16章 内存管理</h2><p> 野 指 针<br> free 完 delete完 置NULL</p>
<p>对 于 内 部 数据 类 (如 ADT&#x2F;UDT) 的 对 象 而 言 光 用 mallocO&#x2F;free0 无 法 满足 动态 对 象 的 要 求<br>对象 在 创建 的 同时 要 <strong>自动 调用 构造 函数</strong> 对象在 销毁 的 时 候要 <strong>自动 调用 析 构 函数</strong><br>由 mallocO&#x2F;free0 是 库 函 数而 不 是 运算 符 不 在 编译 器 控制 权限<br>不 能 把调用 构造函数 和 析 构 函数 的任务强加 给 它们 。<br>因 此 C++ 语言 需要 一能 完成 动态 内 存 分 和 初始 化 工作 的运算 new,<br>以 及一 个 能 够 完成清 理与 释放 内存工作 的运算符 delete。</p>
<p>plain new、nothrow new 及 placement new.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> 的 使 用 方 法 见 示 例 <span class="number">16</span><span class="number">-10</span>。</span><br><span class="line"><span class="comment">// plain new 定义</span></span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="built_in">new</span>(std::<span class="type">size_t</span>) <span class="built_in">throw</span>(std::bad_alloc);</span><br><span class="line">| <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Char * <span class="title">GetMemory</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span></span><br><span class="line"><span class="function">《</span></span><br><span class="line"><span class="function"><span class="type">char</span> *p </span>= <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">GetMemory</span>(<span class="number">1000000</span>); / 可 能 抛 出 std::bad_alloc 异 常</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">const</span> std::bad_alloc&amp; ex) &#123;</span><br><span class="line">cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// nothrow new 定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">unsigned</span> <span class="type">char</span>[length];</span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>) cout &lt;&lt; <span class="string">&quot;allocate failed!&quot;</span>&lt;&lt; endl;</span><br><span class="line">Hf...</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>placement new 不 用 担心 内 存 分配 失败 因 为 它 根本 就 不 会 分配 内 存<br>它所 做 的 唯一 一件 事情 就 是 调用 对 象 的 构造 函数 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">include &lt;<span class="keyword">new</span>&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="built_in">main</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="number">4</span>]; <span class="comment">// nothrow new</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;allocate failed!&quot;</span>&lt;&lt; endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">仁 …</span><br><span class="line"><span class="type">long</span> *q = <span class="built_in">new</span>(p) <span class="built_in">long</span>(<span class="number">1000</span>); <span class="comment">// placement new</span></span><br><span class="line">Ie.</span><br><span class="line"><span class="keyword">delete</span> [ip; / 释放 内 存</span><br></pre></td></tr></table></figure>

<p>Placementnew 的 主 要 用 途 就 是 : 反 复 使 用 一 块 较 大 的 动 态 分 配 成 功 的 内 存 来 构 造 不 同 类 型 的 对 象 或 者 它 们 的 数 组 。 比 如 , 可 以 先 申 请 一 个 尸 够 大 的 字 符 数 组 , 然 后 当 需 要 时 在 它 上 面 构 造 不 同 类 型 对 象 或 其 数组</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> “ 使 用 placement <span class="keyword">new</span> 构 造 起 来 的 对 象 或 其 数 组 , 要 显 式 地 调 用 它 们 的 析 构 函 数 来 销 毁 ( 析 构 函 数 并 不 释 放 对 象 的 内 存 , 千 万 不 要 使 用 <span class="keyword">delete</span>。 这 是 因 为 ,placement <span class="keyword">new</span> 构 造 起 来 的 对 象 或 其 数 组 的 大 小 并 不 一 定 等 于 原 来 分 配 的 内 存 大 小 , 因 此 使 用 <span class="keyword">delete</span> 会 造 成 内 存 泄 漪 , 或 者 在 之 后 释 放 内 存 时 出 现 运 行 时 错 误 。 见 示 例 <span class="number">16</span><span class="number">-14</span> ( 假 设 ADT 表 示 任 意 复 合 数 据 类 # ).</span><br><span class="line">示 例 <span class="number">16</span><span class="number">-14</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostrem&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="built_in">main</span>(<span class="type">void</span>)</span><br><span class="line">《</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std:</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="built_in">sizeof</span>(ADT) + <span class="number">2</span>]:; / nothrow <span class="keyword">new</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;allocate failed!&quot;</span>&lt;&lt; endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ADT *q = <span class="built_in">new</span>(p) ADT; <span class="comment">// placement new: 不 必 担 心 失 败</span></span><br><span class="line">历 .</span><br><span class="line"><span class="comment">// deleteq; / 错 误 ! 不 能 在 此 处 调 用 deleteq;</span></span><br><span class="line">q-&gt;ADT::-ADTO; / 显 示 调 用 析 构 函 数</span><br><span class="line"><span class="keyword">delete</span> []p; / 再 释 放 内 存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span> *) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="12-用对象模拟指针"><a href="#12-用对象模拟指针" class="headerlink" title="12. 用对象模拟指针"></a>12. 用对象模拟指针</h2><p> 些 软 件 库 使 用 这 种 技 术 来 封 装 指 针 , 基 本 上 分 为 如 下 几 种 情 况 。</p>
<ol>
<li>采 用 拷 贝 方 式 。 这 样 的 指 针 对 象 既 负 责 创 建 数 据 对 象 , 又 负 责 删 除 数 据 对<br>象 ,STL 容 器 对 象 采 用 的 就 是 这 种 方 式 。显 然 , 采 用 这 种 方 式 的 指 针 对 象<br>责任 最 清 晰 。</li>
<li>采 用 完 全 接 管 方 式 , 指 针 对 象 不 负 责 创 建 数 据 对 象 , 但是负责删除数据对<br>象 , 即 不 仅 接 管 了 源 指 针 指 向 的 对 象 , 而 且 接 管 了 它 的 所 有 权 。auto ptr&lt;&gt;<br>类 就 是 采 用 这 种 方 式 实 现 的 。</li>
<li>采 用 接 管 方 式 , 是 既 不 负 责 创 建 数 据 对 象 也 不 负 责 删 除 数 据 对 象 , 这 就 是<br>我 们 的 模 拟 指 针 。STL 中 的 迭 代 器 (iterator》 采 用 的 就 是 这 种 方 式 , 它们 在<br>行 为 上 与 底 层 的 指 针 变 量 没 有 什 么 太 大 区 别 , 只 是 在 使 用 方 式 上 统 一 了 起<br>来 。</li>
<li>完 全 接 管 方 式 和 深 拷 贝 方 式 结 合 。 一 般 情 况 是 : 拷 贝 构 造 和 拷 贝 赋 值 采 用<br>深拷 贝 方 式 , 而 指 针 构 造 和 指 针 赋 值 采 用 接 管 方 式 。 这 种 方 式 最 容 易 产 生<br>运 行 时 内 存 访 问 冲 突 和 内 存 泄 漏 问 题 , 因 此 建 议 不 要 使 用 。</li>
</ol>
<h3 id="泛型指针auto-ptr"><a href="#泛型指针auto-ptr" class="headerlink" title="泛型指针auto_ptr"></a>泛型指针auto_ptr</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> 【</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">autp_ptr</span><span class="params">(T *p = <span class="number">0</span>)</span> : m_ptr(p)&#123;</span>&#125;</span><br><span class="line"><span class="built_in">auto_ptr</span>(<span class="type">const</span> auto_ptr&lt;T&gt;&amp; copy) : <span class="built_in">m_ptr</span>(copy.<span class="built_in">release</span>())&#123;&#125;</span><br><span class="line">auto_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> auto_ptr&lt;T&gt;&amp; assign) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;assign) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">m_ptr = assign.<span class="built_in">release</span>(); H 释 放 并 移 交 拥 有 权</span><br><span class="line">多</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">hs</span><br><span class="line">~<span class="built_in">auto_ptr</span>()&#123; <span class="keyword">delete</span> m_ptr; &#125; / 负 责 释 放 存 储</span><br><span class="line">T&amp; <span class="keyword">operator</span>*()&#123; <span class="keyword">return</span>.*m_p; &#125; / 重 载 “*<span class="number">2</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()&#123; <span class="keyword">return</span> m_p; &#125; / 重 载 “-&gt;“</span><br><span class="line"><span class="function">T* <span class="title">release</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">T *temp = m_ptr;</span><br><span class="line">(<span class="keyword">const_cast</span>&lt;auto_ptr&lt;T&gt; *&gt;(<span class="keyword">this</span>))-&gt;m_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">工 * m_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使 用 auto_ptr&lt;&gt; 这 样 的 灵 巧 指 针 有 一 个 好 处 : 当 函 数 即 将 退 出 或 有 异 常 抛 出 的 时 候 ,<br>不 再 需 要 我 们 显 式 地 用 delete 来 删 除 每 一 个 动 态 创 建 起 来 的 对 象</p>
<h3 id="带引用技术的智能指针"><a href="#带引用技术的智能指针" class="headerlink" title="带引用技术的智能指针"></a>带引用技术的智能指针</h3><p>带 有 引 用 计 数 功 能 的 智 能 指 针 兼 有, 智 通 指 针 共 享 实 值 对 象 和 auto ptr 自 动 释 放 实 值 对 象 的 双 重 功 能</p>
<p><img src="/../img/C++/Pasted%20image%2020230603113212.png"></p>
<p>“auto_ptr不 满 足 STL 标 准 容 器 对 元 素 的 最 基 本 要 求<br>,auto ptr 对 象 和 它 的 拷 贝 不 会 共 享 实 值 | 对 象 , 任 何 两 个 auto_ptr 也 不 应 该 共 享 同 一 个 实 值 对 象 。 这 就 是 说 ,auto ptr 对 象 和 | 它 的 拷 贝 并 不 相 同 。 然 而 根 据 STL 容 器 “ 值 “ 语 义 的 要 求 , 可 拷 贝 构 造 意 味 着 一 个 || 对 象 必 须 和 它 的 拷 贝 相 同 ( 标 准 中 的 正 式 定 义 比 这 稍 复 杂 一 些 。 同 样 , 可 赋 值 意 味 耒萱把 个 对 象 赋 值 给 另 一 个 同 类 型 对 象 将 产 生 两 个 相 同 的 对 象 。 显 然 ,auto ptr 不 能 LK 要 求 , 它 与 上 面 的 结 论 矛 盾</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例<span class="number">16</span><span class="number">-23</span></span><br><span class="line">std::list&lt; std::auto_ptr&lt;<span class="type">int</span>&gt; &gt; la; / auto_ptr 列 表</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">la.<span class="built_in">push_back</span>(p1); <span class="comment">// compiling-error!</span></span><br><span class="line">la.<span class="built_in">push_back</span>(p2); <span class="comment">// compiling-error!</span></span><br><span class="line">la.<span class="built_in">push_back</span>(p3); <span class="comment">// compiling-error!</span></span><br><span class="line">set&lt;auto_ptr&lt;<span class="type">int</span>&gt; &gt; sa; / auto_ptr RA: 假 设 为 <span class="keyword">auto</span> ptr 定 义 了 <span class="keyword">operator</span>&lt;</span><br><span class="line">sa.<span class="built_in">insert</span>(p1); <span class="comment">// compiling-error!</span></span><br><span class="line">sa.<span class="built_in">insert</span>(p2); <span class="comment">// compiling-error!</span></span><br><span class="line">sa.<span class="built_in">insert</span>(p3); <span class="comment">// compiling-error!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">T *p = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T)); / 分 配 内 存空 间</span><br><span class="line"><span class="keyword">new</span> (p) <span class="built_in">T</span>(x); <span class="comment">// placement new, 调 用 T 的 copy constructor</span></span><br><span class="line">------ / 将 p 交 给 容 器 管 理 , 调 整 容 器 大 小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::auto_ptr&lt;<span class="type">int</span>&gt; &gt; IntPtrVector;</span><br><span class="line">IntPtrVector va;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">4</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">va.<span class="built_in">push_back</span>(p1);</span><br><span class="line">va.<span class="built_in">push_back</span>(p2);</span><br><span class="line">va.<span class="built_in">push_back</span>(p3);</span><br><span class="line">va.<span class="built_in">push_back</span>(p4);</span><br><span class="line">va.<span class="built_in">push_back</span>(p5);</span><br><span class="line"><span class="number">1</span> ( 注意 : 以 下 操 作 并 非 放 在 一 起 进 行 , 仅 是 示 范 )</span><br><span class="line">IntPtrVector vb = va; va 丧 失 对 所 有 实 值 对 象 的 拥 有 权 ,</span><br><span class="line">/ 元 素 成 为 <span class="literal">NULL</span> 指 针</span><br><span class="line">vb.<span class="built_in">resize</span>(<span class="number">10</span>); / 新 增 的 元 素 都 为 <span class="literal">NULL</span>指 针</span><br><span class="line">std::<span class="built_in">sort</span>(vb.<span class="built_in">begin</span>(),</span><br><span class="line">vb.end0);</span><br><span class="line"></span><br><span class="line">std::auto_ptr&lt;<span class="type">int</span>&gt;</span><br><span class="line">t</span><br><span class="line">=</span><br><span class="line">vb.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">改</span><br><span class="line">变</span><br><span class="line">了</span><br><span class="line">容</span><br><span class="line">器</span><br><span class="line">元</span><br><span class="line">素</span><br><span class="line">std::auto_ptr&lt;<span class="type">int</span>&gt; r = vb[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">std::list&lt;std::auto_ptr&lt;<span class="type">int</span>&gt; &gt; la;</span><br><span class="line">std::<span class="built_in">copy</span>(vb.<span class="built_in">begin</span>(), vb.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(la));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>Scott Meyers 在 《Effective STL) Item 8 中 详 细 地 分 析 了 对 auto ptr 容 器 进 行 排 序<br>| 时 可 能 会 导 致 的 问 题 。 但 是 在 MS VC++ 环 境 下 经 测 试 , 并 没 有 出 现 书 中 所 描 述 的 悲<br>| 惨 结 局 , 而 是 结 果 正 确 。 主 要 原 因 在 于 C++ 标 准 并 没 有 要 求 std::sort等 泛 型 算 法 的 实<br>现 必 须 采 用 某 一 种 方 法 , 而 是 只 规 定 了 它 们 的 接 口 、 功 能 和 应 该 达 到 的 性 能 要 求 ( 容<br>器也 是 如 此 )。 因 此 , 不 同 的 STL 实 现 可 能 采 取 不 同 的 方 法 , 比 如 有 的 sort 实 现 采 用<br>快速 排 序 法 , 而 有 的 采 用 插 入 式 排 序 法 等 。 不 同 的 排 序 方 法 在 遮遇 auto_ptr这 样 的 容<br>| 器 时 可 能 就 会 产 生 不 同 的 结 果 </p>
<p>可 见 , 督 能 指 针 “ 可 以 “ 还 是 “ 不 可 以 “ 作 为 容 器 的 元 素 并 非 绝 对 的 , 不 仅 与 ,STL 的 实 现 有 关 , 而 且 与 STL 宪 器 的 需 求 和 安 全 性 及 容 器 的 语 义 有 关</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">由于 auto_ptr 是 对 象 化 的 智 能 指 针 , 具 有 自 动 释 放 资 源 的 能 力 , 因 此 它 真 正 有 价</span><br><span class="line">, 值 的 用 途 是 在 发 生 异 常 时 避 免 资 源 泄 濡 。 比 如 , 如 果 不 使 用 <span class="keyword">auto</span> ptr, 则 下 列 代 码 在</span><br><span class="line">发 生 异 常 的 情 况 下 不 得 不 多 次 手 工 释 放 资 源 ( 见 示 例 <span class="number">16</span><span class="number">-28</span>)。</span><br><span class="line">示 例 <span class="number">16</span><span class="number">-28</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; ... &#125;<span class="number">5</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">《</span></span><br><span class="line"><span class="function">A *pA</span>= 一 <span class="keyword">new</span> A;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">wee <span class="comment">// using *pA</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...) &#123;</span><br><span class="line"><span class="keyword">delete</span> pA; MBERTAIN BE LAE IK</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> pA; / 函 数 退 出 时 还 要 显 式 释 放</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现 在 有 了 <span class="keyword">auto</span> ptr, 我 们 就 可 以 这 么 做 ( 见 示 例 <span class="number">16</span><span class="number">-29</span>).</span><br><span class="line">示 例 <span class="number">16</span><span class="number">-29</span> |</span><br><span class="line">classA&#123; ... &#125;<span class="number">5</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">auto_ptr&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line"><span class="comment">// using *pA</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果 想 防 止 无 意 中 修 改 <span class="keyword">auto</span> ptr 对 实 值 对 象 的 拥 有 权 , 可以 使 用 <span class="type">const</span> auto_ptr,</span><br><span class="line">! 这 样 的 auto_ptr 只 能 使 用 引 用 或 指 针 传 递 , 不 能 使 用 值 传 递 , 也 不 能 赋 值 和 拷 贝 构 造 </span><br><span class="line"></span><br><span class="line">classA&#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> auto_ptr&lt;A&gt; <span class="title">pl</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">we <span class="comment">// using *pA</span></span><br><span class="line"><span class="function">auto_ptr&lt;A&gt; <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// error!</span></span><br><span class="line">auto_ptr&lt;A&gt; p3;</span><br><span class="line">p3=pl; <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// smart pointer stl</span></span><br><span class="line"></span><br><span class="line">示 例 <span class="number">16</span><span class="number">-31</span></span><br><span class="line">) <span class="keyword">typedef</span> SmartPtr&lt;Shape&gt; ShapeSmartPtr;</span><br><span class="line"><span class="keyword">typedef</span> std::list&lt;ShapeSmartPt&gt; ShapeList;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point&amp; left, <span class="type">const</span> Point&amp; right)</span><br><span class="line">&#123; <span class="keyword">return</span> ((left.m_x &lt; right.m_x) &amp;&amp; (left.m_y &lt;right.m_y); &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>—=(<span class="type">const</span> Point&amp; left, <span class="type">const</span> Point&amp; right)</span><br><span class="line">&#123; <span class="built_in">return</span> ((left.m_x == right.m_x) &amp;&amp; (left.m_y == right.m_y); )</span><br><span class="line">| <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> ShapeSmartPtr left, <span class="type">const</span> ShapeSmartPtr right)</span><br><span class="line">&#123; <span class="built_in">return</span> (left-&gt;GetOriginQ &lt; right-&gt;<span class="built_in">GetOrigin</span>()); 》</span><br><span class="line"><span class="number">1</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ShapeSmartPtr left, <span class="type">const</span> ShapeSmartPtr right)</span><br><span class="line">&#123; <span class="built_in">return</span> (left-&gt;GetOriginQ == right-&gt;<span class="built_in">GetOrigin</span>()); &#125;</span><br><span class="line">ShapeList shapes;</span><br><span class="line">ShapeSmartPtr <span class="built_in">p</span>(<span class="keyword">new</span> <span class="built_in">Shape</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line">ShapeSmartPtr <span class="built_in">q</span>(<span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="number">5</span>));</span><br><span class="line">ShapeSmartPtr <span class="built_in">r</span>(<span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="built_in">Point</span>(<span class="number">4</span>, <span class="number">4</span>)));</span><br><span class="line">shapes.<span class="built_in">push_back</span>(p);</span><br><span class="line">shapes.<span class="built_in">push_back</span>(q);</span><br><span class="line">shapes.<span class="built_in">push_back</span>(r);</span><br><span class="line">|</span><br><span class="line">std::<span class="built_in">sort</span>(shapes.<span class="built_in">begin</span>(), shapes.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ShapeList::const_iterator first=shapes.<span class="built_in">begin</span>();first !=shapes.<span class="built_in">end</span>();++first)</span><br><span class="line">(*first)-&gt;DrawQ);</span><br></pre></td></tr></table></figure>


<h2 id="13-17章-STL"><a href="#13-17章-STL" class="headerlink" title="13. 17章 STL"></a>13. 17章 STL</h2><p>STL 主 要 包 括 下 面 这 些 组 件<br>IO流、 string 类 、 容 器 类(Container)、 迭 代 器 熹 (Iterator)、 存 储 分 配 器 (Allocator)、<br>适 配 器 (Adapter)、 函 数 对 象 (Functor)、 泛 | 型 算 法 (Algorithm)、<br>数 值 运 算 、 国 际 化 和 本 地 化 支 持 , 以 及 标 准 异 常 类 等 。</p>
<p>C++标 准 规 定 , STL 的 头 文 件 都 不 使 用 扩 展名<br>过 去 的 C 程 序 库 头 文 件 在, 并 入 C++ 标 准 库 时 也 都 去 掉 了 .h 扩 展 名 , 同 时 增 加 了 前 缀 “c“。<br>STL 组 件 都 被 纳 入 了 名 字 空 间 std::, 所 以 在 使 用 其 中 的 组 件 之 前 需 使 用 using 声 明 或 using 指 令 ,<br>或 者 也 可 以 在 每 一 处 都 直 接 使 用 完 全 限 定 名 std::。 </p>
<p><img src="/../img/C++/Pasted%20image%2020230603051215.png"></p>
<h3 id="STL头文件分布"><a href="#STL头文件分布" class="headerlink" title="STL头文件分布"></a>STL头文件分布</h3><h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p><img src="/../img/C++/Pasted%20image%2020230603050007.png"></p>
<pre><code>关 联 式 容 器 multimap 和 multiset 也 都 分 别 定 义 在 &lt;map&gt; 和 &lt;set&gt; 中 ,
hash_multimap 和 hash_multiset 定 义 在 &lt;hash_map&gt;和&lt;hash_set&gt;中
</code></pre>
<h3 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h3><pre><code>像 C++VC 数 组 、 字 符 留 、UO 流 等 特 殊 的 容 器 也 可 以 使 用 标 些 泛 型 算 法 一 一
它 们 定 义 在 头 文 件 &lt;algorithm&gt;和 &lt;utility&gt; 中 
</code></pre>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><pre><code>如 输 入 / 输 出 迭 代 器 、 插 入 迭 代 器 、 反 向 迭 代 器 等 都 是 迢 代 器 适 配 器 , 
定 义 在 头 文 件 &lt;iterator&gt;中 
</code></pre>
<h3 id="数学运算库"><a href="#数学运算库" class="headerlink" title="数学运算库"></a>数学运算库</h3><p><img src="/../img/C++/Pasted%20image%2020230603050515.png"></p>
<h3 id="通用工具"><a href="#通用工具" class="headerlink" title="通用工具"></a>通用工具</h3><p><img src="/../img/C++/Pasted%20image%2020230603050604.png"></p>
<h3 id="其他头文件"><a href="#其他头文件" class="headerlink" title="其他头文件"></a>其他头文件</h3><pre><code>&lt;typeinfo&gt; 、&lt;stdexcept&gt;、&lt;strsteam&gt;、&lt;string&gt;、&lt;istream&gt;、
&lt;ostream&gt;、&lt;iostream&gt;、&lt;new&gt;、&lt;iomanip&gt;、&lt;fstream&gt; 
</code></pre>
<h3 id="容器设计原理"><a href="#容器设计原理" class="headerlink" title="容器设计原理"></a>容器设计原理</h3><p>容 器 在 概 念 上 是 一 种 可 以 动 态 增 大 和 减 小 的 模 型<br>其<strong>元 素 对 象</strong> 在 实 现 上 不 可 能 直 接 保 存 在 容 器 对 象 里 面<br>应 该 保 存 在 自 由 内 存 (Free Memory) 或 堆 , CHeap)》 上</p>
<h3 id="内存映像"><a href="#内存映像" class="headerlink" title="内存映像"></a>内存映像</h3><p><img src="/../img/C++/Pasted%20image%2020230603051108.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230603052000.png"></p>
<h3 id="存储方式-访问方式"><a href="#存储方式-访问方式" class="headerlink" title="存储方式 访问方式"></a>存储方式 访问方式</h3><p>向 量 Cvector) 和 链 表 (linked list) 是 两 种 最 基 本 的 动 态 结 构 ,<br>也是 STL 中 两 种 最 基 本 的 容 器 ,<br>分 别 对 应 动 态 数 组 和 链 接 表 结 构<br>同 时 它 们 分 别 代 表 了 内 存 中 同 类型 批 量 数 据 存 放 的 两 种 基 本 方 式 , 连 续 存 储 和 随 机 存 储 ( 不 连 续 存 储 )。 </p>
<p>随 机 访 问 就 是 指 可 以 直 接 通 过 开 销 恒 定 的 算 术 运 算 来 得 到 任 一 元 素 的 内 存 地 址 的 访 问 方 法</p>
<p>顺 序 访 问 则 是 指 必 须 从 第 一 个 元 素 开 始 遍 历 , 直 到 找 到 所 需 的 元 素 对 象 为止 ,<br>而 无 法 直 接 得 到 任 一 中 间 元 素 对 象 的 地址</p>
<p><img src="/../img/C++/Pasted%20image%2020230603052600.png"></p>
<p>stack、queue 及 priorityqueue 在 概 念 和 接 口 上 都 不 支 持 随 机 访 问和 遍历 ,<br>这 是 由 它 们 的 语 义 决 定 的 , 而 不 是 由 底 层 存 储 方 式 决 定 的 , 因此 没 有 选 代 器<br>( 所 以 它 们 才 被 叫 做 容 器 近 配 器 而 不 是 归 为 容 器 类 ), </p>
<p>这 两 种 基 本 的 存 储 方 式 可 以 演 变 出 各 种 不 同 的 存 储 方 式 ,<br>比 如 分 层 连 续 存 储 、 树 (Tree)、 邻 接 表 、 图 等 , 甚 至 可 以 把 二 者 组 合 起 来 </p>
<p>就 拿 “ 树 “ 来 说 , 它 在 本 质 上 就 是 一 种 特 殊 的 链 表 结 构 , 因 此 只 能 顺 序 访 问 ,<br>即 从 某 个 节 点 开 始 搜 索 直 至 到 达 所 要 访 问 的 元 素 对 象 ,<br>或 者 采 用 深 度 优 先 、 广 度 优 先 或 者 前 序 、 中 序 、 后 序 等 方 法 遍 历 整 棵 树 ,<br>但 是 不 可 能 直 接 定 位 到 树 上 的 任 一 个 结 点 对 象 。</p>
<p>主 要 有 一 叉 搜 索 树 (binary-search)、 平 衡 二 叉 树 (balanced binary search). 红 黑 树 (red-black) 等 </p>
<p>由于 红 黑 树 ( 平 衡 二 又 搜 索 树 的 一 种 ) 在 元素 定 位 上 的 优 异 性 能 (CO(logyW),STL 通 常 使 用 它 来 实 现 关 联 式 容 器 </p>
<p>顺序 容 器 主 要 采 用 向 量 和 链 表 及 其 组 合 作 为 基 本 存 储 结 构 , 如 堆 栈 和 各 种 队 列<br>而 关 联 式 容 器 采 用 平 衡 二 叉 搜 索 树 作 为 底 层 存 储 绪 构</p>
<p>由 于 顺 序 容 器 本 来 就 有 “ 序 “, 所 以 它 是 通 过 元 素 对 象 在 容 噬 中 的位 置 来标 识 一 个 元 素 的 ,<br>而 不 是 通 过 元 素 的 值 ( 因 为 它 可 以 存 储 值 相 等 的 多 元 素 对 象 , 而 且 它 们 的 位 置 不 一 定 相 邻 ),<br>这 也 就 是 调 用 顺 序 容 器 的 insert0 函 数 和 erase0 函 数 时 必 须 指 定 插 入 位 置 和 删 除 位 置<br>而 不 能 仅 指 定 元 素 值 的 原 因 .<br>当 然 , 关 联 式 容 噩 也 能 存 储 值 相 等 的 元 素 , 比 如 multimap 和 multiset 等 ,<br>但 是 它 们 在 容 器 中 的 位 置 肯 定 是 相 邻 的</p>
<p><img src="/../img/C++/Pasted%20image%2020230603055357.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Container:iiterator first = theContainerObj.<span class="built_in">begin</span>(),</span><br><span class="line">fast = theContainerObj.<span class="built_in">end</span>(Q);</span><br><span class="line">first != last;</span><br><span class="line">++first) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; first-&gt;.,. &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (*first)... &lt;&lt; endl;</span><br><span class="line">/</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Inputlterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Inputlterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">Inputlterator <span class="title">find</span><span class="params">(Inputlterator first, Inputfterator last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(first != last &amp;&amp; *first != value) ++first;</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>hash table 及 由 它 演 化 出 来 的 hash_set&#x2F; hash_map&#x2F;hash_ multiset&#x2F;hash_multimap<br>作 为 关 联 式 容 磐 加 进来</p>
<p>STL 容 器 采 用 拷 贝 方 式 来 接 收 待 插 入 的 元 素 对 象 一 一 在 插入 的 时 候 容 器<br>自 动 新 建 等 量 的 元 素 对 象 , 并 用 待 插 入 对 象 依 次 初 始 化 它 们 ( 调 用 拷 贝 构 造 函 数 </p>
<p>在 删 除 元 素 时 , 容 器 负 责 释 放 其 内 存 资 源 ( 对 札 用 随 机 存 储 策 略 的 容 器 )<br>或者 仅 仅调 用 元 素 的 析 构 函 数 ( 对 采 用 连 续 存 储 策 略 的 容 器 </p>
<p>对 象 类 型 一 般 需 要 符 合 下 述 要 求 , 才 能 够 作 为 STL 容 器 的 元 素 。<br>(1) 可 默 认 构 造 的 。 但 不 是 在 任 何 情 况 下 都 需 要 满 足 这 一 条 , 比 如 关 联 式 容 器 ,<br>i 对 于 顺 序 容 器 , 除 非 在 初 始 化 的 时 候 需 要 插 入 默 认 构 造 的 若 干 个 对 象 , 或 者 调 用 容<br>| 器 的 resize0、assign0、insert0等 函 数 的 菜 些 版 本 , 否 则 也 不 需 要 满 足 这 – 条 。<br>(2)) 可 拷 贝 构 造 的 。<br>(3) 可 拷 贝 赋 值 的 ( 但 也 不 是 在 任 何 情 况 下 都 需 要 )。<br>这 几 条 条 对 基 本 数 据 类 型 及 不 含 指 针 成 员 和 引 用 成 员 的 类 型 都 是 适 用 的 。<br>(4) 或 者 , 具 有 public的 、 采 用 拷 贝 的 方 式 显 式 定 义 的 拷 贝 构 造 函 数 、 拷 贝 赋<br>, 值 函 数 和 析 构 函 数 。 这 一 条 适 用 于 含 有 指 针 成 员 或 引 用 成 员 的 对 象 ,<br>但 模 拟 指 针 ( 例如 迭 代 器 ) 应 该 归 入 前 面 几 条 中 </p>
<p>引 用 不 能 作 为 STL 容 噩 的 元 素 类 型 :<br>第 一 , 引用 在创 建 时 必 须 初 始 化 为 一 个 具 体 的 对 氢 , 而 STL 容 器 不 能 满 尸 这 一 要 求 ;<br>第 二 , 引 用 没 有 构 造 函 数 和 析 构 函 数 , 更 没 有 赋 值 语 义 .</p>
<h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭 代 器 是 为 了 降 低 容 器 和 泛 型 算 法 之 间 的 糖 合 性 而 设 计<br>指 针 代 表 眠 正 的 内 存 地 址 , 即 对 象 在 内 存 中 的 存 储 位 置 ;<br>而 迭 代 器 则 代 表 元 素 在 容 器 中 的 相 对 位 置<br>( 当 道 历 容 命 的 时 候 , 关 联 式 容 器 的 元 素 也 就 具 有 了 “ 相 对 位 置 “)。</p>
<p>vector, 没 有 必 要 重 新 定 义 迭 代 器 类 型 , 其 元 素 ! 的 指 针 就 可 以 直 接 充 当 迭 代 器</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> T* iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> T* iterator;</span><br></pre></td></tr></table></figure>

<p>采 用 不 连 续 存 储 或 其 他 存 储 方 式 的 容 器 , 例 如 ist. deque. set. map 等 ,<br>则 | 需 定 义 自 己 的 迭 代 器 类 (class), 一 般 情 况 下 它 们 是 对 元 素 指 针 的 封 装 , 即 模 拟 指 针</p>
<p>一 些 特 殊 容 器 如 <code>vector&lt;bool&gt;</code> 和 <code>bitset&lt;N&gt;</code> 等 ,</p>
<p>较 典 型 的 算 法 就 是 distance 和 advance。 这 方 面 的 知 识 涉 及 到 traits 技术<br>使 用 <code>vector&lt;int&gt;::iterator</code>, 而不是<code>int*</code> 虽然它们是等价的’,</p>
<h4 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h4><p>迭 代 器 失 效 是 指 当 <strong>容 器 底 层 存 储 发 生 变 动</strong> 时 , 原 来 指 向 容 器 中 某 个 或 某 些 元 素 的 迭 代 器<br>由 于 元 素 的 存 储 位 置 发 生 了 改 变 而 不 再 指 向 它 们 , 从 而 成 为 无 效 的 迭 代 器 。 |<br>使 用 无 效 的 迭 代 器 就 像 使 用 无 效 的 指 针 ( 野 指 针 ) 一 样 危 险 。</p>
<p>引 起 容 器 存 储 的 变 动 呢<br>主 要 有 : reserve(0、 resize(). push_back(), pop_back(). insert(). erase(). clear() 等 容 器 方 法<br>和 一 些 泛 型 算 法 , 如 sort()、copy()、 replace()、remove()、unique(),<br>以 及 集 合 操 作 ( 并 、 交 、 差 ) 算 法 等</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">《</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; ages</span>; / 未 预 留 空 间</span><br><span class="line">ages.<span class="built_in">push_back</span>(<span class="number">2</span>); / 引 起 内 存 重 分 配</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator p = ages.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> Ginti=<span class="number">0</span>;i&lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">ages.<span class="built_in">push_back</span>(<span class="number">5</span>); / 会 引 起 若 干 次 内 存 重 分 配 操 作</span><br><span class="line">&#125;</span><br><span class="line">. cout &lt;&lt; “The first age :“&lt;&lt;*p &lt;&lt; endl: /p 已 经 失 效 , 危 险 !</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator p = ages.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>; i&lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">ages.<span class="built_in">push_back</span>(<span class="number">5</span>); / 会 引 起 若 干 次 内 存 重 分 配 操 作</span><br><span class="line">&#125;</span><br><span class="line">p = ages.<span class="built_in">begin</span>(); / 重 新 获 取 迭 代 器</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The first age : “&lt;&lt; *p &lt;&lt; endl; 八 ok</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>容 量 是 为 了 减 少 那 些 使 用 连 续 空 间 ( 线 性 空 间 》 存 储 元 素 的 容 器 在 增 加 元 素 时<br>重 新 分 配 内 存 的 次 数 的 一 种 机 制 , 即 当 增 加 元 素 且 剩 余 空 闲 空 间 不 足 时 ,<br>按照 一 定 比 例 ( 通 常 是 原 来 容 量 的 2 或 1.5 倍 )<br><img src="/../img/C++/Pasted%20image%2020230603075716.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">我 们 可 以 从 std::vector&lt;T&gt;的 size0和 capacity0这 两 个</span><br><span class="line">成 员 函 数 的 实 现 上 看 出 容 器 所 辖 元 素 空 间 和 容 量 的 区 别 :</span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> (start == <span class="number">0</span> ? <span class="number">0</span> : end_of_storage - start); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (start == (<span class="number">70</span>: finish - start); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">reserve</span>(size_type n);</span><br></pre></td></tr></table></figure>

<p>(1)) 如 果 n 大 于 容 器 现 有 的 容 量 ( 即 capacity0),<br>则 需 要 在 自 由 内 存 区 为 整 个 容 器 重 新 分 配 一 块 新 的 更 大 的 连 续 空 间 , 其 大 小 为 n * sizeof (T),<br>然 后 将 容 器 内 所 有有 效 元 素 从 旧 位 置 全 部 拷 贝 到 新 位 置 ( 调 用 拷 贝 构 造 函 数 ),<br>最 后 释 放 旧 位 置 的 所 有存 储 空 间 并 调 整 容 器 对 象 的 元 素 位 置 指 示 器<br>( 就 是 让 那 三 个 指 针 指 向 新 内 存 区 的 相 应 位 置 )。<br>也 就 是 说 , 如 果 请 求 容 量 比 原 有 容 量 大 的 话 , 结 果 是 容 器 的 冗 余 容 量 加 大<br>(2) &lt;&#x3D;n 什么都不做</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; li;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ¢ = <span class="number">0</span>; ¢ &lt; <span class="number">10</span>; c++)</span><br><span class="line"><span class="built_in">lipush_back</span> (c);</span><br><span class="line">vi.<span class="built_in">reserve</span>(li.<span class="built_in">size</span>());<span class="comment">// 预 留 空 间 , 但 是 并 没 有 改 变 容 器 的 大 小 , 预 留 空 间 未 初 始 化</span></span><br><span class="line">std::<span class="built_in">copy</span> (libegin0, liendO vi.<span class="built_in">begin</span>()); / 拷 贝赋 值</span><br><span class="line">std::<span class="built_in">copy</span> (vi-<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cerr, <span class="string">&quot;\t&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确使用方法</span></span><br><span class="line">vi.<span class="built_in">reserve</span> (li.<span class="built_in">size</span>()); <span class="comment">// 预留 空 间 , 但 是 并 没 有 改 </span></span><br><span class="line">std::<span class="built_in">copy</span>(t.beginO, <span class="built_in">liend</span>(), std::<span class="built_in">back_inserter</span>(vi));</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230603081048.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size type n, <span class="type">const</span> T&amp; c = T())</span></span>;</span><br></pre></td></tr></table></figure>

<p>其 中 n 就 是 最 后 要 保 持 的 元 素 个 数 , 如 果 需 要 新 增 元 素 的 话 ,c 则 是 新 增 元 素 的 默 认<br>壹 初 始 值 。 下 面 是 resize()的 实 现 策 略 。<br>(1) 如 果 n 大 于 容 器 当 前 的 大 小 ( 即 size0), 则 在 容 器 的 末 尾 插 入 ( 追加 ) n<br>size0个 初 值 为 c 的 元 素 , 如 果 不 指 定 初 值 , 则 用 元 素 类 型 的 默 认 构 造 函 数 来 初 始 化<br>每一 个 新 元 素 〔 这 可 能 引 起 内 存 重 分 配 以 及 容 器 容 量 的 扩 张 )。<br>(2) 如 果 n 小 于 容 器 当 前 的 大 小 , 则 从 容 器 的 末 尾 删 除 size 0 ~ n 个 元 素 ,<br>但i <strong>不 释 放 元 素 本 身 的 内 存 空 间</strong>, 因 此 容 量 不 变 。<br>(3) 否 则 , 什 么 也 不 做 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">td::list&lt;<span class="type">int</span>&gt; 。 止 ;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">10</span>; c++)</span><br><span class="line">li.<span class="built_in">push_back</span> (c);</span><br><span class="line">vi-<span class="built_in">resize</span>(li.<span class="built_in">size</span>(); / 调 整 容 器 大 小</span><br><span class="line">std::<span class="built_in">copy</span> (li-<span class="built_in">begin</span>(), li.<span class="built_in">end</span>(), vi-<span class="built_in">begin</span>()); UMA</span><br><span class="line">std::<span class="built_in">copy</span> (vi-<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cerr, <span class="string">&quot;\t&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230603081829.png"></p>
<p> 压 缩 容 器的 多 余 容 量 从 而 节 省 存 储 空 间<br> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> std::vector&lt;<span class="type">int</span>&gt; — vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">10</span>; c++)</span><br><span class="line">vi.<span class="built_in">push_back</span> (c);</span><br><span class="line">std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vi).<span class="built_in">swap</span>(vi); W 构 造 一 个 临 时 对 象 , 然 后 与 之 交 换 元 素</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">17</span><span class="number">-7</span> 一 个 固 定 容 量 的 循 环 队 </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T <span class="comment">/* 元 素 类 型 */</span> , <span class="type">unsigned</span> <span class="type">int</span> N <span class="comment">/* 容 量 */</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CyclicQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> T&amp; const_reference;</span><br><span class="line"><span class="built_in">CyclicQueue</span>() : <span class="built_in">m_popPos</span>(<span class="number">0</span>), <span class="built_in">m_count</span>(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">assert</span>(N &gt; <span class="number">0</span>);</span><br><span class="line">m_beginPtr = (T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T) * N)); / 分 配 原 始 空 间</span><br><span class="line">&#125; 。</span><br><span class="line">~<span class="built_in">CyclicQueue</span>() &#123;</span><br><span class="line">_Clear(); <span class="comment">// this-&gt;_Clear(Q);</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">((<span class="type">void</span>*)m_beginPtr)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CyclicQueue</span>(<span class="type">const</span> CyclicQueue&lt;T, N&gt;&amp; copy) : <span class="built_in">m_popPos</span>(<span class="number">0</span>), <span class="built_in">m_count</span>(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">assert</span>(N &gt; <span class="number">0</span>);</span><br><span class="line">m_beginPtr = (T*)(<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T) * N)); / 分 配 原 始 空 间</span><br><span class="line"><span class="type">size_t</span> copyPos = copy.m_popPos;</span><br><span class="line"><span class="keyword">for</span> (size_type idx = <span class="number">0</span>; idx &lt; copy.m_count; ++idx) 【</span><br><span class="line">_Copy(idx, copy.m_beginPtr[copyPos&#125;); <span class="comment">// this-&gt;_Copy0Q;</span></span><br><span class="line">++copyPos; copyPos %= N; ++m_count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">CyclicQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CyclicQueue&lt;T, N&gt;&amp; other) &#123;</span><br><span class="line">CyclicQueue&lt;T, N&gt; <span class="built_in">temp</span>(other); W 调 用 拷 贝 构 造 函 数</span><br><span class="line"><span class="built_in">swap</span>(temp); [ff <span class="keyword">this</span>-&gt;swapQ);</span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (m_count == <span class="number">0</span>); &#125;</span><br><span class="line"><span class="type">bool</span> isfulO <span class="type">const</span> &#123; <span class="keyword">return</span> (m_count == N); &#125;</span><br><span class="line"><span class="function">value_type <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(m_count != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (m_beginPtr[m_popPos&#125;);</span><br><span class="line">&#125; .</span><br><span class="line"><span class="function">value_type <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(m_count != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (m_beginPtr[m_popPos]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">value_type <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(m_count != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">size_type pushPos = (m_popPos + m_count) % N;</span><br><span class="line"><span class="keyword">if</span> (pushPos== <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (*(m_beginPtr + N - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> (m_beginPtr[pushPos - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">) <span class="function">value_type <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(m_count &#123;= <span class="number">0</span>);</span><br><span class="line">size_type pushPos = (m_popPos + m_count) % N;</span><br><span class="line"><span class="keyword">if</span> (pushPos == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (*(m_beginPtr + N - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">return</span> (m_beginPtr[pushPos - <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">; <span class="type">bool</span> <span class="built_in">push</span>(const_reference data = TO) &#123;</span><br><span class="line">| <span class="keyword">if</span> (m_count &lt;N) t / 不 满 !</span><br><span class="line">size_type pushPos = (m_popPos + m_count) % N;</span><br><span class="line">i _Copy(pushPos, data); /! <span class="keyword">this</span>-&gt;_CopyQ;</span><br><span class="line">++m_count;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">)</span><br><span class="line">) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">) <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(reference data)</span> </span>&#123;</span><br><span class="line">| <span class="keyword">if</span> (m_count &gt; <span class="number">0</span>) &#123; 丫 不 宇 !</span><br><span class="line">data = m_beginPtr[m_popPos]; /f <span class="keyword">operator</span>=</span><br><span class="line">彗 _Destroy(m_popPos); <span class="comment">// this-&gt;_Destroy(Q);</span></span><br><span class="line">--m_count; ++m_popPos; m_popPos %= N; / 新 的 pop 位 置</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_count; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;_Clear(); &#125; / <span class="keyword">this</span>-&gt;_Clear();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(CyclicQueue&lt;T, N&gt;&amp; other)</span> </span>&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(m_beginPtr, other.m_beginPtr);</span><br><span class="line">std::<span class="built_in">swap</span>(m_popPos, other.m_popPos);</span><br><span class="line">std::<span class="built_in">swap</span>(m_count, other.m_count);i|</span><br><span class="line">i</span><br><span class="line"><span class="string">&#x27; &#125;</span></span><br><span class="line"><span class="string">i</span></span><br><span class="line"><span class="string">ii private:</span></span><br><span class="line"><span class="string">void Clear() &#123;</span></span><br><span class="line"><span class="string">for (; m_count &gt; 0; --m_count) &#123;</span></span><br><span class="line"><span class="string">_Destroy(m_popPos); H this-&gt;_Destroy();</span></span><br><span class="line"><span class="string">| ++m_popPos; m_popPos %= N;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">m_popPos = 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void _Destroy(sizetype idx) &#123;</span></span><br><span class="line"><span class="string">assert(idx &lt; NJ;</span></span><br><span class="line"><span class="string">T *pTemp = (m_beginPtr + idx);</span></span><br><span class="line"><span class="string">pTemp-&gt;~TQ; W 调 用 析 构 函 数 销 毁 元 素 对 象</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void _Copy(size_type idx, const_reference data) &#123;</span></span><br><span class="line"><span class="string">assert(idx &lt; N);</span></span><br><span class="line"><span class="string">T *pTemp = (m_beginPtr + idx);</span></span><br><span class="line"><span class="string">new ((void*)pTemp) T(data); // 调 用 placement new 和 拷 贝 构 造 函 数 拷 贝 对 象</span></span><br><span class="line"><span class="string">| &#125;|</span></span><br><span class="line"><span class="string">| value_type *m_beginPtr; / 队 列 存 储 空 间 起 始 位 置</span></span><br><span class="line"><span class="string">size_type m_popPos; / 下 次 pop 位 置</span></span><br><span class="line"><span class="string">| size_type m_count; / 有 效 元 紫 个 数</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>

<p><strong>尽 量 不 要 在 道 历 容 器 的 过 程 中 义 容 器 进 行 插 入 元 素 、 删除 元 素 等 修 改 擎作 ,</strong><br>这 和 不 要 在 for 循 环 中 修 改 计 数 器 是 一 个 道 理 , 特 别 是 连 续 存 储 的 容器 中 。<br>因 为 这 些 操 作 会 使 一 些 追 代 器 失 效 , 特 别 是 当 前 选 代 器 , 这 在 效果 上 等 价 于 修 改 了 循 环 计 数 器 。<br>更 进 一 步 的 原 因 是 下 一 次 迭 代 操 作 , 即++iterator 会 使 用 本 次 选 代 操 作 的 选 代 器 ,<br>而 当 前 迭 代 器 可 能 已 经 失 效 </p>
<p>虽然 有 些 容 器 如 list, 修 改 操 作 只 会 使 当 前 选 代 器 失 效 , 即 并 不 会 引 起 存储 空 间 重 分 配 ,<br>所 以 可 以 在 邋 历 的 过 程 中 正 确 地 删 除 当 前 元 素 ( 这 里 面有一 个 技 巧 ),<br>但 是 也 最 好 不 要 这 样 做 , 否 则 可 能 存 在 重 大 隐 惠 . 参 见 list等 的 remove(). remove_if() 成 员 函 数 的 实 现 </p>
<h3 id="存储分配器"><a href="#存储分配器" class="headerlink" title="存储分配器"></a>存储分配器</h3><p>allocator类 是 一 个 模 板 , 作 为 容 器 类 模 板 的 一 个 policy 参 数 , 它 不 仅 与 将 要 为 之<br>分 配 空 间 的 数 据 对 象 的 类 型 无 关 , 并 且 为 动 态 内 存 的 分 配 和 释 放 提 供 了 面 向 对 象 的<br>接 口 。 它 是 对 new 运 算 符 的 更 高 层 次 的 抽 象 , 即 隐 藏 了 底 层 的 内 存 模 式 〔 段 内 存 、<br>! 共享 内 存 、 分 布 式 内 存 等 ), 封 装 了 动 态 内 存 分 配 和 释 放 操 作 , 隐 藏 了 指 针 本 身 的 大<br>| 小 、 存 储 空 间 重 分 配 模 型 及 内 存 页 大 小 等 细 节 , 提 供 了 更 好 的 可 移 植 性 。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例<span class="number">17</span><span class="number">-8</span>  COM 环 境 下 STL 容 器 的 allocator 实 </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">STLCOMAllocator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line"><span class="keyword">typedef</span> _Ty* pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> _Ty* const_pointer;</span><br><span class="line"><span class="keyword">typedef</span> _Ty&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> _Ty&amp; const_reference;</span><br><span class="line"><span class="function">pointer <span class="title">address</span><span class="params">(reference ref)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (&amp;ref); &#125;</span><br><span class="line"><span class="function">const_pointer <span class="title">address</span><span class="params">(const_reference ref)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (&amp;ref); &#125;</span><br><span class="line"><span class="function">_Ty* <span class="title">allocate</span><span class="params">(size_type n, <span class="type">const</span> <span class="type">void</span>* <span class="comment">/* no use */</span> )</span></span></span><br><span class="line"><span class="function">皇 </span>&#123; <span class="keyword">return</span> (pointer)(::<span class="built_in">CoTaskMemAlloc</span>(n * <span class="built_in">sizeof</span>(_Ty))); &#125; <span class="comment">// aligned!</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, size_type <span class="comment">/* no use */</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123; ::<span class="built_in">CoTaskMemFree</span>(p); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer p, <span class="type">const</span> Ty&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="keyword">new</span> ((<span class="type">void</span>*)p)_Ty(v); <span class="comment">// placement new &amp; copy constructor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) p-&gt;~_TyQ; <span class="comment">// destructor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">size_type sz = (size_type)(<span class="number">-1</span>) / <span class="built_in">sizeof</span>(_ Ty);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span> &lt; sz? sz: <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty, <span class="keyword">typename</span> _U&gt; <span class="keyword">inline</span></span><br><span class="line"><span class="type">bool</span> __stdcall <span class="keyword">operator</span> ==(<span class="type">const</span> STLCOMAllocator&lt;_Ty&gt;&amp;,</span><br><span class="line"><span class="type">const</span> STLCOMAllocator&lt;_U&gt;&amp;)</span><br><span class="line">&#123; <span class="built_in">return</span> (<span class="literal">true</span>); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty, <span class="keyword">typename</span> _U&gt; <span class="keyword">inline</span></span><br><span class="line"><span class="type">bool</span> __stdcall <span class="keyword">operator</span> !=(<span class="type">const</span> STLCOMAIlocator&lt;_Ty&gt;&amp;,</span><br><span class="line"><span class="type">const</span> STLCOMAIlocator&lt;_U&gt;&amp;)</span><br><span class="line">&#123; <span class="built_in">return</span> (<span class="literal">false</span>); </span><br></pre></td></tr></table></figure>

<h3 id="适配器-容器适配器-stack-deque-list"><a href="#适配器-容器适配器-stack-deque-list" class="headerlink" title="适配器 容器适配器 stack deque list"></a>适配器 容器适配器 stack deque list</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; li;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k<span class="number">+4</span>) &#123;</span><br><span class="line">li.<span class="built_in">push_back</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(li.<span class="built_in">begin</span>(), li.endQ, ostream _iterator&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; list ;</span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; eos, <span class="built_in">isiter</span>(cin);</span><br><span class="line"><span class="built_in">copy</span>(isiter, eos, <span class="built_in">back_inserter</span>(li));</span><br><span class="line"><span class="built_in">copy</span>(li.<span class="built_in">begin</span>(),li.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout,<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>


<h3 id="泛型算法-1"><a href="#泛型算法-1" class="headerlink" title="泛型算法"></a>泛型算法</h3><p>STL 提 供 的 泛 型 算 法 主 要 有 如 下 几 种 ;</p>
<blockquote>
<p>“ 查 找 算 法 , 如 find0、search0、binary search()、find_if0等 。<br>今 “ 排 序 算 法 , 如 sort)、merge0等 。<br>从 “ 数 学 计 算 , 如 accumulate0、inner product0、partial sum0 等 。</p>
</blockquote>
<ul>
<li>“ 集合 运 算 , 如 set_union0、set_intersection0、includes0等 。</li>
<li>“容器 管 理 , 如 copy0、replace0、transform0、remove()、for each() 等 。<blockquote>
<p>“ 统 计 运 算 , 如 max(0O、min0、count0、max_element0等 。<br>今 “ 堆 管 理 , 如 make_heap()、push_heap0、pop_ heap(). sort_heap().<br>“ 比 较 运 算 , 如 equal0等</p>
</blockquote>
</li>
</ul>
<p> 泛 型 算 法 一 般 接 受 下 列 参 数 类 型 的 一 种 或 几 种<br>“ 迭 代 器 , 标 示 容 器 或 区 间 的 范 围 , 以值 传 递 。<br>从 “ 谓 词 , 返 回 bool 值 的 函 数 对 象 , 指 定 算 法 的 操 作 方 式 , 例 如 find_if0的 第 三<br>个 参 数 。<br>从 函 数 对 象 , 用 户 指 定 要 做 的 操 作 , 例 如 for_ each(0)的 第 三 个 参 数 。<br>今 “ 容器 元 素 , 用 户 指 定 的 基 准 对 象 , 例 如 find0的 第 三 个 参 数 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Template&lt;<span class="keyword">typename</span> Inputlterator, <span class="keyword">typename</span> Outputlterator&gt; <span class="keyword">inline</span></span></span><br><span class="line"><span class="function">Outputlterator <span class="title">copy</span><span class="params">(Inputlterator first, InputIterator last, Outputlterator oi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(; first != last; ++first, ++oi)</span><br><span class="line">	*oi = *first;</span><br><span class="line">	<span class="keyword">return</span> Oi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; i; vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c&lt; <span class="number">10</span>; c++) li.<span class="built_in">push_back</span>(c);</span><br><span class="line">vi.<span class="built_in">resize</span>(li.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">copy</span>(libeginO, liendO, vi.<span class="built_in">begin</span>()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; i; vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c&lt; <span class="number">10</span>; c++) li.<span class="built_in">push_back</span>(c);</span><br><span class="line">/ 拷 贝 链 表 元 素 到 vi 中 , 使 用 插 入 迭 代 器</span><br><span class="line"><span class="built_in">copy</span>(<span class="built_in">libegin</span>(, li.endQ), <span class="built_in">back_inserter</span>(vi)); / 调 用 vi.<span class="built_in">push_back</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>侃 多 泛 型 算 法 总 是 假 定 容 器 的 元 素 类 型 定 义 了 operator-(、operator–0、 operatorl&#x3D;()、operator&lt;() 或 operator&gt;() 等 函 数 , 因 此 你 有 义 务 为 你 的 家 器 元 素 类 型 定 义 它 们 , 否 则 泛 型 算 法 将 采 用 元 素 类 型 的 默 认 语 义 或 者 报 错。</p>
<p>在 应 用 编 程 时 要 选 用 最 合 适 的 算法<br>,find0 算 法 的 复 杂 度 为 O(, 而 binary seareh0 算 法 的 复 杂 度 为$O(log{2}N)$当 容 器 中 的 元 素 有 序 时 , 当 然 应 选 用 binary seareh0。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">示例 <span class="number">17</span><span class="number">-15</span> 基 于 STL 框 架 实 现 的 “ 折 半 “ 查找 算法</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">RandomAccessIterator <span class="title">binary_search</span><span class="params">(RandomAccesslterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">RandomAccesslterator last,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">RandomAccesslterator mid, not_found </span>= last;</span><br><span class="line"><span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">mid = first + (last - frst) / <span class="number">2</span>:; / 注 意 : 不是 (first + last) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">L</span>(value &lt; *mid) &amp;&amp; !(*mid &lt; value))</span><br><span class="line"><span class="keyword">return</span> mid; /! 调 用 T::<span class="keyword">operator</span>&lt;()</span><br><span class="line"><span class="keyword">if</span> (value &lt; *mid)</span><br><span class="line">last = mid; <span class="comment">// 调 用 T::operator&lt;()</span></span><br><span class="line"><span class="keyword">else</span> first = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> not_found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一些特殊容器"><a href="#一些特殊容器" class="headerlink" title="一些特殊容器"></a>一些特殊容器</h3><h3 id="string-类"><a href="#string-类" class="headerlink" title="string 类"></a>string 类</h3><h3 id="bitset-并非set"><a href="#bitset-并非set" class="headerlink" title="bitset 并非set"></a>bitset 并非set</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> Length&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bitset</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">reference</span>&#123; ... &#125;; / 可 以 自 动 转 换 为 <span class="type">bool</span> 变 量</span><br><span class="line"><span class="comment">// constructors...</span></span><br><span class="line">Hf accessors...</span><br><span class="line"><span class="comment">// rautators...</span></span><br><span class="line"><span class="comment">// convertors...</span></span><br><span class="line"><span class="comment">// statistics...</span></span><br><span class="line"><span class="comment">// test...</span></span><br><span class="line">I &amp;=, |=, *=, &lt;&lt;=, &gt;&gt;=, &gt;&gt;, &lt;&lt;, ==, !=, ~ overloading...</span><br><span class="line">/ &lt;&lt;(output), &gt;&gt;(input), &amp;, |, ^ <span class="keyword">friend</span> overloading...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">WORD BITS = <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) * <span class="number">8</span>, / WORD 的 bit 数</span><br><span class="line">N_WORD= ( Length== <span class="number">0</span> ? <span class="number">0</span> : (Length - <span class="number">1</span>) /,WORD_BITS )</span><br><span class="line"><span class="comment">// Length 个 bit 折 合 多 少 个 WORD</span></span><br><span class="line">出</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> array[N_WORD + <span class="number">1</span>]; <span class="built_in">ABBA</span> ( 不 能 定 义 长 度 为 <span class="number">0</span> 的 数 组 )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230603090456.png"></p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector&lt;bool&gt;"></a><code>vector&lt;bool&gt;</code></h3><p><img src="/../img/C++/Pasted%20image%2020230603091045.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">bool</span>&gt; BoolVector; <span class="comment">// vector&lt;bool&gt;的 具 体 名 字 与 STL 实现 有 关</span></span><br><span class="line">BoolVector bvect;</span><br><span class="line">bvect.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (inti = <span class="number">0</span>; i &lt; <span class="number">100</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">bvect.<span class="built_in">insert</span>(bvect.<span class="built_in">end</span>(), <span class="literal">true</span>);</span><br><span class="line">bvect.<span class="built_in">insert</span>(bvect.<span class="built_in">end</span>(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BoolVector::iterator first = bvect.<span class="built_in">begin</span>(),</span><br><span class="line">last = bvect.<span class="built_in">end</span>(); first != last; ++first) &#123;</span><br><span class="line">cout &lt;&lt; *first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; bvect.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">bvect.<span class="built_in">front</span>(). flipQ;</span><br><span class="line">bvect.<span class="built_in">back</span>().flipQ;</span><br><span class="line">bvect.flipQ;</span><br><span class="line">bvect.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空容器"><a href="#空容器" class="headerlink" title="空容器"></a>空容器</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; li; / 空 容 器</span><br><span class="line">li.pop_backQ; <span class="comment">// runtime error!</span></span><br><span class="line"><span class="keyword">if</span></span><br><span class="line">(!li.<span class="built_in">empty</span>()) li.<span class="built_in">erase</span>(li.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 例 <span class="number">17</span><span class="number">-20</span>。 示 例 <span class="number">17</span><span class="number">-20</span> </span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> / 顺 序 容 器 </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span> / 联 合 容 器</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> using namespace std; </span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line">  list&lt;<span class="type">int</span>&gt; temp1;</span><br><span class="line">   temp] .<span class="built_in">insert</span>(temp<span class="number">1.</span><span class="built_in">end</span>(), <span class="number">10</span>);</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; li; W 空 容 器</span><br><span class="line">liinsertdisend0, <span class="number">10</span>); / 创 建 新 对 象</span><br><span class="line">li.<span class="built_in">insert</span>(li.endQ, <span class="number">10</span>); / 创 建 新 对 象</span><br><span class="line"><span class="built_in">Iierase</span>(temp1l.begin0O); “ 丫 runtime error! 虫 然 li 中 也 有 值 为 <span class="number">10</span> 的 <span class="type">int</span> 元 素</span><br><span class="line">/ 但 是 temp<span class="number">1.</span>begin0指 向 的 元 素 对 象 并 不 属 于 li 所 有</span><br><span class="line"><span class="built_in">lierase</span>(li-<span class="built_in">begin</span>(Q)); ok! libegin0指 向 的 对 象 为 ii 所 有</span><br><span class="line">| <span class="built_in">lierase</span>(*p); W compiling error! 没 有 定 义 这 样 的 方 法 , 对象 *p 不</span><br><span class="line">W 属 于 i 所 有 。 不 能 以 元 素 的 值 来 判 断 其 是 否 属 于 一</span><br><span class="line">W 个 顺 序 容 器 , 因 为 顺 序 容 器 可 以 同 时 存 储 值 完 全 相 同</span><br><span class="line">W 的 多 个 对 象 ; 否 则 容 器 将 不 知 道 该 删 除 哪 一 个 元 素 了</span><br><span class="line"><span class="number">1</span> set&lt;<span class="type">int</span>&gt; temp2;</span><br><span class="line">| temp<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">set&lt;<span class="type">int</span>&gt; si; / 空容 器</span><br><span class="line"><span class="built_in">siinsert</span>(<span class="number">10</span>); / si 包 含 一 个 值 为 <span class="number">10</span> 的元 素</span><br><span class="line"><span class="built_in">siinsert</span>(si.<span class="built_in">end</span>(<span class="number">0</span>), <span class="number">20</span>);</span><br><span class="line"><span class="built_in">siinsert</span>(<span class="built_in">sisend</span>(<span class="number">0</span>), <span class="number">20</span>); 丫 忽 略 !</span><br><span class="line">si.<span class="built_in">erase</span>(temp<span class="number">2.</span>beginQ); —_<span class="comment">// runtime error! temp2.begin0指 向 的 对 参 不 属 于 si 所 有</span></span><br><span class="line">si.<span class="built_in">erase</span>(*p); (OK! 从 si 中 删 除 值 等 于 *p 的元 素</span><br><span class="line">si.<span class="built_in">erase</span>(si.<span class="built_in">begin</span>()); OK! sitbegin0 指 向 的 对 象 为 si 所 有</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除 了 上 面 这 些 特 殊 容 器 外 , 还 有 一 些 专 用 于 数 学 运 算 的 容 器 、 算 法 和 类 型 ,<br>如 valarray、 complex 等 , 分 别 定 义 在 头 文 件 <code>&lt;valarray&gt;和 &lt;complex&gt;</code> 中 ,<br>头 文 件 <code>&lt;numeric&gt;</code> 中 定 义 了 用 于 向 量 计 算 的 算 法 </p>
<p>往 容 器 中 插 入 元 素 时 , 若 元 素 在 容 器 中 的 顺 序 无 关 紧 要 , 请 尽 量 加 在 最<br>后 面 。 若 经 常 需 要 在 序 列 容 器 的 开 头 或 中 间 增 加 或 删 除 元 素 时 , 应选 用<br>list.</p>
<p>当 容 器 作 为 参 数 被 传 递 时 , 请 采 用 引 用 传 递 方 式 。 否 则 将 调 用 容 器 的 拷<br>贝构 造 函 数 , 其 开 销 是 难 以 想 象 的 </p>
<p>当 元 素 的 有 序 比 搜 索 速 度 更 重 要 时 , 应 选 用 set. multiset.map或 multimap。<br>否 则 , 选 用 hash_set、hash_multiset、hash_map 或 hash_multimap。</p>
<p><img src="/../img/C++/Pasted%20image%2020230603100246.png"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* strDest, <span class="type">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>( (strDest != <span class="literal">NULL</span>) &amp;&amp; (srtSrc != <span class="literal">NULL</span>) );</span><br><span class="line">	<span class="type">char</span>* address = strDest;</span><br><span class="line">	<span class="keyword">while</span> ( (*strDest++ = *strSrc++) != <span class="string">&#x27;\0&#x27;</span> );</span><br><span class="line">	<span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;&quot;</span>); <span class="comment">//智 通 构 造 函 数</span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String &amp;other);  <span class="comment">// 拷 贝 构 造 函 数</span></span><br><span class="line">	~ <span class="built_in">String</span>(<span class="type">void</span>);</span><br><span class="line">	String&amp; operate =(<span class="type">const</span> String &amp;other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> *m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//String 的 普 通 构 造 函 数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str) / <span class="number">6</span> 分</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(str == <span class="literal">NULL</span>)</span><br><span class="line">	&#123; </span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">		*m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[length<span class="number">+1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 的 析 构 函 数</span></span><br><span class="line">String::~<span class="built_in">String</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷 贝 构 造 函 数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> length = <span class="built_in">strlen</span>(other.m_data);</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="type">char</span>[length<span class="number">+1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值 函 数</span></span><br><span class="line">String &amp; String::operate =(<span class="type">const</span> String &amp;other)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> *temp = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(temp, other.m_data);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">delete</span> [] m_data;</span><br><span class="line">		m_data = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>Golang 源码编译安装 CentOS 7 note</title>
    <url>/2019/03/04/Golang-%E6%BA%90%E7%A0%81-CentOS-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-note/</url>
    <content><![CDATA[<h2 id="1-Prefix"><a href="#1-Prefix" class="headerlink" title="1. Prefix"></a>1. Prefix</h2><ul>
<li><p>需要下载的文件: <strong><a href="https://golang.org/dl/">Download</a></strong></p>
<ul>
<li>go1.12.src.tar.gz</li>
<li>go1.4.3.src.tar.gz</li>
<li>gcc glibc-devel</li>
</ul>
</li>
<li><p>go1.4以上版本安装 <strong>依赖</strong> <em><strong>go1.4</strong></em> 需要先编译安装go1.4, 否则会报错 (这个设定 很奇怪 不过 never mind just do it)<br> 报错提示信息如下:</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Building Go cmd/dist using /root/go1.4.</span><br><span class="line">ERROR: Cannot find /root/go1.4/bin/go.</span><br><span class="line">Set <span class="variable">$GOROOT_BOOTSTRAP</span> to a working Go tree &gt;= Go 1.4.</span><br></pre></td></tr></table></figure></li>
<li><p>安装 gcc 用于编译 go 1.4</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y gcc glibc-devel</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="2-Install-go1-4-3-src-tar-gz"><a href="#2-Install-go1-4-3-src-tar-gz" class="headerlink" title="2. Install go1.4.3.src.tar.gz"></a>2. Install go1.4.3.src.tar.gz</h2><h3 id="2-1-安装-go1-4-3"><a href="#2-1-安装-go1-4-3" class="headerlink" title="2.1 安装 go1.4.3"></a>2.1 安装 go1.4.3</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /root/go1.4</span><br><span class="line">tar -xvf go1.4.3.src.tar.gz -C /root/go1.4</span><br><span class="line"><span class="built_in">cd</span> /root/go1.4/src</span><br><span class="line">./all.bash</span><br></pre></td></tr></table></figure>

<h3 id="2-2-install-error"><a href="#2-2-install-error" class="headerlink" title="2.2 install error"></a>2.2 install error</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--- FAIL: TestParseInLocation (0.00s)</span><br><span class="line">	format_test.go:202: ParseInLocation(Feb 01 2013 AST, Baghdad) = 2013-02-01 00:00:00 +0000 AST, want 2013-02-01 00:00:00 +0300 +03</span><br><span class="line">--- FAIL: TestLoadFixed (0.00s)</span><br><span class="line">	time_test.go:929: Now().In(loc).Zone() = <span class="string">&quot;-01&quot;</span>, -3600, want <span class="string">&quot;GMT+1&quot;</span>, -3600</span><br></pre></td></tr></table></figure>

<p>这两个错误其实是测试文件的报错 与工程编译基本没什么关系 也不太影响 可以跳过 怎么跳过 请看下面</p>
<ol>
<li><p><strong>TestParseInLocation 错误</strong></p>
<ul>
<li><p><em>这个错误是因为</em>:</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The tzdata 2017a update (2017-02-28) changed the abbreviation of the</span><br><span class="line">Asia/Baghdad <span class="keyword">time</span> zone (used <span class="keyword">in</span> TestParseInLocation) from <span class="string">&#x27;AST&#x27;</span> to the</span><br><span class="line">numeric <span class="string">&#x27;+03&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>  请参考 <code>Red Hat Enterprise Linux Timezone Data</code> 的声明:</p>
<ul>
<li><strong><a href="https://access.redhat.com/articles/1187353">Red Hat Enterprise Linux Timezone Data (tzdata) - Development Status Page</a></strong></li>
<li><strong><a href="https://mm.icann.org/pipermail/tz-announce/2017-February/000045.html">2017a release of tz code and data available</a></strong></li>
</ul>
</li>
<li><p><em>解决</em></p>
<p>  这是 <code>src/time/format_test.go</code> 文件 202 行的报错<br>  (不同1.4 go 的版本 行数可能不一样 请根据 函数 <code>TestParseInLocation</code> 查找)</p>
<p>  <img src="/../img/Golang-%E6%BA%90%E7%A0%81-CentOS-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-note/TestParseInLocation_diff.png" alt="TestParseInLocation_diff.png"></p>
<p>  这个 golang github 源码提过的一个 <strong><a href="https://github.com/golang/go/issues/19457">issue</a></strong> 已经解决的</p>
<p>  <code>gopherbot</code> comment 了修改 issue 的 <strong><a href="https://go-review.googlesource.com/c/go/+/37964/">链接</a></strong> 我就是从那里截图过来的 如果访问不到这个链接 按照截图改就行</p>
</li>
</ul>
</li>
<li><p><strong>TestLoadFixed 错误</strong></p>
<ul>
<li><p><em>错误原因</em></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">The tzdata 2017a update (2016-09-18) changed the <span class="keyword">time</span> zone abbreviation from a long English-language string</span><br><span class="line">(such as: <span class="string">&quot;GMT+1&quot;</span>) to <span class="string">&quot;-01&quot;</span>.</span><br></pre></td></tr></table></figure>

<p>  请参考 <code>Red Hat Enterprise Linux Timezone Data</code> 的声明 :</p>
<ul>
<li><strong><a href="https://access.redhat.com/articles/1187353">Red Hat Enterprise Linux Timezone Data (tzdata) - Development Status Page</a></strong></li>
<li><strong><a href="https://mm.icann.org/pipermail/tz-announce/2016-September/000041.html">2016g release of tz code and data available</a></strong></li>
</ul>
</li>
<li><p><em>Fix</em></p>
<p>  这是 <code>src/time/time_test.go</code> 文件 929 行的报错</p>
<p>  <img src="/../img/Golang-%E6%BA%90%E7%A0%81-CentOS-%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85-note/TestLoadFixed_diff.png" alt="TestLoadFixed_diff"></p>
<p>  issue 修改 <strong><a href="https://go-review.googlesource.com/c/go/+/29995/3/src/time/time_test.go#b951">链接</a></strong> 如果访问不到这个链接 按照截图改就行</p>
</li>
</ul>
</li>
</ol>
<h3 id="2-3-install-success"><a href="#2-3-install-success" class="headerlink" title="2.3 install success"></a>2.3 install success</h3><ul>
<li><p>安装成功提示</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ALL TESTS PASSED</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">Installed Go <span class="keyword">for</span> linux/amd64 <span class="keyword">in</span> /home/you/go.</span><br><span class="line">Installed commands <span class="keyword">in</span> /root/go1.4/bin.</span><br><span class="line">*** You need to add /home/go1.4/bin to your <span class="variable">$PATH</span>. ***</span><br></pre></td></tr></table></figure>
</li>
<li><p>看到这个安装成功的提示以后 设置一下 <code>go1.4</code> 的环境变量(待会儿再把它改回 <code>go1.12</code>)</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export PATH=<span class="variable">$PATH</span>:/root/go1.4/bin&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;export GOROOT=/root/go1.4&quot;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 <code>go version</code> 查看版本号</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go version go1.4.3 linux/amd64</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-Install-go1-12-src-tar-gz"><a href="#3-Install-go1-12-src-tar-gz" class="headerlink" title="3. Install go1.12.src.tar.gz"></a>3. Install go1.12.src.tar.gz</h2><ul>
<li><p>安装 go1.12</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> /root/go1.12</span><br><span class="line">tar -xvf go1.12.src.tar.gz -C /root/go1.12</span><br><span class="line"><span class="built_in">cd</span> /root/go1.12/src</span><br><span class="line">./all.bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装成功以后 清掉原来 <code>go1.4</code> 的环境变量 添加如下环境变量</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/root/go1.12/bin</span><br><span class="line"><span class="built_in">export</span> GOROOT=/root/go1.12</span><br><span class="line"><span class="built_in">export</span> GOPATH=/root/go1.12/go-projects</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 <code>go version</code> 查看版本号</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go version go1.12 linux/amd64</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>Golang</tag>
        <tag>CentOS</tag>
        <tag>Linux</tag>
        <tag>源码编译</tag>
      </tags>
  </entry>
  <entry>
    <title>C++11、C++14、C++17、C++20新特性总结（5万字详解）</title>
    <url>/2023/06/04/C++11%E3%80%81C++14%E3%80%81C++17%E3%80%81C++20%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%885%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_41854911/article/details/119657617">C++11、C++14、C++17、C++20新特性总结（5万字详解）_c++20 c++17_小熊coder的博客-CSDN博客</a></p>
<h1 id="C-11、C-14、C-17、C-20新特性总结（5万字详解）"><a href="#C-11、C-14、C-17、C-20新特性总结（5万字详解）" class="headerlink" title="C++11、C++14、C++17、C++20新特性总结（5万字详解）"></a>C++11、C++14、C++17、C++20新特性总结（5万字详解）</h1><h2 id="文章目录"><a href="#文章目录" class="headerlink" title="文章目录"></a>文章目录</h2><ul>
<li><a href="#c11c14c17c20%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%935%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3">C++11、C++14、C++17、C++20新特性总结（5万字详解）</a><ul>
<li><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">文章目录</a><ul>
<li><a href="#c-11%E6%98%AF%E4%BB%80%E4%B9%88c-11%E6%A0%87%E5%87%86%E7%9A%84%E7%94%B1%E6%9D%A5">C++ 11是什么，C++ 11标准的由来</a></li>
<li><a href="#c-auto%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5">C++ auto类型推导完全攻略</a><ul>
<li><a href="#auto-%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E7%9A%84%E8%AF%AD%E6%B3%95%E5%92%8C%E8%A7%84%E5%88%99">auto 类型推导的语法和规则</a></li>
<li><a href="#auto-%E7%9A%84%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95">auto 的高级用法</a></li>
<li><a href="#auto-%E7%9A%84%E9%99%90%E5%88%B6">auto 的限制</a></li>
<li><a href="#auto-%E7%9A%84%E5%BA%94%E7%94%A8">auto 的应用</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8-auto-%E5%AE%9A%E4%B9%89%E8%BF%AD%E4%BB%A3%E5%99%A8">使用 auto 定义迭代器</a></li>
<li><a href="#auto-%E7%94%A8%E4%BA%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B">auto 用于泛型编程</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c-decltype%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC%E5%AE%8C%E5%85%A8%E6%94%BB%E7%95%A5">C++ decltype类型推导完全攻略</a><ul>
<li><a href="#exp-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">exp 注意事项</a></li>
</ul>
</li>
<li><a href="#decltype-%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99">decltype 推导规则</a></li>
<li><a href="#decltype-%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8">decltype 的实际应用</a></li>
<li><a href="#%E6%B1%87%E6%80%BBauto%E5%92%8Cdecltype%E7%9A%84%E5%8C%BA%E5%88%AB">汇总auto和decltype的区别</a><ul>
<li><a href="#%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB">语法格式的区别</a></li>
<li><a href="#%E5%AF%B9-cv-%E9%99%90%E5%AE%9A%E7%AC%A6%E7%9A%84%E5%A4%84%E7%90%86">对 cv 限定符的处理</a></li>
<li><a href="#%E5%AF%B9%E5%BC%95%E7%94%A8%E7%9A%84%E5%A4%84%E7%90%86">对引用的处理</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
<li><a href="#c%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%E8%B7%9F%E8%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B">C++返回值类型后置（跟踪返回值类型）</a></li>
<li><a href="#c11%E5%AF%B9%E6%A8%A1%E6%9D%BF%E5%AE%9E%E4%BE%8B%E5%8C%96%E4%B8%AD%E8%BF%9E%E7%BB%AD%E5%8F%B3%E5%B0%96%E6%8B%AC%E5%8F%B7%E7%9A%84%E6%94%B9%E8%BF%9B">C++11对模板实例化中连续右尖括号&gt;&gt;的改进</a><ul>
<li><a href="#%E6%89%A9%E5%B1%95%E9%98%85%E8%AF%BB">扩展阅读</a></li>
</ul>
</li>
<li><a href="#c11%E4%BD%BF%E7%94%A8using%E5%AE%9A%E4%B9%89%E5%88%AB%E5%90%8D%E6%9B%BF%E4%BB%A3typedef">C++11使用using定义别名（替代typedef）</a></li>
<li><a href="#c11%E6%94%AF%E6%8C%81%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%BB%98%E8%AE%A4%E6%A8%A1%E6%9D%BF%E5%8F%82%E6%95%B0">C++11支持函数模板的默认模板参数</a></li>
<li><a href="#c11%E5%9C%A8%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E5%92%8C%E7%B1%BB%E6%A8%A1%E6%9D%BF%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0">C++11在函数模板和类模板中使用可变参数</a><ul>
<li><a href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF">可变参数模板</a><ul>
<li><a href="#1-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF">1) 可变参数函数模板</a></li>
<li><a href="#2-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%B1%BB%E6%A8%A1%E6%9D%BF">2) 可变参数类模板</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c11-tuple%E5%85%83%E7%BB%84%E8%AF%A6%E8%A7%A3">C++11 tuple元组详解</a><ul>
<li><a href="#tuple%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA">tuple对象的创建</a><ul>
<li><a href="#1-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">1) 类的构造函数</a></li>
<li><a href="#2-make_tuple%E5%87%BD%E6%95%B0">2) make_tuple()函数</a></li>
</ul>
</li>
<li><a href="#tuple%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0">tuple常用函数</a></li>
</ul>
</li>
<li><a href="#c11%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E7%BB%9F%E4%B8%80%E4%BA%86%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F">C++11列表初始化（统一了初始化方式）</a><ul>
<li><a href="#%E7%BB%9F%E4%B8%80%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96">统一的初始化</a></li>
</ul>
</li>
<li><a href="#c11-lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3">C++11 lambda匿名函数用法详解</a><ul>
<li><a href="#lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89">lambda匿名函数的定义</a><ul>
<li><a href="#lambda%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84%E5%A4%96%E9%83%A8%E5%8F%98%E9%87%8F">lambda匿名函数中的[外部变量]</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c11%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93union">C++11非受限联合体（union）</a><ul>
<li><a href="#1-c11-%E5%85%81%E8%AE%B8%E9%9D%9E-pod-%E7%B1%BB%E5%9E%8B">1. C++11 允许非 POD 类型</a></li>
<li><a href="#2-c11-%E5%85%81%E8%AE%B8%E8%81%94%E5%90%88%E4%BD%93%E6%9C%89%E9%9D%99%E6%80%81%E6%88%90%E5%91%98">2. C++11 允许联合体有静态成员</a></li>
</ul>
</li>
<li><a href="#%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%E7%9A%84%E8%B5%8B%E5%80%BC%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">非受限联合体的赋值注意事项</a><ul>
<li><a href="#placement-new-%E6%98%AF%E4%BB%80%E4%B9%88">placement new 是什么？</a></li>
</ul>
</li>
<li><a href="#%E9%9D%9E%E5%8F%97%E9%99%90%E8%81%94%E5%90%88%E4%BD%93%E7%9A%84%E5%8C%BF%E5%90%8D%E5%A3%B0%E6%98%8E%E5%92%8C%E6%9E%9A%E4%B8%BE%E5%BC%8F%E7%B1%BB">非受限联合体的匿名声明和“枚举式类”</a></li>
<li><a href="#c11-for%E5%BE%AA%E7%8E%AF%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84%E5%BE%AA%E7%8E%AF%E8%AF%A6%E8%A7%A3">C++11 for循环（基于范围的循环）详解</a></li>
<li><a href="#c11-for%E5%BE%AA%E7%8E%AF%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">C++11 for循环使用注意事项</a></li>
<li><a href="#c11-constexpr%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E4%B8%BA%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%95%BF%E7%AF%87%E7%A5%9E%E6%96%87">C++11 constexpr：验证是否为常量表达式（长篇神文）</a><ul>
<li><a href="#constexpr%E4%BF%AE%E9%A5%B0%E6%99%AE%E9%80%9A%E5%8F%98%E9%87%8F">constexpr修饰普通变量</a></li>
<li><a href="#constexpr%E4%BF%AE%E9%A5%B0%E5%87%BD%E6%95%B0">constexpr修饰函数</a></li>
<li><a href="#constexpr%E4%BF%AE%E9%A5%B0%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">constexpr修饰类的构造函数</a></li>
<li><a href="#constexpr%E4%BF%AE%E9%A5%B0%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0">constexpr修饰模板函数</a></li>
</ul>
</li>
<li><a href="#c11-constexpr%E5%92%8Cconst%E7%9A%84%E5%8C%BA%E5%88%AB">C++11 constexpr和const的区别</a></li>
<li><a href="#c11-long-long%E8%B6%85%E9%95%BF%E6%95%B4%E5%BD%A2%E8%AF%A6%E8%A7%A3">C++11 long long超长整形详解</a></li>
<li><a href="#c11%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8%E4%B8%80%E7%9C%8B%E5%8D%B3%E6%87%82">C++11右值引用（一看即懂）</a><ul>
<li><a href="#c%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC">C++左值和右值</a></li>
<li><a href="#c%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8">C++右值引用</a></li>
</ul>
</li>
<li><a href="#c11%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E7%94%A8%E6%B3%95">C++11移动构造函数的功能和用法</a><ul>
<li><a href="#c11%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E6%98%AF%E4%BB%80%E4%B9%88">C++11移动语义是什么</a></li>
<li><a href="#c%E7%A7%BB%E5%8A%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">C++移动构造函数（移动语义的具体实现）</a></li>
</ul>
</li>
<li><a href="#c11-move%E5%87%BD%E6%95%B0%E5%B0%86%E5%B7%A6%E5%80%BC%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%B3%E5%80%BC">C++11 move()函数：将左值强制转换为右值</a></li>
<li><a href="#c11%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6%E7%9A%84%E7%94%A8%E6%B3%95">C++11引用限定符的用法</a><ul>
<li><a href="#const%E5%92%8C%E5%BC%95%E7%94%A8%E9%99%90%E5%AE%9A%E7%AC%A6">const和引用限定符</a></li>
</ul>
</li>
<li><a href="#c11%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0">C++11完美转发及其实现</a></li>
<li><a href="#c11-nullptr%E5%88%9D%E5%A7%8B%E5%8C%96%E7%A9%BA%E6%8C%87%E9%92%88">C++11 nullptr：初始化空指针</a></li>
<li><a href="#c11-shared_ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E8%B6%85%E7%BA%A7%E8%AF%A6%E7%BB%86">C++11 shared_ptr智能指针（超级详细）</a><ul>
<li><a href="#c11-shared_ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">C++11 shared_ptr智能指针</a><ul>
<li><a href="#1shared_ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9B%E5%BB%BA">1、shared_ptr智能指针的创建</a></li>
<li><a href="#2shared_ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">2、shared_ptr模板类提供的成员方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c11-unique_ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">C++11 unique_ptr智能指针</a><ul>
<li><a href="#unique_ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9B%E5%BB%BA">unique_ptr智能指针的创建</a></li>
<li><a href="#unique_ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">unique_ptr模板类提供的成员方法</a></li>
</ul>
</li>
<li><a href="#c11-weak_ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">C++11 weak_ptr智能指针</a><ul>
<li><a href="#c11-weak_ptr%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-1">C++11 weak_ptr智能指针</a><ul>
<li><a href="#1weak_ptr%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9B%E5%BB%BA">1、weak_ptr指针的创建</a></li>
<li><a href="#2-weak_ptr%E6%A8%A1%E6%9D%BF%E7%B1%BB%E6%8F%90%E4%BE%9B%E7%9A%84%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95">2) weak_ptr模板类提供的成员方法</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#c14-%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93">C++14 新特性总结</a><ul>
<li><a href="#%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC">函数返回值类型推导</a></li>
<li><a href="#lambda%E5%8F%82%E6%95%B0auto">lambda参数auto</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF">变量模板</a></li>
<li><a href="#%E5%88%AB%E5%90%8D%E6%A8%A1%E6%9D%BF">别名模板</a></li>
<li><a href="#constexpr%E7%9A%84%E9%99%90%E5%88%B6">constexpr的限制</a></li>
<li><a href="#deprecated%E6%A0%87%E8%AE%B0">[[<code>deprecated</code>]]标记</a></li>
<li><a href="#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E9%9D%A2%E9%87%8F%E4%B8%8E%E6%95%B4%E5%BD%A2%E5%AD%97%E9%9D%A2%E9%87%8F%E5%88%86%E9%9A%94%E7%AC%A6">二进制字面量与整形字面量分隔符</a></li>
<li><a href="#stdmake_unique">std::make_unique</a></li>
<li><a href="#stdshared_timed_mutex%E4%B8%8Estdshared_lock">std::shared_timed_mutex与std::shared_lock</a></li>
<li><a href="#stdinteger_sequence">std::integer_sequence</a></li>
<li><a href="#stdexchange">std::exchange</a></li>
<li><a href="#stdquoted">std::quoted</a></li>
</ul>
</li>
<li><a href="#c17%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93">C++17新特性总结</a><ul>
<li><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E6%8E%A8%E5%AF%BC">构造函数模板推导</a></li>
<li><a href="#%E7%BB%93%E6%9E%84%E5%8C%96%E7%BB%91%E5%AE%9A">结构化绑定</a></li>
<li><a href="#if-switch%E8%AF%AD%E5%8F%A5%E5%88%9D%E5%A7%8B%E5%8C%96">if-switch语句初始化</a></li>
<li><a href="#%E5%86%85%E8%81%94%E5%8F%98%E9%87%8F">内联变量</a></li>
<li><a href="#%E6%8A%98%E5%8F%A0%E8%A1%A8%E8%BE%BE%E5%BC%8F">折叠表达式</a></li>
<li><a href="#constexpr-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F">constexpr lambda表达式</a></li>
<li><a href="#namespace%E5%B5%8C%E5%A5%97">namespace嵌套</a></li>
<li><a href="#__has_include%E9%A2%84%E5%A4%84%E7%90%86%E8%A1%A8%E8%BE%BE%E5%BC%8F">__has_include预处理表达式</a></li>
<li><a href="#%E5%9C%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%94%A8this%E6%8D%95%E8%8E%B7%E5%AF%B9%E8%B1%A1%E5%89%AF%E6%9C%AC">在lambda表达式用*this捕获对象副本</a></li>
<li><a href="#%E6%96%B0%E5%A2%9Eattribute">新增Attribute</a></li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2">字符串转换</a></li>
<li><a href="#stdvariant">std::variant</a></li>
</ul>
</li>
<li><a href="#stdoptional">std::optional</a><ul>
<li><a href="#stdany">std::any</a></li>
<li><a href="#stdapply">std::apply</a></li>
<li><a href="#stdmake_from_tuple">std::make_from_tuple</a></li>
<li><a href="#stdstring_view">std::string_view</a></li>
<li><a href="#as_const">as_const</a></li>
<li><a href="#file_system">file_system</a></li>
<li><a href="#stdshared_mutex">std::shared_mutex</a></li>
</ul>
</li>
<li><a href="#c20-%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93">C++20 新增特性总结</a><ul>
<li><a href="#%E6%96%B0%E5%A2%9E%E5%85%B3%E9%94%AE%E5%AD%97keywords">新增关键字(keywords)</a></li>
<li><a href="#%E6%96%B0%E5%A2%9E%E6%A0%87%E8%AF%86%E7%AC%A6identifies">新增标识符(Identifies)</a></li>
<li><a href="#%E6%A8%A1%E5%9D%97modules">模块(Modules)</a><ul>
<li><a href="#%E4%BC%98%E7%82%B9">优点</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">创建模块</a></li>
<li><a href="#%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97">引用模块</a></li>
<li><a href="#import-%E5%A4%B4%E6%96%87%E4%BB%B6">import 头文件</a></li>
</ul>
</li>
<li><a href="#ranges">Ranges</a><ul>
<li><a href="#%E4%BE%8B%E5%AD%90">例子</a></li>
</ul>
</li>
<li><a href="#%E5%8D%8F%E7%A8%8Bcoroutines">协程(Coroutines)</a><ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B">什么是协程</a></li>
<li><a href="#%E4%BE%8B%E5%AD%90vc">例子(VC++)</a></li>
</ul>
</li>
<li><a href="#concepts">Concepts</a><ul>
<li><a href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89">如何定义</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8">使用</a></li>
<li><a href="#%E4%BE%8B%E5%AD%90-1">例子</a></li>
</ul>
</li>
<li><a href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%96%B0">Lambda 表达式的更新</a><ul>
<li><a href="#-this-%E9%9C%80%E8%A6%81%E6%98%BE%E5%BC%8F%E6%8D%95%E8%8E%B7this%E5%8F%98%E9%87%8F">[&#x3D;, this] 需要显式捕获<code>this</code>变量</a></li>
<li><a href="#%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%BC%8F%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">模板形式的 Lambda 表达式</a></li>
<li><a href="#lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%8D%95%E8%8E%B7%E6%94%AF%E6%8C%81%E6%89%93%E5%8C%85%E5%B1%95%E5%BC%80pack-expansion">Lambda 表达式捕获支持打包展开(Pack Expansion)</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8Fconstexpr-%E7%9A%84%E6%9B%B4%E6%96%B0">常量表达式(<code>constexpr</code>) 的更新</a><ul>
<li><a href="#constexpr-string--vector"><code>constexpr</code> string &amp; vector</a></li>
</ul>
</li>
<li><a href="#%E5%8E%9F%E5%AD%90atomic%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">原子(Atomic)智能指针</a><ul>
<li><a href="#%E4%BE%8B%E5%AD%90-2">例子</a></li>
</ul>
</li>
<li><a href="#%E8%87%AA%E5%8A%A8%E5%90%88%E6%B5%81joining-%E5%8F%AF%E4%B8%AD%E6%96%ADcancellable-%E7%9A%84%E7%BA%BF%E7%A8%8B">自动合流(Joining), 可中断(Cancellable) 的线程</a><ul>
<li><a href="#%E4%BE%8B%E5%AD%90-3">例子</a></li>
</ul>
</li>
<li><a href="#c20-%E5%90%8C%E6%AD%A5synchronization%E5%BA%93">C++20 同步(Synchronization)库</a><ul>
<li><a href="#stdatomic_ref">std::atomic_ref</a></li>
</ul>
</li>
<li><a href="#%E5%85%B6%E4%BB%96%E6%9B%B4%E6%96%B0">其他更新</a><ul>
<li><a href="#%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96designated-initializers">指定初始化(Designated Initializers)</a></li>
<li><a href="#%E8%88%AA%E5%A4%A9%E9%A3%9E%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%AC%A6-">航天飞机操作符 &lt;&#x3D;&gt;</a></li>
<li><a href="#%E8%8C%83%E5%9B%B4-for-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E6%94%AF%E6%8C%81%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AF%AD%E5%8F%A5">范围 for 循环语句支持初始化语句</a></li>
<li><a href="#%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%8F%82%E6%94%AF%E6%8C%81%E5%AD%97%E7%AC%A6%E4%B8%B2">非类型模板形参支持字符串</a></li>
<li><a href="#likely-unlikely">[[likely]], [[unlikely]]</a></li>
<li><a href="#%E6%97%A5%E5%8E%86calendar%E5%92%8C%E6%97%B6%E5%8C%BAtimezone%E5%8A%9F%E8%83%BD">日历(Calendar)和时区(Timezone)功能</a></li>
<li><a href="#stdspan">std::span</a></li>
<li><a href="#%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E5%AE%8F">特性测试宏</a></li>
<li><a href="#"></a></li>
<li><a href="#consteval-%E5%87%BD%E6%95%B0"><code>consteval</code> 函数</a></li>
<li><a href="#constinit"><code>constinit</code></a></li>
<li><a href="#%E7%94%A8-using-%E5%BC%95%E7%94%A8-enum-%E7%B1%BB%E5%9E%8B">用 <code>using</code> 引用 <code>enum</code> 类型</a></li>
<li><a href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%BA%93stdformat">格式化库(<code>std::format</code>)</a></li>
<li><a href="#%E5%A2%9E%E5%8A%A0%E6%95%B0%E5%AD%A6%E5%B8%B8%E9%87%8F">增加数学常量</a></li>
<li><a href="#stdsource_location">std::source_location</a></li>
<li><a href="#nodiscardreason">[[nodiscard(reason)]]</a></li>
<li><a href="#%E4%BD%8D%E8%BF%90%E7%AE%97">位运算</a></li>
<li><a href="#%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%9B%B4%E6%96%B0">一些小更新</a></li>
<li><a href="#%E7%9B%AE%E5%BD%95">目录</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="C-11是什么，C-11标准的由来"><a href="#C-11是什么，C-11标准的由来" class="headerlink" title="C++ 11是什么，C++ 11标准的由来"></a>C++ 11是什么，C++ 11标准的由来</h3><p>C++ 这门编程语言的历史可以追溯至 1979 年，当时的 Bjarne Stroustrup（C++ 之父，后续简称 Stroustrup）还在使用 Simula 语言进行开发工作。</p>
<p>图 1 C++之父，Bjarne Stroustrup</p>
<p>Simula 语言被认为是第一个面向对象的编程语言。Stroustrup 也非常赞赏 Simula 语言的这种特性，但由于实例开发中 Simula 语言的执行效率太低，所以此后不久，Stroustrup 开始从事“带类的C”编程语言的开发工作。</p>
<blockquote>
<p>注意在开发初期，并没有 C++ 这个称谓。所谓“带类的C”，顾名思义就是在 C 语言的基础上，为其加入面向对象的思想（扩增一些写好的类和对象）。初期的 C++ 除了具备 C 语言的所有功能外，还具有类、基本继承、内联函数、默认函数参数以及强类型检查等简单功能。</p>
</blockquote>
<p>不仅如此，Stroustrup 还在 CPre（C语言编译器）的基础上，专门为“带类的C”开发了一个编译器，称为 Cfront，它可以将带有类的 C 代码自动转换为普通 C 语言程序。值得一提的是在 1993 年，Cfront 因难以支持 C++ 异常机制被弃用。</p>
<p>1983 年，“带类的C”正式被称为“C++”，其中“++”就取自 C 语言中的“++”运算符，这也从侧面表明了 Stroustrup 对于 C++ 这门编程语言的定位。 与此同时，C++还增添了很多功能，比如虚函数、函数重载、引用、const 关键字以及 &#x2F;&#x2F; 注释符号等。</p>
<blockquote>
<p>在随后的几年时间里，C++ 得到了快速地发展。比如说， C++ 不断地被更新，类中增加了受保护成员（protected）和私有成员（private），并允许使用多继承等；Stroustrup 出版了 《带注释的C++参考手册》一书，其一度被当做 C++ 开发的重要参考；Borland 发布了 Turbo C ++编译器，该编译器包含有大量的第三方 C++ 库，极大便利了 C ++ 的开发，等等。</p>
</blockquote>
<p>直到 1998 年，C++ 标准委员会发布了第一版 C++ 标准，并将其命名为 C++ 98 标准。据不知名人士透露，《带注释的C++参考手册》这本书对 C++ 98 标准的制定产生了很大的影响。</p>
<p>经过作者的不断迭代，一本书往往会先后发布很多个版本，其中每个新版本都是对前一个版本的修正和更新。C++ 编程语言的发展也是如此。截止到目前（2020 年），C++ 的发展历经了以下 3 个个标准：</p>
<ul>
<li>[?] #check dd</li>
</ul>
<ul>
<li>2011 年，新的 C++ 11 标准诞生，用于取代 C++ 98 标准。此标准还有一个别名，为“C++ 0x”；</li>
<li>2014 年，C++ 14 标准发布，该标准库对 C++ 11 标准库做了更优的修改和更新；</li>
<li>2017 年底，C++ 17 标准正式颁布。</li>
</ul>
<blockquote>
<p>所谓标准，即明确 C++ 代码的编写规范，所有的 C++ 程序员都应遵守此标准。</p>
</blockquote>
<p>值得一提的是在 C++ 11 标准之前，C++ 标准委员会还在 2003 年对 C++ 98 标准做了一次修改（称为 C++ 03 标准），但由于其仅仅修复了一些 C++ 98 标准中存在的漏洞，并未修改核心语法，因此人们习惯将这次修订和 C++ 98 合称为 C++98&#x2F;03 标准。</p>
<p>以上 3 个标准中，相比对前一个版本的修改和更新程度，C++ 11 标准无疑是颠覆性的，该标准在 C++ 98 的基础上修正了约 600 个 C++ 语言中存在的缺陷，同时添加了约 140 个新特性，这些更新使得 C++ 语言焕然一新。读者可以这样理解 C++ 11 标准，它在 C++ 98&#x2F;03 标准的基础上孕育出了全新的 C++ 编程语言，造就了 C++ 新的开始。</p>
<p>那么，C++ 11 标准到底包含哪些新特性呢？别急，接下来会分篇给大家做详细地讲解。</p>
<h3 id="C-auto类型推导完全攻略"><a href="#C-auto类型推导完全攻略" class="headerlink" title="C++ auto类型推导完全攻略"></a>C++ auto类型推导完全攻略</h3><p>在 <a href="http://c.biancheng.net/cplus/">C++</a>11 之前的版本（C++98 和 C++ 03）中，定义变量或者声明变量之前都必须指明它的类型，比如 int、char 等；但是在一些比较灵活的语言中，比如 <a href="http://c.biancheng.net/csharp/">C#</a>、<a href="http://c.biancheng.net/js/">JavaScript</a>、<a href="http://c.biancheng.net/php/">PHP</a>、<a href="http://c.biancheng.net/python/">Python</a> 等，程序员在定义变量时可以不指明具体的类型，而是让编译器（或者解释器）自己去推导，这就让代码的编写更加方便。</p>
<p>C++11 为了顺应这种趋势也开始支持自动类型推导了！C++11 使用 <strong>auto</strong> 关键字来支持自动类型推导。</p>
<h4 id="auto-类型推导的语法和规则"><a href="#auto-类型推导的语法和规则" class="headerlink" title="auto 类型推导的语法和规则"></a>auto 类型推导的语法和规则</h4><p>在之前的 C++ 版本中，auto 关键字用来指明变量的存储类型，它和 static 关键字是相对的。auto 表示变量是自动存储的，这也是编译器的默认规则，所以写不写都一样，一般我们也不写，这使得 auto 关键字的存在变得非常鸡肋。</p>
<p>C++11 赋予 auto 关键字新的含义，使用它来做自动类型推导。也就是说，使用了 auto 关键字以后，编译器会在编译期间自动推导出变量的类型，这样我们就不用手动指明变量的数据类型了。</p>
<p>auto 关键字基本的使用语法如下：</p>
<p>auto name &#x3D; value;</p>
<p>name 是变量的名字，value 是变量的初始值。</p>
<p>注意：auto 仅仅是一个占位符，在编译器期间它会被真正的类型所替代。或者说，C++ 中的变量必须是有明确类型的，只是这个类型是由编译器自己推导出来的。</p>
<p>auto 类型推导的简单例子：</p>
<p>auto n &#x3D; 10;<br>auto f &#x3D; 12.8;<br>auto p &#x3D; &n;<br>auto url &#x3D; “<a href="http://c.biancheng.net/cplus/%E2%80%9D">http://c.biancheng.net/cplus/”</a>;</p>
<p>下面我们来解释一下：</p>
<ul>
<li>第 1 行中，10 是一个整数，默认是 int 类型，所以推导出变量 n 的类型是 int。</li>
<li>第 2 行中，12.8 是一个小数，默认是 double 类型，所以推导出变量 f 的类型是 double。</li>
<li>第 3 行中，&amp;n 的结果是一个 int* 类型的指针，所以推导出变量 p 的类型是 int*。</li>
<li>第 4 行中，由双引号<code>&quot;&quot;</code>包围起来的字符串是 const char* 类型，所以推导出变量 url 的类型是 const char*，也即一个常量指针。</li>
</ul>
<p>我们也可以连续定义多个变量：</p>
<p>int n &#x3D; 20;<br>auto *p &#x3D; &amp;n, m &#x3D; 99;</p>
<p>先看前面的第一个子表达式，&amp;n 的类型是 int*，编译器会根据 auto *p 推导出 auto 为 int。后面的 m 变量自然也为 int 类型，所以把 99 赋值给它也是正确的。</p>
<p>这里我们要注意，推导的时候不能有二义性。在本例中，编译器根据第一个子表达式已经推导出 auto 为 int 类型，那么后面的 m 也只能是 int 类型，如果写作<code>m=12.5</code>就是错误的，因为 12.5 是double 类型，这和 int 是冲突的。</p>
<p>还有一个值得注意的地方是：使用 auto 类型推导的变量必须马上初始化，这个很容易理解，因为 auto 在 C++11 中只是“占位符”，并非如 int 一样的真正的类型声明。</p>
<h4 id="auto-的高级用法"><a href="#auto-的高级用法" class="headerlink" title="auto 的高级用法"></a>auto 的高级用法</h4><p>auto 除了可以独立使用，还可以和某些具体类型混合使用，这样 auto 表示的就是“半个”类型，而不是完整的类型。请看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> *p1 = &amp;x;   <span class="comment">//p1 为 int *，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span>  p2 = &amp;x;   <span class="comment">//p2 为 int*，auto 推导为 int*</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r1  = x;   <span class="comment">//r1 为 int&amp;，auto 推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> r2 = r1;    <span class="comment">//r2 为  int，auto 推导为 int</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>下面我们来解释一下：</p>
<ul>
<li>第 2 行代码中，p1 为 int* 类型，也即 auto * 为 int *，所以 auto 被推导成了 int 类型。</li>
<li>第 3 行代码中，auto 被推导为 int* 类型，前边的例子也已经演示过了。</li>
<li>第 4 行代码中，r1 为 int &amp; 类型，auto 被推导为 int 类型。</li>
<li>第 5 行代码是需要重点说明的，r1 本来是 int&amp; 类型，但是 auto 却被推导为 int 类型，这表明当<code>=</code>右边的表达式是一个引用类型时，auto 会把引用抛弃，直接推导出它的原始类型。</li>
</ul>
<ul>
<li>[?] #check</li>
</ul>
<p>接下来，我们再来看一下 auto 和 const 的结合：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>  x = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span>  <span class="keyword">auto</span> n = x;  <span class="comment">//n 为 const int ，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> f = n;      <span class="comment">//f 为 const int，auto 被推导为 int（const 属性被抛弃）</span></span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> &amp;r1 = x;  <span class="comment">//r1 为 const int&amp; 类型，auto 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;r2 = r1;  <span class="comment">//r1 为 const int&amp; 类型，auto 被推导为 const int 类型`在这里插入代码片`</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>下面我们来解释一下：</p>
<ul>
<li>第 2 行代码中，n 为 const int，auto 被推导为 int。</li>
<li>第 3 行代码中，n 为 const int 类型，但是 auto 却被推导为 int 类型，这说明当<code>=</code>右边的表达式带有 const 属性时， auto 不会使用 const 属性，而是直接推导出 non-const 类型。</li>
<li>第 4 行代码中，auto 被推导为 int 类型，这个很容易理解，不再赘述。</li>
<li>第 5 行代码中，r1 是 const int &amp; 类型，auto 也被推导为 const int 类型，这说明当 const 和引用结合时，auto 的推导将保留表达式的 const 类型。</li>
</ul>
<p>最后我们来简单总结一下 auto 与 const 结合的用法：</p>
<ul>
<li>当类型不为引用时，auto 的推导结果将不保留表达式的 const 属性；</li>
<li>当类型为引用时，auto 的推导结果将保留表达式的 const 属性。</li>
</ul>
<h4 id="auto-的限制"><a href="#auto-的限制" class="headerlink" title="auto 的限制"></a>auto 的限制</h4><p>前面介绍推导规则的时候我们说过，使用 auto 的时候必须对变量进行初始化，这是 auto 的限制之一。那么，除此以外，auto 还有哪些其它的限制呢？</p>
<ul>
<li>[?] #check</li>
</ul>
<ol>
<li>auto 不能在函数的参数中使用。</li>
</ol>
<p>这个应该很容易理解，我们在定义函数的时候只是对参数进行了声明，指明了参数的类型，但并没有给它赋值，只有在实际调用函数的时候才会给参数赋值；而 auto 要求必须对变量进行初始化，所以这是矛盾的。</p>
<ol start="2">
<li><p>auto 不能作用于类的非静态成员变量（也就是没有 static 关键字修饰的成员变量）中。</p>
</li>
<li><p>auto 关键字不能定义数组，比如下面的例子就是错误的：</p>
</li>
</ol>
<p>char url[] &#x3D; “<a href="http://c.biancheng.net/%E2%80%9D">http://c.biancheng.net/”</a>;<br>auto str[] &#x3D; url; &#x2F;&#x2F;arr 为数组，所以不能使用 auto</p>
<ol start="4">
<li>auto 不能作用于模板参数，请看下面的例子：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A&lt;<span class="type">int</span>&gt; C1;</span><br><span class="line">    A&lt;<span class="keyword">auto</span>&gt; C2 = C1;  <span class="comment">//错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<h4 id="auto-的应用"><a href="#auto-的应用" class="headerlink" title="auto 的应用"></a>auto 的应用</h4><p>说了那么多 auto 的推导规则和一些注意事项，那么 auto 在实际开发中到底有什么应用呢？下面我们列举两个典型的应用场景。</p>
<h4 id="使用-auto-定义迭代器"><a href="#使用-auto-定义迭代器" class="headerlink" title="使用 auto 定义迭代器"></a>使用 auto 定义迭代器</h4><p>auto 的一个典型应用场景是用来定义 stl 的迭代器。</p>
<p>我们在使用 stl 容器的时候，需要使用迭代器来遍历容器里面的元素；不同容器的迭代器有不同的类型，在定义迭代器时必须指明。而迭代器的类型有时候比较复杂，书写起来很麻烦，请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt;::iterator i = v.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>可以看出来，定义迭代器 i 的时候，类型书写比较冗长，容易出错。然而有了 auto 类型推导，我们大可不必这样，只写一个 auto 即可。</p>
<p>修改上面的代码，使之变得更加简洁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="type">int</span>&gt; &gt; v;</span><br><span class="line">    <span class="keyword">auto</span> i = v.<span class="built_in">begin</span>();  <span class="comment">//使用 auto 代替具体的类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>auto 可以根据表达式 v.begin() 的类型（begin() 函数的返回值类型）来推导出变量 i 的类型。</p>
<h4 id="auto-用于泛型编程"><a href="#auto-用于泛型编程" class="headerlink" title="auto 用于泛型编程"></a>auto 用于<a href="https://so.csdn.net/so/search?q=%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B&spm=1001.2101.3001.7020">泛型编程</a></h4><p>auto 的另一个应用就是当我们不知道变量是什么类型，或者不希望指明具体类型的时候，比如泛型编程中。我们接着看例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> val = T::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>&lt;A&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;B&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p>100<br><a href="http://c.biancheng.net/cplus/">http://c.biancheng.net/cplus/</a></p>
<p>本例中的模板函数 func() 会调用所有类的静态函数 get()，并对它的返回值做统一处理，但是 get() 的返回值类型并不一样，而且不能自动转换。这种要求在以前的 C++ 版本中实现起来非常的麻烦，需要额外增加一个模板参数，并在调用时手动给该模板参数赋值，用以指明变量 val 的类型。</p>
<p>但是有了 auto 类型自动推导，编译器就根据 get() 的返回值自己推导出 val 变量的类型，就不用再增加一个模板参数了。</p>
<p>下面的代码演示了不使用 auto 的解决办法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">get</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;  <span class="comment">//额外增加一个模板参数 T2</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    T2 val = T1::<span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="comment">//调用时也要手动给模板参数赋值</span></span><br><span class="line">    <span class="built_in">func</span>&lt;A, <span class="type">int</span>&gt;();</span><br><span class="line">    <span class="built_in">func</span>&lt;B, <span class="type">const</span> <span class="type">char</span>*&gt;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>

<h2 id="C-decltype类型推导完全攻略"><a href="#C-decltype类型推导完全攻略" class="headerlink" title="C++ decltype类型推导完全攻略"></a>C++ decltype类型推导完全攻略</h2><p>decltype 是 <a href="http://c.biancheng.net/cplus/">C++</a>11 新增的一个关键字，它和 auto 的功能一样，都用来在编译时期进行自动类型推导。不了解 auto 用法的读者请转到《<a href="http://c.biancheng.net/view/6984.html">C++ auto</a>》。</p>
<p>decltype 是“declare type”的缩写，译为“声明类型”。</p>
<p>既然已经有了 auto 关键字，为什么还需要 decltype 关键字呢？因为 auto 并不适用于所有的自动类型推导场景，在某些特殊情况下 auto 用起来非常不方便，甚至压根无法使用，所以 decltype 关键字也被引入到 C++11 中。</p>
<p>auto 和 decltype 关键字都可以自动推导出变量的类型，但它们的用法是有区别的：</p>
<p>auto varname &#x3D; value;<br>decltype(exp) varname &#x3D; value;</p>
<p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式。</p>
<p>auto 根据<code>=</code>右边的初始值 value 推导出变量的类型，而 decltype 根据 exp 表达式推导出变量的类型，跟<code>=</code>右边的 value 没有关系。</p>
<p>另外，auto 要求变量必须初始化，而 decltype 不要求。这很容易理解，auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。decltype 可以写成下面的形式：</p>
<p>decltype(exp) varname;</p>
<h3 id="exp-注意事项"><a href="#exp-注意事项" class="headerlink" title="exp 注意事项"></a>exp 注意事项</h3><p>原则上讲，exp 就是一个普通的表达式，它可以是任意复杂的形式，但是我们必须要保证 exp 的结果是有类型的，不能是 void；例如，当 exp 调用一个返回值类型为 void 的函数时，exp 的结果也是 void 类型，此时就会导致编译错误。</p>
<p>C++ decltype 用法举例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) b = <span class="number">1</span>;  <span class="comment">//b 被推导成了 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10.8</span>) x = <span class="number">5.5</span>;  <span class="comment">//x 被推导成了 double</span></span><br><span class="line"><span class="keyword">decltype</span>(x + <span class="number">100</span>) y;  <span class="comment">//y 被推导成了 double</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>可以看到，decltype 能够根据变量、字面量、带有运算符的表达式推导出变量的类型。读者请留意第 4 行，y 没有被初始化。</p>
<h2 id="decltype-推导规则"><a href="#decltype-推导规则" class="headerlink" title="decltype 推导规则"></a>decltype 推导规则</h2><p>上面的例子让我们初步感受了一下 decltype 的用法，但你不要认为 decltype 就这么简单，它的玩法实际上可以非常复杂。当程序员使用 decltype(exp) 获取类型时，编译器将根据以下三条规则得出结果：</p>
<ul>
<li>如果 exp 是一个不被括号<code>( )</code>包围的表达式，或者是一个类成员访问表达式，或者是一个单独的变量，那么 decltype(exp) 的类型就和 exp 一致，这是最普遍最常见的情况。</li>
<li>如果 exp 是函数调用，那么 decltype(exp) 的类型就和函数返回值的类型一致。</li>
<li>如果 exp 是一个左值，或者被括号<code>( )</code>包围，那么 decltype(exp) 的类型就是 exp 的引用；假设 exp 的类型为 T，那么 decltype(exp) 的类型就是 T&amp;。</li>
</ul>
<p>为了更好地理解 decltype 的推导规则，下面来看几个实际的例子。</p>
<p>【实例1】exp 是一个普通表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> total;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> scores;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Student::total = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span>  <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp;r = n;</span><br><span class="line">    Student stu;</span><br><span class="line">    <span class="keyword">decltype</span>(n) a = n;  <span class="comment">//n 为 int 类型，a 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(r) b = n;     <span class="comment">//r 为 const int&amp; 类型, b 被推导为 const int&amp; 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(Student::total) c = <span class="number">0</span>;  <span class="comment">//total 为类 Student 的一个 int 类型的成员变量，c 被推导为 int 类型</span></span><br><span class="line">    <span class="keyword">decltype</span>(stu.name) url = <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;  <span class="comment">//total 为类 Student 的一个 string 类型的成员变量， url 被推导为 string 类型</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<p>这段代码很简单，按照推导规则 1，对于一般的表达式，decltype 的推导结果就和这个表达式的类型一致。</p>
<p>【实例2】exp 为函数调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">/函数声明</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">func_int_r</span><span class="params">(<span class="type">int</span>, <span class="type">char</span>)</span></span>;  <span class="comment">//返回值为 int&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp;&amp; <span class="title">func_int_rr</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">//返回值为 int&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func_int</span><span class="params">(<span class="type">double</span>)</span></span>;  <span class="comment">//返回值为 int</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp; <span class="title">fun_cint_r</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;</span></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span>&amp;&amp; <span class="title">func_cint_rr</span><span class="params">(<span class="type">void</span>)</span></span>;  <span class="comment">//返回值为 const int&amp;&amp;</span></span><br><span class="line"><span class="comment">//decltype类型推导</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_r</span>(<span class="number">100</span>, <span class="string">&#x27;A&#x27;</span>)) a = n;  <span class="comment">//a 的类型为 int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int_rr</span>()) b = <span class="number">0</span>;  <span class="comment">//b 的类型为 int&amp;&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_int</span>(<span class="number">10.5</span>)) c = <span class="number">0</span>;   <span class="comment">//c 的类型为 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">fun_cint_r</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))  x = n;    <span class="comment">//x 的类型为 const int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">func_cint_rr</span>()) y = <span class="number">0</span>;  <span class="comment">// y 的类型为 const int&amp;&amp;</span></span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，exp 中调用函数时需要带上括号和参数，但这仅仅是形式，并不会真的去执行函数代码。</p>
<p>【实例3】exp 是左值，或者被<code>( )</code>包围：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> Base obj;</span><br><span class="line">    <span class="comment">//带有括号的表达式</span></span><br><span class="line">    <span class="keyword">decltype</span>(obj.x) a = <span class="number">0</span>;  <span class="comment">//obj.x 为类的成员访问表达式，符合推导规则一，a 的类型为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>((obj.x)) b = a;  <span class="comment">//obj.x 带有括号，符合推导规则三，b 的类型为 int&amp;。</span></span><br><span class="line">    <span class="comment">//加法表达式</span></span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">decltype</span>(n + m) c = <span class="number">0</span>;  <span class="comment">//n+m 得到一个右值，符合推导规则一，所以推导结果为 int</span></span><br><span class="line">    <span class="keyword">decltype</span>(n = n + m) d = c;  <span class="comment">//n=n+m 得到一个左值，符号推导规则三，所以推导结果为 int&amp;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<ul>
<li>[?]  #check<br>这里我们需要重点说一下左值和右值：左值是指那些在表达式执行结束后依然存在的数据，也就是持久性的数据；右值是指那些在表达式执行结束后不再存在的数据，也就是临时性的数据。有一种很简单的方法来区分左值和右值，对表达式取地址，如果编译器不报错就为左值，否则为右值。</li>
</ul>
<h2 id="decltype-的实际应用"><a href="#decltype-的实际应用" class="headerlink" title="decltype 的实际应用"></a>decltype 的实际应用</h2><p>auto 的语法格式比 decltype 简单，所以在一般的类型推导中，使用 auto 比使用 decltype 更加方便，你可以转到《<a href="http://c.biancheng.net/view/6984.html">C++ auto</a>》查看很多类似的例子，本节仅演示只能使用 decltype 的情形。</p>
<p>我们知道，auto 只能用于类的静态成员，不能用于类的非静态成员（普通成员），如果我们想推导非静态成员的类型，这个时候就必须使用 decltype 了。下面是一个模板的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typename</span> T::iterator m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    Base&lt;<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&gt; obj;</span><br><span class="line">    obj.<span class="built_in">func</span>(v);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>单独看 Base 类中 m_it 成员的定义，很难看出会有什么错误，但在使用 Base 类的时候，如果传入一个 const 类型的容器，编译器马上就会弹出一大堆错误信息。原因就在于，<code>T::iterator</code>并不能包括所有的迭代器类型，当 T 是一个 const 容器时，应当使用 const_iterator。</p>
<p>要想解决这个问题，在之前的 C++98&#x2F;03 版本下只能想办法把 const 类型的容器用模板特化单独处理，增加了不少工作量，看起来也非常晦涩。但是有了 C++11 的 decltype 关键字，就可以直接这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(T&amp; container)</span> </span>&#123;</span><br><span class="line">        m_it = container.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">decltype</span>(<span class="built_in">T</span>().<span class="built_in">begin</span>()) m_it;  <span class="comment">//注意这里</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>看起来是不是很清爽？</p>
<p>注意，有些低版本的编译器不支持<code>T().begin()</code>这种写法，以上代码我在 VS2019 下测试通过，在 VS2015 下测试失败。</p>
<h2 id="汇总auto和decltype的区别"><a href="#汇总auto和decltype的区别" class="headerlink" title="汇总auto和decltype的区别"></a>汇总auto和decltype的区别</h2><p>通过《<a href="http://c.biancheng.net/view/6984.html">C++ auto</a>》和《<a href="http://c.biancheng.net/view/7151.html">C++ decltype</a>》两节的学习，相信大家已经掌握了 auto 和 decltype 的语法规则以及使用场景，这节我们将 auto 和 decltype 放在一起，综合对比一下它们的区别，并告诉大家该如何选择。</p>
<h3 id="语法格式的区别"><a href="#语法格式的区别" class="headerlink" title="语法格式的区别"></a>语法格式的区别</h3><p>auto 和 decltype 都是 C++11 新增的关键字，都用于自动类型推导，但是它们的语法格式是有区别的，如下所示：</p>
<p>auto varname &#x3D; value; &#x2F;&#x2F;auto的语法格式<br>decltype(exp) varname [&#x3D; value]; &#x2F;&#x2F;decltype的语法格式</p>
<p>其中，varname 表示变量名，value 表示赋给变量的值，exp 表示一个表达式，方括号<code>[ ]</code>表示可有可无。</p>
<p>auto 和 decltype 都会自动推导出变量 varname 的类型：</p>
<ul>
<li>auto 根据<code>=</code>右边的初始值 value 推导出变量的类型；</li>
<li>decltype 根据 exp 表达式推导出变量的类型，跟<code>=</code>右边的 value 没有关系。</li>
</ul>
<p>另外，auto 要求变量必须初始化，也就是在定义变量的同时必须给它赋值；而 decltype 不要求，初始化与否都不影响变量的类型。这很容易理解，因为 auto 是根据变量的初始值来推导出变量类型的，如果不初始化，变量的类型也就无法推导了。</p>
<p>auto 将变量的类型和初始值绑定在一起，而 decltype 将变量的类型和初始值分开；虽然 auto 的书写更加简洁，但 decltype 的使用更加灵活。</p>
<p>请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> n1 = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="number">10</span>) n2 = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">auto</span> url1 = <span class="string">&quot;http://c.biancheng.net/cplus/&quot;</span>;</span><br><span class="line"><span class="keyword">decltype</span>(url1) url2 = <span class="string">&quot;http://c.biancheng.net/java/&quot;</span>;</span><br><span class="line"><span class="keyword">auto</span> f1 = <span class="number">2.5</span>;</span><br><span class="line"><span class="keyword">decltype</span>(n1*<span class="number">6.7</span>) f2;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>这些用法在前面的两节中已经进行了分析，此处就不再赘述了。</p>
<h3 id="对-cv-限定符的处理"><a href="#对-cv-限定符的处理" class="headerlink" title="对 cv 限定符的处理"></a>对 cv 限定符的处理</h3><p>「cv 限定符」是 const 和 volatile 关键字的统称：</p>
<ul>
<li>const 关键字用来表示数据是只读的，也就是不能被修改；</li>
<li>volatile 和 const 是相反的，它用来表示数据是可变的、易变的，目的是不让 CPU 将数据缓存到寄存器，而是从原始的内存中读取。</li>
</ul>
<p>在推导变量类型时，auto 和 decltype 对 cv 限制符的处理是不一样的。decltype 会保留 cv 限定符，而 auto 有可能会去掉 cv 限定符。</p>
<p>以下是 auto 关键字对 cv 限定符的推导规则：</p>
<ul>
<li>如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。</li>
<li>如果表达式的类型是指针或者引用，auto 将保留 cv 限定符。</li>
</ul>
<p>下面的例子演示了对 const 限定符的推导：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//非指针非引用类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> n2 = <span class="number">10</span>;</span><br><span class="line">n2 = <span class="number">99</span>;  <span class="comment">//赋值不报错</span></span><br><span class="line"><span class="keyword">decltype</span>(n1) n3 = <span class="number">20</span>;</span><br><span class="line">n3 = <span class="number">5</span>;  <span class="comment">//赋值报错</span></span><br><span class="line"><span class="comment">//指针类型</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *p1 = &amp;n1;</span><br><span class="line"><span class="keyword">auto</span> p2 = p1;</span><br><span class="line">*p2 = <span class="number">66</span>;  <span class="comment">//赋值报错</span></span><br><span class="line"><span class="keyword">decltype</span>(p1) p3 = p1;</span><br><span class="line">*p3 = <span class="number">19</span>;  <span class="comment">//赋值报错</span></span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>在 C++ 中无法将一个变量的完整类型输出，我们通过对变量赋值来判断它是否被 const 修饰；如果被 const 修饰那么赋值失败，如果不被 const 修饰那么赋值成功。虽然这种方案不太直观，但也是能达到目的的。</p>
<p>n2 赋值成功，说明不带 const，也就是 const 被 auto 抛弃了，这验证了 auto 的第一条推导规则。p2 赋值失败，说明是带 const 的，也就是 const 没有被 auto 抛弃，这验证了 auto 的第二条推导规则。</p>
<p>n3 和 p3 都赋值失败，说明 decltype 不会去掉表达式的 const 属性。</p>
<h3 id="对引用的处理"><a href="#对引用的处理" class="headerlink" title="对引用的处理"></a>对引用的处理</h3><p>当表达式的类型为引用时，auto 和 decltype 的推导规则也不一样；decltype 会保留引用类型，而 auto 会抛弃引用类型，直接推导出它的原始类型。请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;r1 = n;</span><br><span class="line">    <span class="comment">//auto推导</span></span><br><span class="line">    <span class="keyword">auto</span> r2 = r1;</span><br><span class="line">    r2 = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//decltype推导</span></span><br><span class="line">    <span class="keyword">decltype</span>(r1) r3 = n;</span><br><span class="line">    r3 = <span class="number">99</span>;</span><br><span class="line">    cout &lt;&lt; n &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r1 &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; r3 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>运行结果：<br>10, 10, 20<br>99, 99, 99</p>
<p>从运行结果可以发现，给 r2 赋值并没有改变 n 的值，这说明 r2 没有指向 n，而是自立门户，单独拥有了一块内存，这就证明 r 不再是引用类型，它的引用类型被 auto 抛弃了。</p>
<p>给 r3 赋值，n 的值也跟着改变了，这说明 r3 仍然指向 n，它的引用类型被 decltype 保留了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>auto 虽然在书写格式上比 decltype 简单，但是它的推导规则复杂，有时候会改变表达式的原始类型；而 decltype 比较纯粹，它一般会坚持保留原始表达式的任何类型，让推导的结果更加原汁原味。</p>
<p>从代码是否健壮的角度考虑，我推荐使用 decltype，它没有那么多是非；但是 decltype 总是显得比较麻烦，尤其是当表达式比较复杂时，例如：</p>
<p>vector nums;<br>decltype(nums.begin()) it &#x3D; nums.begin();</p>
<p>而如果使用 auto 就会清爽很多：</p>
<p>vector nums;<br>auto it &#x3D; nums.begin();</p>
<p>在实际开发中人们仍然喜欢使用 auto 关键字（我也这么干），因为它用起来简单直观，更符合人们的审美。如果你的表达式类型不复杂，我还是推荐使用 auto 关键字，优雅的代码总是叫人赏心悦目，沉浸其中。</p>
<h2 id="C-返回值类型后置（跟踪返回值类型）"><a href="#C-返回值类型后置（跟踪返回值类型）" class="headerlink" title="C++返回值类型后置（跟踪返回值类型）"></a>C++返回值类型后置（跟踪返回值类型）</h2><p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型。考虑下面这个场景：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T t, U u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a = <span class="number">1</span>; <span class="type">float</span> b = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">auto</span> c = <span class="built_in">add</span>&lt;<span class="keyword">decltype</span>(a + b)&gt;(a, b);</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>我们并不关心 a+b 的类型是什么，因此，只需要通过 decltype(a+b) 直接得到返回值类型即可。但是像上面这样使用十分不方便，因为外部其实并不知道参数之间应该如何运算，只有 add 函数才知道返回值应当如何推导。</p>
<p>那么，在 add 函数的定义上能不能直接通过 decltype 拿到返回值呢？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(t + u) <span class="built_in">add</span>(T t, U u)  <span class="comment">// error: t、u尚未定义</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>当然，直接像上面这样写是编译不过的。因为 t、u 在参数列表中，而 <a href="http://c.biancheng.net/cplus/">C++</a> 的返回值是前置语法，在返回值定义的时候参数变量还不存在。</p>
<p>可行的写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">T</span>() + <span class="built_in">U</span>()) <span class="built_in">add</span>(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>考虑到 T、U 可能是没有无参构造函数的类，正确的写法应该是这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">decltype</span>((*(T*)<span class="number">0</span>) + (*(U*)<span class="number">0</span>)) <span class="built_in">add</span>(T t, U u)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>虽然成功地使用 decltype 完成了返回值的推导，但写法过于晦涩，会大大增加 decltype 在返回值类型推导上的使用难度并降低代码的可读性。</p>
<p>因此，在 C++11 中增加了**返回类型后置（trailing-return-type，又称跟踪返回类型）**语法，将 decltype 和 auto 结合起来完成返回值类型的推导。</p>
<p>返回类型后置语法是通过 auto 和 decltype 结合起来使用的。上面的 add 函数，使用新的语法可以写成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> -&gt; <span class="title">decltype</span><span class="params">(t + u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t + u;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>为了进一步说明这个语法，再看另一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo</span><span class="params">(<span class="type">int</span>&amp; i)</span></span>;</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">foo</span><span class="params">(<span class="type">float</span>&amp; f)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(T&amp; val)</span> -&gt; <span class="title">decltype</span><span class="params">(foo(val))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>如果说前一个例子中的 add 使用 C++98&#x2F;03 的返回值写法还勉强可以完成，那么这个例子对于 C++ 而言就是不可能完成的任务了。</p>
<p>在这个例子中，使用 decltype 结合返回值后置语法很容易推导出了 foo(val) 可能出现的返回值类型，并将其用到了 func 上。</p>
<p>返回值类型后置语法，是为了解决函数返回值类型依赖于参数而导致难以确定返回值类型的问题。有了这种语法以后，对返回值类型的推导就可以用清晰的方式（直接通过参数做运算）描述出来，而不需要像 C++98&#x2F;03 那样使用晦涩难懂的写法。</p>
<h2 id="C-11对模板实例化中连续右尖括号-的改进"><a href="#C-11对模板实例化中连续右尖括号-的改进" class="headerlink" title="C++11对模板实例化中连续右尖括号&gt;&gt;的改进"></a>C++11对模板实例化中连续右尖括号&gt;&gt;的改进</h2><p>在 C++98&#x2F;03 的泛型编程中，模板实例化有一个很烦琐的地方，那就是连续两个右尖括号（&gt;&gt;）会被编译器解释成右移操作符，而不是模板参数表的结束。</p>
<p>【实例】C++98&#x2F;03 中不支持连续两个右尖括号的示例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo&lt;A&lt;<span class="type">int</span>&gt;&gt;::type xx;  <span class="comment">//编译出错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>使用 gcc 编译时，会得到如下错误提示：</p>
<p>error: ‘&gt;&gt;’ should be ‘&gt;&gt;’ within a nested template argument list Foo<A>::type xx;</p>
<p>意思就是，<code>Foo&lt;A&lt;int&gt;&gt;</code>这种写法是不被支持的，要写成这样<code>Foo&lt;A&lt;int&gt; &gt;</code>（注意两个右尖括号之间的空格）。</p>
<p>这种限制无疑是很没有必要的。在 C++ 的各种成对括号中，目前只有右尖括号连续写两个会出现这种二义性。static_cast、reinterpret_cast 等 C++ 标准转换运算符，都是使用<code>&lt;&gt;</code>来获得待转换类型（type-id）的。若这个 type-id 本身是一个模板，用起来会很不方便。</p>
<p>现在在 C++11 中，这种限制终于被取消了。在 C++11 标准中，要求编译器对模板的右尖括号做单独处理，使编译器能够正确判断出<code>&gt;&gt;</code>是一个右移操作符还是模板参数表的结束标记（delimiter，界定符）。</p>
<p>不过这种自动化的处理在某些时候会与老标准不兼容，比如下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="type">int</span> N&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Foo&lt;<span class="number">100</span> &gt;&gt; <span class="number">2</span>&gt; xx;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>在 C++98&#x2F;03 的编译器中编译是没问题的，但 C++11 的编译器会显示：</p>
<p>error: expected unqualif?ied-id before ‘&gt;’ token Foo&lt;100 &gt;&gt; 2&gt; xx;</p>
<p>解决的方法是这样写：</p>
<p>Foo&lt;(100 &gt;&gt; 2)&gt; xx; &#x2F;&#x2F; 注意括号</p>
<p>这种加括号的写法其实也是一个良好的编程习惯，使得在书写时倾向于写出无二义性的代码。</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p>各种 C++98&#x2F;03 编译器除了支持标准（ISO&#x2F;IEC 14882：2003 及其之前的标准）之外，还自行做了不少的拓展。这些拓展中的一部分，后来经过了 C++ 委员会的斟酌和完善，进入了 C++11。</p>
<p>所以有一部分 C++11 的新特征，在一些 C++98&#x2F;03 的老编译器下也是可以支持的，只是由于没有标准化，无法保证各种平台&#x2F;编译器下的兼容性。比如像 Microsoft Visual C++2005 这种不支持 C++11 的编译器，在对模板右尖括号的处理上和现在的 C++11 是一致的。</p>
<h2 id="C-11使用using定义别名（替代typedef）"><a href="#C-11使用using定义别名（替代typedef）" class="headerlink" title="C++11使用using定义别名（替代typedef）"></a>C++11使用using定义别名（替代typedef）</h2><p>大家都知道，在 <a href="http://c.biancheng.net/cplus/">C++</a> 中可以通过 typedef 重定义一个类型：</p>
<p>typedef unsigned int uint_t;</p>
<p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。因此，下面这样将不是合法的函数重载：</p>
<p>void func(unsigned int);<br>void func(uint_t); &#x2F;&#x2F; error: redefinition</p>
<p>使用 typedef 重定义类型是很方便的，但它也有一些限制，比如，无法重定义一个模板。</p>
<p>想象下面这个场景：</p>
<p>typedef std::map&lt;std::string, int&gt; map_int_t;<br>&#x2F;&#x2F; …<br>typedef std::map&lt;std::string, std::string&gt; map_str_t;<br>&#x2F;&#x2F; …</p>
<p>我们需要的其实是一个固定以 std::string 为 key 的 map，它可以映射到 int 或另一个 std::string。然而这个简单的需求仅通过 typedef 却很难办到。</p>
<p>因此，在 C++98&#x2F;03 中往往不得不这样写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">str_map</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> std::map&lt;std::string, Val&gt; type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">str_map&lt;<span class="type">int</span>&gt;::type map1;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>一个虽然简单但却略显烦琐的 str_map 外敷类是必要的。这明显让我们在复用某些泛型代码时非常难受。</p>
<p>现在，在 C++11 中终于出现了可以重定义一个模板的语法。请看下面的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Val&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">str_map_t</span> = std::map&lt;std::string, Val&gt;;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="type">str_map_t</span>&lt;<span class="type">int</span>&gt; map1;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>这里使用新的 using 别名语法定义了 std::map 的模板别名 str_map_t。比起前面使用外敷模板加 typedef 构建的 str_map，它完全就像是一个新的 map 类模板，因此，简洁了很多。</p>
<p>实际上，using 的别名语法覆盖了 typedef 的全部功能。先来看看对普通类型的重定义示例，将这两种语法对比一下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重定义unsigned int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="type">uint_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">uint_t</span> = <span class="type">unsigned</span> <span class="type">int</span>;</span><br><span class="line"><span class="comment">// 重定义std::map</span></span><br><span class="line"><span class="keyword">typedef</span> std::map&lt;std::string, <span class="type">int</span>&gt; <span class="type">map_int_t</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="type">map_int_t</span> = std::map&lt;std::string, <span class="type">int</span>&gt;;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在重定义普通类型上，两种使用方法的效果是等价的，唯一不同的是定义语法。</p>
<p>typedef 的定义方法和变量的声明类似：像声明一个变量一样，声明一个重定义类型，之后在声明之前加上 typedef 即可。这种写法凸显了 C&#x2F;C++ 中的语法一致性，但有时却会增加代码的阅读难度。比如重定义一个函数指针时：</p>
<p>typedef void (*func_t)(int, int);</p>
<p>与之相比，using 后面总是立即跟随新标识符（Identifier），之后使用类似赋值的语法，把现有的类型（type-id）赋给新类型：</p>
<p>using func_t &#x3D; void (*)(int, int);</p>
<p>从上面的对比中可以发现，C++11 的 using 别名语法比 typedef 更加清晰。因为 typedef 的别名语法本质上类似一种解方程的思路。而 using 语法通过赋值来定义别名，和我们平时的思考方式一致。</p>
<p>下面再通过一个对比示例，看看新的 using 语法是如何定义模板别名的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* C++98/03 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">func_t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*type)</span><span class="params">(T, T)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt;::type xx_1;</span><br><span class="line"><span class="comment">/* C++11 */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> <span class="type">func_t</span> = <span class="built_in">void</span> (*)(T, T);</span><br><span class="line"><span class="comment">// 使用 func_t 模板</span></span><br><span class="line"><span class="type">func_t</span>&lt;<span class="type">int</span>&gt; xx_2;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>从示例中可以看出，通过 using 定义模板别名的语法，只是在普通类型别名语法的基础上增加 template 的参数列表。使用 using 可以轻松地创建一个新的模板别名，而不需要像 C++98&#x2F;03 那样使用烦琐的外敷模板。</p>
<p>需要注意的是，using 语法和 typedef 一样，并不会创造新的类型。也就是说，上面示例中 C++11 的 using 写法只是 typedef 的等价物。虽然 using 重定义的 func_t 是一个模板，但 func_t 定义的 xx_2 并不是一个由类模板实例化后的类，而是 void(*)(int, int) 的别名。</p>
<p>因此，下面这样写：</p>
<p>void foo(void (*func_call)(int, int));<br>void foo(func_t func_call); &#x2F;&#x2F; error: redefinition</p>
<p>同样是无法实现重载的，func_t 只是 void(*)(int, int) 类型的等价物。</p>
<p>细心的读者可以发现，using 重定义的 func_t 是一个模板，但它既不是类模板也不是函数模板（函数模板实例化后是一个函数），而是一种新的模板形式：模板别名（alias template）。</p>
<p>其实，通过 using 可以轻松定义任意类型的模板表达方式。比如下面这样：</p>
<p>template<br>using type_t &#x3D; T;<br>&#x2F;&#x2F; …<br>type_t i;</p>
<p>type_t 实例化后的类型和它的模板参数类型等价。这里，type_t 将等价于 int。</p>
<h2 id="C-11支持函数模板的默认模板参数"><a href="#C-11支持函数模板的默认模板参数" class="headerlink" title="C++11支持函数模板的默认模板参数"></a>C++11支持函数模板的默认模板参数</h2><p>在 <a href="http://c.biancheng.net/cplus/">C++</a>98&#x2F;03 标准中，类模板可以有默认的模板参数，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="type">int</span>, U N = <span class="number">0</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> Foo</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>但是却不支持函数的默认模板参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T = <span class="type">int</span>&gt;  <span class="comment">// error in C++98/03: default template arguments</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>现在这一限制在 C++11 中被解除了。上面的 func 函数在 C++11 中可以直接使用，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>();   <span class="comment">//T = int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>此时模板参数 T 的类型就为默认值 int。从上面的例子中可以看出，当所有模板参数都有默认参数时，函数模板的调用如同一个普通函数。但对于类模板而言，哪怕所有参数都有默认参数，在使用时也必须在模板名后跟随<code>&lt;&gt;</code>来实例化。</p>
<p>除了上面提到的部分之外，函数模板的默认模板参数在使用规则上和其他的默认参数也有一些不同，它没有必须写在参数表最后的限制。甚至于，根据实际场景中函数模板被调用的情形，编译器还可以自行推导出部分模板参数的类型。</p>
<p>这意味着，当默认模板参数和编译器自行推导出模板参数类型的能力一起结合使用时，代码的书写将变得异常灵活。我们可以指定函数中的一部分模板参数采用默认参数，而另一部分使用自动推导，比如下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> R = <span class="type">int</span>, <span class="keyword">typename</span> U&gt;</span><br><span class="line">R <span class="built_in">func</span>(U val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">97</span>);               <span class="comment">// R=int, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">char</span>&gt;(<span class="number">97</span>);         <span class="comment">// R=char, U=int</span></span><br><span class="line">    <span class="built_in">func</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">97</span>);  <span class="comment">// R=double, U=int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>C++11 标准中，我们可以像 func(97) 这样调用模板函数，因为编译器可以根据实参 97 自行推导出模板参数 U 的类型为 int，并且根据返回值 val&#x3D;97 推导出 R 的类型也为 int；而 func(97) 手动指定了模板参数 R 的类型为 char（默认模板参数将无效），并通过实参 97 推导出了 U &#x3D; int；最后 func&lt;double,int&gt;(97) 手动指定的 R 和 U 的类型值，因此无需编译器自行推导。</p>
<p>再次强调，当默认模板参数和自行推导的模板参数同时使用时，若无法推导出函数模板参数的类型，编译器会选择使用默认模板参数；如果模板参数即无法推导出来，又未设置其默认值，则编译器直接报错。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U = <span class="type">double</span>&gt;</span><br><span class="line"><span class="type">void</span> <span class="built_in">func</span>(T val1 = <span class="number">0</span>, U val2 = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="string">&#x27;c&#x27;</span>); <span class="comment">//T=char, U=double</span></span><br><span class="line">    <span class="built_in">func</span>();    <span class="comment">//编译报错</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>其中，func(‘c’) 的这种调用方式，编译器通过实参 ‘c’ 可以推导出 T&#x3D;char，但由于未传递第 2 个实参，因此模板参数 U 使用的是默认参数 double；但 func() 的调用方式是不行的，虽然 val1 设置有默认值，但编译器无法通过该默认值推导出模板参数 T 的类型。由此不难看出，编译器的自动推导能力并没有想象的那么强大。</p>
<p>总的来说，C++11 支持为函数模板中的参数设置默认值，在实际使用过程中，我们可以选择使用默认值，也可以尝试由编译器自行推导得到，还可以亲自指定各个模板参数的类型。</p>
<h2 id="C-11在函数模板和类模板中使用可变参数"><a href="#C-11在函数模板和类模板中使用可变参数" class="headerlink" title="C++11在函数模板和类模板中使用可变参数"></a>C++11在函数模板和类模板中使用可变参数</h2><p>所谓可变参数，指的是参数的个数和类型都可以是任意的。提到参数，大家会第一时间想到函数参数，除此之外 C++ 的模板（包括函数模板和类模板）也会用到参数。</p>
<p>对于函数参数而言，C++ 一直都支持为函数设置可变参数，最典型的代表就是 printf() 函数，它的语法格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int printf ( const char * format, ... );</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p><code>...</code>就表示的是可变参数，即 printf() 函数可以接收任意个参数，且各个参数的类型可以不同，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printf(&quot;%d&quot;, 10);printf(&quot;%d %c&quot;,10, &#x27;A&#x27;);printf(&quot;%d %c %f&quot;,10, &#x27;A&#x27;, 1.23);</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>我们通常将容纳多个参数的可变参数称为参数包。借助 format 字符串，printf() 函数可以轻松判断出参数包中的参数个数和类型。</p>
<p>下面的程序中，自定义了一个简单的可变参数函数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;#include &lt;cstdarg&gt;//可变参数的函数void vair_fun(int count, ...)&#123;    va_list args;    va_start(args, count);    for (int i = 0; i &lt; count; ++i)    &#123;        int arg = va_arg(args, int);        std::cout &lt;&lt; arg &lt;&lt; &quot; &quot;;    &#125;    va_end(args);&#125;int main()&#123;    //可变参数有 4 个，分别为 10、20、30、40    vair_fun(4, 10, 20, 30,40);    return 0;&#125;</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>程序中的 vair_fun() 函数有 2 个参数，一个是 count，另一个就是 … 可变参数。我们可以很容易在函数内部使用 count 参数，但要想使用参数包中的参数，需要借助<code>&lt;cstdarg&gt;</code>头文件中的 va_start、va_arg 以及 va_end 这 3 个带参数的宏：</p>
<ul>
<li>va_start(args, count)：args 是 va_list 类型的变量，我们可以简单的将其视为 char * 类型。借助 count 参数，找到可变参数的起始位置并赋值给 args；</li>
<li>va_arg(args, int)：调用 va_start 找到可变参数起始位置的前提下，通过指明参数类型为 int，va_arg 就可以将可变参数中的第一个参数返回；</li>
<li>va_end(args)：不再使用 args 变量后，应及时调用 va_end 宏清理 args 变量。</li>
</ul>
<blockquote>
<p>注意，借助 va_arg 获取参数包中的参数时，va_arg 不具备自行终止的能力，所以程序中借助 count 参数控制 va_arg 的执行次数，继而将所有的参数读取出来。控制 va_arg 执行次数还有其他方法，比如读取到指定数据时终止。</p>
</blockquote>
<p>使用 … 可变参数的过程中，需注意以下几点：</p>
<ol>
<li>… 可变参数必须作为函数的最后一个参数，且一个函数最多只能拥有 1 个可变参数。</li>
<li>可变参数的前面至少要有 1 个有名参数（例如上面例子中的 count 参数）；</li>
<li>当可变参数中包含 char 类型的参数时，va_arg 宏要以 int 类型的方式读取；当可变参数中包含 short 类型的参数时，va_arg 宏要以 double 类型的方式读取。</li>
</ol>
<p>需要注意的是，… 可变参数的方法仅适用于函数参数，并不适用于模板参数。C++11 标准中，提供了一种实现可变模板参数的方法。</p>
<h3 id="可变参数模板"><a href="#可变参数模板" class="headerlink" title="可变参数模板"></a>可变参数模板</h3><p>C++ 11 标准发布之前，函数模板和类模板只能设定固定数量的模板参数。C++11 标准对模板的功能进行了扩展，允许模板中包含任意数量的模板参数，这样的模板又称可变参数模板。</p>
<h4 id="1-可变参数函数模板"><a href="#1-可变参数函数模板" class="headerlink" title="1) 可变参数函数模板"></a>1) 可变参数函数模板</h4><p>先讲解函数模板，如下定义了一个可变参数的函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vair_fun</span><span class="params">(T...args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>模板参数中， typename（或者 class）后跟 … 就表明 T 是一个可变模板参数，它可以接收多种数据类型，又称模板参数包。vair_fun() 函数中，args 参数的类型用 T… 表示，表示 args 参数可以接收任意个参数，又称函数参数包。</p>
<p>这也就意味着，此函数模板最终实例化出的 vair_fun() 函数可以指定任意类型、任意数量的参数。例如，我们可以这样使用这个函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vair_fun</span>();</span><br><span class="line"><span class="built_in">vair_fun</span>(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">vair_fun</span>(<span class="number">1</span>, <span class="string">&quot;abc&quot;</span>, <span class="number">1.23</span>);</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>使用可变参数模板的难点在于，如何在模板函数内部“解开”参数包（使用包内的数据），这里给大家介绍两种简单的方法。</p>
<p>【递归方式解包】<br>先看一个实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//模板函数递归的出口</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vir_fun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vir_fun</span><span class="params">(T argc, args... argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; argc &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//开始递归，将第一个参数外的 argv 参数包重新传递给 vir_fun</span></span><br><span class="line">    <span class="built_in">vir_fun</span>(argv...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vir_fun</span>(<span class="number">1</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>, <span class="number">2.34</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>执行结果为：</p>
<p>1<br><a href="http://www.biancheng.net/">http://www.biancheng.net</a><br>2.34</p>
<p>分析一个程序的执行流程：</p>
<ul>
<li>首先，main() 函数调用 vir_fun() 模板函数时，根据所传实参的值，可以很轻易地判断出模板参数 T 的类型为 int，函数参数 argc 的值为 1，剩余的模板参数和函数参数都分别位于 args 和 argv 中；</li>
<li>vir_fun() 函数中，首先输出了 argc 的值（为 1），然后重复调用自身，同时将函数参数包 argv 中的数据作为实参传递给形参 argc 和 argv；</li>
<li>再次执行 vir_fun() 函数，此时模板参数 T 的类型为 char*，输出 argc 的值为 “http:<a href="http://www.biancheng.net”.再次调用自身,继续将/">www.biancheng.net”。再次调用自身，继续将</a> argv 包中的数据作为实参；</li>
<li>再次执行 vir_fun() 函数，此时模板参数 T 的类型为 double，输出 argc 的值为 2.34。再次调用自身，将空的 argv 包作为实参；</li>
<li>由于 argv 包没有数据，此时会调用无任何形参、函数体为空的 vir_fun() 函数，最终执行结束。</li>
</ul>
<blockquote>
<p>以递归方式解包，一定要设置递归结束的出口。例如本例中，无形参、函数体为空的 vir_fun() 函数就是递归结束的出口。</p>
</blockquote>
<p>【非递归方法解包】<br>借助逗号表达式和初始化列表，也可以解开参数包。</p>
<p>以 vir_fun() 函数为例，下面程序演示了非递归方法解包的过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dispaly</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; t &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... args&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">vir_fun</span><span class="params">(args... argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//逗号表达式+初始化列表</span></span><br><span class="line">    <span class="type">int</span> arr[] = &#123; (<span class="built_in">dispaly</span>(argv),<span class="number">0</span>)... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vir_fun</span>(<span class="number">1</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>, <span class="number">2.34</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>这里重点分析一下第 13 行代码，我们以<code>&#123; &#125;</code>初始化列表的方式对数组 arr 进行了初始化， (display(argv),0)… 会依次展开为 (display(1),0)、(display(“<a href="http://www.biancheng.net”),0/">http://www.biancheng.net”),0</a>) 和 (display(2.34),0)。也就是说，第 13 行代码和如下代码是等价的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"> <span class="type">int</span> arr[] = &#123; (<span class="built_in">dispaly</span>(<span class="number">1</span>),<span class="number">0</span>), (<span class="built_in">dispaly</span>(<span class="string">&quot;http://www.biancheng.net&quot;</span>),<span class="number">0</span>), (<span class="built_in">dispaly</span>(<span class="number">2.34</span>),<span class="number">0</span>) &#125;;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>可以看到，每个元素都是一个逗号表达式，以 (display(1), 0) 为例，它会先计算 display(1)，然后将 0 作为整个表达式的值返回给数组，因此 arr 数组最终存储的都是 0。arr 数组纯粹是为了将参数包展开，没有发挥其它作用。</p>
<h4 id="2-可变参数类模板"><a href="#2-可变参数类模板" class="headerlink" title="2) 可变参数类模板"></a>2) 可变参数类模板</h4><p>C++11 标准中，类模板中的模板参数也可以是一个可变参数。C++ 11 标准提供的 typle 元组类就是一个典型的可变参数模板类，它的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Types&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tuple</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>和固定模板参数的类不同，typle 模板类实例化时，可以接收任意数量、任意类型的模板参数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std:tuple&lt;&gt; tp0;</span><br><span class="line">std::tuple&lt;<span class="type">int</span>&gt; tp1 = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>);</span><br><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>&gt; tp2 = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.34</span>);</span><br><span class="line">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, string&gt; tp3 = std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.34</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>);</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>如下代码展示了一个支持可变参数的类模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//声明模板类demo</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Values&gt; <span class="keyword">class</span> <span class="title class_">demo</span>;</span><br><span class="line"><span class="comment">//继承式递归的出口</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="keyword">class</span> <span class="title class_">demo</span>&lt;&gt; &#123;&#125;;</span><br><span class="line"><span class="comment">//以继承的方式解包</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Head, <span class="keyword">typename</span>... Tail&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&lt;Head, Tail...&gt;</span><br><span class="line">    : <span class="keyword">private</span> demo&lt;Tail...&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(Head v, Tail... vtail) : <span class="built_in">m_head</span>(v), <span class="built_in">demo</span>&lt;Tail...&gt;(vtail...) &#123;</span><br><span class="line">        <span class="built_in">dis_head</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dis_head</span><span class="params">()</span> </span>&#123; std::cout &lt;&lt; m_head &lt;&lt; std::endl; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Head m_head;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo&lt;<span class="type">int</span>, <span class="type">float</span>, std::string&gt; <span class="title">t</span><span class="params">(<span class="number">1</span>, <span class="number">2.34</span>, <span class="string">&quot;http://www.biancheng.net&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<p>程序中，demo 模板参数中的 Tail 就是一个参数包，解包的方式是以“递归+继承”的方式实现的。具体来讲，demo&lt;Head, Tail…&gt; 类实例化时，由于其继承自 demo&lt;Tail…&gt; 类，因此父类也会实例化，一直递归至 Tail 参数包为空，此时会调用模板参数列表为空的 demo 模板类。</p>
<p>程序的输出结果为：</p>
<p><a href="http://www.biancheng.net/">http://www.biancheng.net</a><br>2.34<br>1</p>
<p>可变参数模板类还有其它的解包方法，这里不再一一赘述，感兴趣的读者可以自行做深入的研究。</p>
<h2 id="C-11-tuple元组详解"><a href="#C-11-tuple元组详解" class="headerlink" title="C++11 tuple元组详解"></a>C++11 tuple元组详解</h2><p>C++11 标准新引入了一种类模板，命名为 tuple（中文可直译为元组）。tuple 最大的特点是：实例化的对象可以存储任意数量、任意类型的数据。</p>
<p>tuple 的应用场景很广泛，例如当需要存储多个不同类型的元素时，可以使用 tuple；当函数需要返回多个数据时，可以将这些数据存储在 tuple 中，函数只需返回一个 tuple 对象即可。</p>
<p>本节，我们将给大家详细地讲解 tuple 的用法。</p>
<h3 id="tuple对象的创建"><a href="#tuple对象的创建" class="headerlink" title="tuple对象的创建"></a>tuple对象的创建</h3><p>tuple 本质是一个以可变模板参数定义的类模板，它定义在 头文件并位于 std 命名空间中。因此要想使用 tuple 类模板，程序中需要首先引入以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>实例化 tuple 模板类对象常用的方法有两种，一种是借助该类的构造函数，另一种是借助 make_tuple() 函数。</p>
<h4 id="1-类的构造函数"><a href="#1-类的构造函数" class="headerlink" title="1) 类的构造函数"></a>1) 类的构造函数</h4><p>tuple 模板类提供有很多构造函数，包括：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>) 默认构造函数</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="title">tuple</span><span class="params">()</span></span>;</span><br><span class="line"><span class="number">2</span>) 拷贝构造函数</span><br><span class="line"><span class="built_in">tuple</span> (<span class="type">const</span> tuple&amp; tpl);</span><br><span class="line"><span class="number">3</span>) 移动构造函数</span><br><span class="line"><span class="built_in">tuple</span> (tuple&amp;&amp; tpl);</span><br><span class="line"><span class="number">4</span>) 隐式类型转换构造函数</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> tuple&lt;UTypes...&gt;&amp; tpl); <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (tuple&lt;UTypes...&gt;&amp;&amp; tpl);      <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">5</span>) 支持初始化列表的构造函数</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(<span class="type">const</span> Types&amp;... elems)</span></span>;  <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span>... UTypes&gt;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">tuple</span> <span class="params">(UTypes&amp;&amp;... elems)</span></span>;  <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">6</span>) 将pair对象转换为tuple对象</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (<span class="type">const</span> pair&lt;U1,U2&gt;&amp; pr);       <span class="comment">//左值方式</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">U1</span>, <span class="keyword">class</span> <span class="title class_">U2</span>&gt;</span><br><span class="line">    <span class="built_in">tuple</span> (pair&lt;U1,U2&gt;&amp;&amp; pr);            <span class="comment">//右值方式</span></span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     <span class="comment">// std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span>        <span class="comment">// std::tuple</span></span></span><br><span class="line"><span class="keyword">using</span> std::tuple;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; first;                             <span class="comment">// 1)   first&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">second</span><span class="params">(first)</span></span>;                     <span class="comment">// 2)   second&#123;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">third</span><span class="params">(std::make_tuple(<span class="number">20</span>, <span class="string">&#x27;b&#x27;</span>))</span></span>;   <span class="comment">// 3)   third&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">long</span>, <span class="type">char</span>&gt; <span class="title">fourth</span><span class="params">(third)</span></span>;                    <span class="comment">// 4)的左值方式, fourth&#123;20,&#x27;b&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">fifth</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;                    <span class="comment">// 5)的右值方式, fifth&#123;10.&#x27;a&#x27;&#125;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">sixth</span><span class="params">(std::make_pair(<span class="number">30</span>, <span class="string">&#x27;c&#x27;</span>))</span></span>;    <span class="comment">// 6)的右值方式, sixth&#123;30,&#x27;&#x27;c&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<h4 id="2-make-tuple-函数"><a href="#2-make-tuple-函数" class="headerlink" title="2) make_tuple()函数"></a>2) make_tuple()函数</h4><p>上面程序中，我们已经用到了 make_tuple() 函数，它以模板的形式定义在 头文件中，功能是创建一个 tuple 右值对象（或者临时对象）。</p>
<p>对于 make_tuple() 函数创建了 tuple 对象，我们可以上面程序中那样作为移动构造函数的参数，也可以这样用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> first = std::<span class="built_in">make_tuple</span> (<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>);   <span class="comment">// tuple &lt; int, char &gt;</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">0</span>; <span class="type">int</span> b[<span class="number">3</span>];</span><br><span class="line"><span class="keyword">auto</span> second = std::<span class="built_in">make_tuple</span> (a,b);     <span class="comment">// tuple &lt; int, int* &gt;</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>程序中分别创建了 first 和 second 两个 tuple 对象，它们的类型可以直接用 auto 表示。</p>
<h3 id="tuple常用函数"><a href="#tuple常用函数" class="headerlink" title="tuple常用函数"></a>tuple常用函数</h3><p>为了方便您在实际开发中使用 tuple 对象，tupe 模板类提供了一个功能实用的成员函数， 头文件中也提供了一些和操作 tuple 对象相关的函数模板和类模板，如表 1 所示。</p>
<table>
<thead>
<tr>
<th>函数或类模板</th>
<th>描 述</th>
</tr>
</thead>
<tbody><tr>
<td>tup1.swap(tup2) swap(tup1, tup2)</td>
<td>tup1 和 tup2 表示类型相同的两个 tuple 对象，tuple 模板类中定义有一个 swap() 成员函数， 头文件还提供了一个同名的 swap() 全局函数。 swap() 函数的功能是交换两个 tuple 对象存储的内容。</td>
</tr>
<tr>
<td>get(tup)</td>
<td>tup 表示某个 tuple 对象，num 是一个整数，get() 是 头文件提供的全局函数，功能是返回 tup 对象中第 num+1 个元素。</td>
</tr>
<tr>
<td>tuple_size::value</td>
<td>tuple_size 是定义在 头文件的类模板，它只有一个成员变量 value，功能是获取某个 tuple 对象中元素的个数，type 为该tuple 对象的类型。</td>
</tr>
<tr>
<td>tuple_element&lt;I, type&gt;::type</td>
<td>tuple_element 是定义在 头文件的类模板，它只有一个成员变量 type，功能是获取某个 tuple 对象第 I+1 个元素的类型。</td>
</tr>
<tr>
<td>forward_as_tuple&lt;args…&gt;</td>
<td>args… 表示 tuple 对象存储的多个元素，该函数的功能是创建一个 tuple 对象，内部存储的 args… 元素都是右值引用形式的。</td>
</tr>
<tr>
<td>tie(args…) &#x3D; tup</td>
<td>tup 表示某个 tuple 对象，tie() 是 头文件提供的，功能是将 tup 内存储的元素逐一赋值给 args… 指定的左值变量。</td>
</tr>
<tr>
<td>tuple_cat(args…)</td>
<td>args… 表示多个 tuple 对象，该函数是 头文件提供的，功能是创建一个 tuple 对象，此对象包含 args… 指定的所有 tuple 对象内的元素。</td>
</tr>
</tbody></table>
<blockquote>
<p>tuple 模板类对赋值运算符 &#x3D; 进行了重载，使得同类型的 tuple 对象可以直接赋值。此外，tuple 模板类还重载了 &#x3D;&#x3D;、!&#x3D;、&lt;、&gt;、&gt;&#x3D;、&lt;&#x3D; 这几个比较运算符，同类型的 tuple 对象可以相互比较（逐个比较各个元素）。</p>
</blockquote>
<p>下面的程序给您演示了表 1 中一部分函数模板和类模板的功能：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="comment">//创建一个 tuple 对象存储 10 和 &#x27;x&#x27;</span></span><br><span class="line">    <span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">char</span>&gt; <span class="title">mytuple</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;x&#x27;</span>)</span></span>;</span><br><span class="line">    <span class="comment">//计算 mytuple 存储元素的个数</span></span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mytuple)&gt;::value;</span><br><span class="line">    <span class="comment">//输出 mytuple 中存储的元素</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//修改指定的元素</span></span><br><span class="line">    std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) = <span class="number">100</span>;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">//使用 makde_tuple() 创建一个 tuple 对象</span></span><br><span class="line">    <span class="keyword">auto</span> bar = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;test&quot;</span>, <span class="number">3.1</span>, <span class="number">14</span>);</span><br><span class="line">    <span class="comment">//拆解 bar 对象，分别赋值给 mystr、mydou、myint</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* mystr = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">double</span> mydou;</span><br><span class="line">    <span class="type">int</span> myint;</span><br><span class="line">    <span class="comment">//使用 tie() 时，如果不想接受某个元素的值，实参可以用 std::ignore 代替</span></span><br><span class="line">    std::<span class="built_in">tie</span>(mystr, mydou, myint) = bar;</span><br><span class="line">    <span class="comment">//std::tie(std::ignore, std::ignore, myint) = bar;  //只接收第 3 个整形值</span></span><br><span class="line">    <span class="comment">//将 mytuple 和 bar 中的元素整合到 1 个 tuple 对象中</span></span><br><span class="line">    <span class="keyword">auto</span> mycat = std::<span class="built_in">tuple_cat</span>(mytuple, bar);</span><br><span class="line">    size = std::tuple_size&lt;<span class="keyword">decltype</span>(mycat)&gt;::value;</span><br><span class="line">    std::cout &lt;&lt; size &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10 x<br>100<br>5</p>
<h2 id="C-11列表初始化（统一了初始化方式）"><a href="#C-11列表初始化（统一了初始化方式）" class="headerlink" title="C++11列表初始化（统一了初始化方式）"></a>C++11列表初始化（统一了初始化方式）</h2><p>我们知道，在 <a href="http://c.biancheng.net/cplus/">C++</a>98&#x2F;03 中的对象初始化方法有很多种，请看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化列表</span></span><br><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"><span class="comment">//拷贝初始化（copy-initialization）</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line">&#125; foo = <span class="number">123</span>;  <span class="comment">//需要拷贝构造函数</span></span><br><span class="line"><span class="comment">//直接初始化（direct-initialization）</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">j</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">Foo <span class="title">bar</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>

<p>这些不同的初始化方法，都有各自的适用范围和作用。最关键的是，这些种类繁多的初始化方法，没有一种可以通用所有情况。</p>
<p>为了统一初始化方式，并且让初始化行为具有确定的效果，C++11 中提出了列表初始化（List-initialization）的概念。</p>
<p>POD 类型即 plain old data 类型，简单来说，是可以直接使用 memcpy 复制的对象。</p>
<h3 id="统一的初始化"><a href="#统一的初始化" class="headerlink" title="统一的初始化"></a>统一的初始化</h3><p>在上面我们已经看到了，对于普通数组和 POD 类型，C++98&#x2F;03 可以使用初始化列表（initializer list）进行初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="type">long</span> l_arr[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125; a = &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>但是这种初始化方式的适用性非常狭窄，只有上面提到的这两种数据类型可以使用初始化列表。</p>
<p>在 C++11 中，初始化列表的适用性被大大增加了。它现在可以用于任何类型对象的初始化，请看下面的代码。</p>
<p>【实例】通过初始化列表初始化对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">const</span> Foo &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">a1</span><span class="params">(<span class="number">123</span>)</span></span>;</span><br><span class="line">    Foo a2 = <span class="number">123</span>;  <span class="comment">//error: &#x27;Foo::Foo(const Foo &amp;)&#x27; is private</span></span><br><span class="line">    Foo a3 = &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    Foo a4 &#123; <span class="number">123</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a5 = &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="type">int</span> a6 &#123; <span class="number">3</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>在上例中，a3、a4 使用了新的初始化方式来初始化对象，效果如同 a1 的直接初始化。</p>
<p>a5、a6 则是基本数据类型的列表初始化方式。可以看到，它们的形式都是统一的。</p>
<p>这里需要注意的是，a3 虽然使用了等于号，但它仍然是列表初始化，因此，私有的拷贝构造并不会影响到它。</p>
<p>a4 和 a6 的写法，是 C++98&#x2F;03 所不具备的。在 C++11 中，可以直接在变量名后面跟上初始化列表，来进行对象的初始化。</p>
<p>这种变量名后面跟上初始化列表方法同样适用于普通数组和 POD 类型的初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i_arr[<span class="number">3</span>] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;  <span class="comment">//普通数组</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">B</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">    &#125; b;</span><br><span class="line">&#125; a &#123; <span class="number">1</span>, &#123; <span class="number">2</span>, <span class="number">3</span> &#125; &#125;;  <span class="comment">//POD类型</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>在初始化时，<code>&#123;&#125;</code>前面的等于号是否书写对初始化行为没有影响。</p>
<p>另外，如同读者所想的那样，new 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表：</p>
<p>int* a &#x3D; new int { 123 };<br>double b &#x3D; double { 12.12 };<br>int* arr &#x3D; new int[3] { 1, 2, 3 };</p>
<p>指针 a 指向了一个 new 操作符返回的内存，通过初始化列表方式在内存初始化时指定了值为 123。</p>
<p>b 则是对匿名对象使用列表初始化后，再进行拷贝初始化。</p>
<p>这里让人眼前一亮的是 arr 的初始化方式。堆上动态分配的数组终于也可以使用初始化列表进行初始化了。</p>
<p>除了上面所述的内容之外，列表初始化还可以直接使用在函数的返回值上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span>, <span class="type">double</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Foo <span class="title">func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="number">123</span>, <span class="number">321.0</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>这里的 return 语句就如同返回了一个 Foo(123, 321.0)。</p>
<p>由上面的这些例子可以看到，在 C++11 中使用初始化列表是非常便利的。它不仅统一了各种对象的初始化方式，而且还使代码的书写更加简单清晰。</p>
<h2 id="C-11-lambda匿名函数用法详解"><a href="#C-11-lambda匿名函数用法详解" class="headerlink" title="C++11 lambda匿名函数用法详解"></a>C++11 lambda匿名函数用法详解</h2><p>lambda 源自希腊字母表中第 11 位的 λ，在计算机科学领域，它则是被用来表示一种匿名函数。所谓匿名函数，简单地理解就是没有名称的函数，又常被称为 lambda 函数或者 lambda 表达式。</p>
<p>继 Python、Java、C#、PHP 等众多高级编程语言都支持 lambda 匿名函数后，C++11 标准终于引入了 lambda，本节将带领大家系统地学习 lambda 表达式的具体用法。</p>
<h3 id="lambda匿名函数的定义"><a href="#lambda匿名函数的定义" class="headerlink" title="lambda匿名函数的定义"></a>lambda匿名函数的定义</h3><p>定义一个 lambda 匿名函数很简单，可以套用如下的语法格式：</p>
<p>[外部变量访问方式说明符] (参数) mutable noexcept&#x2F;throw() -&gt; 返回值类型<br>{<br>函数体;<br>};</p>
<p>其中各部分的含义分别为：</p>
<ol>
<li>[外部变量方位方式说明符]<br>[ ] 方括号用于向编译器表明当前是一个 lambda 表达式，其不能被省略。在方括号内部，可以注明当前 lambda 函数的函数体中可以使用哪些“外部变量”。</li>
</ol>
<blockquote>
<p>所谓外部变量，指的是和当前 lambda 表达式位于同一作用域内的所有局部变量。</p>
</blockquote>
<ol start="2">
<li><p>(参数)<br>和普通函数的定义一样，lambda 匿名函数也可以接收外部传递的多个参数。和普通函数不同的是，如果不需要传递参数，可以连同 () 小括号一起省略；</p>
</li>
<li><p>mutable<br>此关键字可以省略，如果使用则之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，对于以值传递方式引入的外部变量，不允许在 lambda 表达式内部修改它们的值（可以理解为这部分变量都是 const 常量）。而如果想修改它们，就必须使用 mutable 关键字。</p>
</li>
</ol>
<p>注意，对于以值传递方式引入的外部变量，lambda 表达式修改的是拷贝的那一份，并不会修改真正的外部变量；</p>
<ol start="4">
<li>noexcept&#x2F;throw()<br>可以省略，如果使用，在之前的 () 小括号将不能省略（参数个数可以为 0）。默认情况下，lambda 函数的函数体中可以抛出任何类型的异常。而标注 noexcept 关键字，则表示函数体内不会抛出任何异常；使用 throw() 可以指定 lambda 函数内部可以抛出的异常类型。</li>
</ol>
<p>值得一提的是，如果 lambda 函数标有 noexcept 而函数体内抛出了异常，又或者使用 throw() 限定了异常类型而函数体内抛出了非指定类型的异常，这些异常无法使用 try-catch 捕获，会导致程序执行失败（本节后续会给出实例）。</p>
<ol start="5">
<li><p>-&gt; 返回值类型<br>指明 lambda 匿名函数的返回值类型。值得一提的是，如果 lambda 函数体内只有一个 return 语句，或者该函数返回 void，则编译器可以自行推断出返回值类型，此情况下可以直接省略<code>-&gt; 返回值类型</code>。</p>
</li>
<li><p>函数体<br>和普通函数一样，lambda 匿名函数包含的内部代码都放置在函数体中。该函数体内除了可以使用指定传递进来的参数之外，还可以使用指定的外部变量以及全局范围内的所有全局变量。</p>
</li>
</ol>
<p>需要注意的是，外部变量会受到以值传递还是以引用传递方式引入的影响，而全局变量则不会。换句话说，在 lambda 表达式内可以使用任意一个全局变量，必要时还可以直接修改它们的值。</p>
<blockquote>
<p>其中，红色标识的参数是定义 lambda 表达式时必须写的，而绿色标识的参数可以省略。</p>
</blockquote>
<p>比如，如下就定义了一个最简单的 lambda 匿名函数：</p>
<p>[]{}</p>
<p>显然，此 lambda 匿名函数未引入任何外部变量（[] 内为空），也没有传递任何参数，没有指定 mutable、noexcept 等关键字，没有返回值和函数体。所以，这是一个没有任何功能的 lambda 匿名函数。</p>
<h4 id="lambda匿名函数中的-外部变量"><a href="#lambda匿名函数中的-外部变量" class="headerlink" title="lambda匿名函数中的[外部变量]"></a>lambda匿名函数中的[外部变量]</h4><p>对于 lambda 匿名函数的使用，令多数初学者感到困惑的就是 [外部变量] 的使用。其实很简单，无非表 1 所示的这几种编写格式。</p>
<table>
<thead>
<tr>
<th>外部变量格式</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>[]</td>
<td>空方括号表示当前 lambda 匿名函数中不导入任何外部变量。</td>
</tr>
<tr>
<td>[&#x3D;]</td>
<td>只有一个 &#x3D; 等号，表示以值传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[&amp;]</td>
<td>只有一个 &amp; 符号，表示以引用传递的方式导入所有外部变量；</td>
</tr>
<tr>
<td>[val1,val2,…]</td>
<td>表示以值传递的方式导入 val1、val2 等指定的外部变量，同时多个变量之间没有先后次序；</td>
</tr>
<tr>
<td>[&amp;val1,&amp;val2,…]</td>
<td>表示以引用传递的方式导入 val1、val2等指定的外部变量，多个变量之间没有前后次序；</td>
</tr>
<tr>
<td>[val,&amp;val2,…]</td>
<td>以上 2 种方式还可以混合使用，变量之间没有前后次序。</td>
</tr>
<tr>
<td>[&#x3D;,&amp;val1,…]</td>
<td>表示除 val1 以引用传递的方式导入外，其它外部变量都以值传递的方式导入。</td>
</tr>
<tr>
<td>[this]</td>
<td>表示以值传递的方式导入当前的 this 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>注意，单个外部变量不允许以相同的传递方式导入多次。例如 [&#x3D;，val1] 中，val1 先后被以值传递的方式导入了 2 次，这是非法的。</p>
</blockquote>
<p>【例 1】lambda 匿名函数的定义和使用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num<span class="number">+4</span>, [=](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">bool</span>&#123; <span class="keyword">return</span> x &lt; y; &#125; );</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>1 2 3 4</p>
<p>程序第 9 行通过调用 sort() 函数实现了对 num 数组中元素的升序排序，其中就用到了 lambda 匿名函数。而如果使用普通函数，需以如下代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义的升序排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">sort_up</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span>  x &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">4</span>] = &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//对 a 数组中的元素进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(num, num<span class="number">+4</span>, sort_up);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n : num)&#123;</span><br><span class="line">        cout &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>此程序中 sort_up() 函数的功能和上一个程序中的 lambda 匿名函数完全相同。显然在类似的场景中，使用 lambda 匿名函数更有优势。</p>
<p>除此之外，虽然 lambda 匿名函数没有函数名称，但我们仍可以为其手动设置一个名称，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//display 即为 lambda 匿名函数的函数名</span></span><br><span class="line">    <span class="keyword">auto</span> display = [](<span class="type">int</span> a,<span class="type">int</span> b) -&gt; <span class="type">void</span>&#123;cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b;&#125;;</span><br><span class="line">    <span class="comment">//调用 lambda 函数</span></span><br><span class="line">    <span class="built_in">display</span>(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10 20</p>
<p>可以看到，程序中使用 auto 关键字为 lambda 匿名函数设定了一个函数名，由此我们即可在作用域内调用该函数。</p>
<p>【例 2】值传递和引用传递的区别</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="type">int</span> all_num = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//局部变量</span></span><br><span class="line">    <span class="type">int</span> num_1 = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> num_2 = <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> num_3 = <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda1:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda1 = [=]&#123;</span><br><span class="line">        <span class="comment">//全局变量可以访问甚至修改</span></span><br><span class="line">        all_num = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda1</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lambda2:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> lambda2 = [&amp;]&#123;</span><br><span class="line">        all_num = <span class="number">100</span>;</span><br><span class="line">        num_1 = <span class="number">10</span>;</span><br><span class="line">        num_2 = <span class="number">20</span>;</span><br><span class="line">        num_3 = <span class="number">30</span>;</span><br><span class="line">        cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">             &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">lambda2</span>();</span><br><span class="line">    cout &lt;&lt; all_num &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829303132333435</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>lambda1:<br>1 2 3<br>10<br>lambda2:<br>10 20 30<br>100</p>
<p>可以看到，在创建 lambda1 和 lambda2 匿名函数的作用域中，有 num_1、num_2 和 num_3 这 3 个局部变量，另外还有 all_num 全局变量。</p>
<p>其中，lambda1 匿名函数是以 [&#x3D;] 值传递的方式导入的局部变量，这意味着默认情况下，此函数内部无法修改这 3 个局部变量的值，但全局变量 all_num 除外。相对地，lambda2 匿名函数以 [&amp;] 引用传递的方式导入这 3 个局部变量，因此在该函数的内部不就可以访问这 3 个局部变量，还可以任意修改它们。同样，也可以访问甚至修改全局变量。</p>
<blockquote>
<p>感兴趣的读者，可自行尝试在 lambda1 匿名函数中修改 num_1、num_2 或者 num_3 的值，观察编译器的报错信息。</p>
</blockquote>
<p>当然，如果我们想在 lambda1 匿名函数的基础上修改外部变量的值，可以借助 mutable 关键字，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> lambda1 = [=]() <span class="keyword">mutable</span>&#123;</span><br><span class="line">    num_1 = <span class="number">10</span>;</span><br><span class="line">    num_2 = <span class="number">20</span>;</span><br><span class="line">    num_3 = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//函数体内只能使用外部变量，而无法对它们进行修改</span></span><br><span class="line">    cout &lt;&lt; num_1 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_2 &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line">         &lt;&lt; num_3 &lt;&lt; endl;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>由此，就可以在 lambda1 匿名函数中修改外部变量的值。但需要注意的是，这里修改的仅是 num_1、num_2、num_3 拷贝的那一份的值，真正外部变量的值并不会发生改变。</p>
<p>【例 3】执行抛出异常类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except = []()<span class="built_in">throw</span>(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">except</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">catch</span> (<span class="type">int</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>捕获到了整形异常</p>
<p>可以看到，except 匿名数组中指定函数体中可以抛出整形异常，因此当函数体中真正发生整形异常时，可以借助 try-catch 块成功捕获并处理。</p>
<p>在此基础上，在看一下反例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> except1 = []()<span class="keyword">noexcept</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">100</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">auto</span> except2 = []()<span class="built_in">throw</span>(<span class="type">char</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">10</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="built_in">except1</span>();</span><br><span class="line">        <span class="built_in">except2</span>();</span><br><span class="line">    &#125;<span class="built_in">catch</span>(<span class="type">int</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;捕获到了整形异常&quot;</span>&lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>此程序运行会直接崩溃，原因很简单，except1 匿名函数指定了函数体中不发生任何异常，但函数体中却发生了整形异常；except2 匿名函数指定函数体可能会发生字符异常，但函数体中却发生了整形异常。由于指定异常类型和真正发生的异常类型不匹配，导致 try-catch 无法捕获，最终程序运行崩溃。</p>
<blockquote>
<p>如果不使用 noexcept 或者 throw()，则 lambda 匿名函数的函数体中允许发生任何类型的异常。</p>
</blockquote>
<h2 id="C-11非受限联合体（union）"><a href="#C-11非受限联合体（union）" class="headerlink" title="C++11非受限联合体（union）"></a>C++11非受限联合体（union）</h2><p>在 C&#x2F;<a href="http://c.biancheng.net/cplus/">C++</a> 中，联合体（Union）是一种构造数据类型。在一个联合体内，我们可以定义多个不同类型的成员，这些成员将会共享同一块内存空间。老版本的 C++ 为了和C语言保持兼容，对联合体的数据成员的类型进行了很大程度的限制，这些限制在今天看来并没有必要，因此 C++11 取消了这些限制。</p>
<p>C++11 标准规定，任何非引用类型都可以成为联合体的数据成员，这种联合体也被称为非受限联合体。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">bool</span> g, <span class="type">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">T</span>&#123;</span><br><span class="line">    Student s;  <span class="comment">// 含有非POD类型的成员，gcc-5.1.0  版本报错</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中，因为 Student 类带有自定义的构造函数，所以是一个非 POD 类型的，这导致编译器报错。这种规定只是 C++ 为了兼容C语言而制定，然而在长期的编程实践中发现，这种规定是没有必要的。</p>
<p>关于 POD 类型稍后我们会讲解，大家先不要着急。</p>
<p>接下来，我们具体看一下 C++11 对 C++98 的改进。</p>
<h3 id="1-C-11-允许非-POD-类型"><a href="#1-C-11-允许非-POD-类型" class="headerlink" title="1. C++11 允许非 POD 类型"></a>1. C++11 允许非 POD 类型</h3><p>C++98 不允许联合体的成员是非 POD 类型，但是 C++1 1 取消了这种限制。</p>
<p>POD 是 C++ 中一个比较重要的概念，在这里我们做一个简单介绍。POD 是英文 Plain Old Data 的缩写，用来描述一个类型的属性。</p>
<p>POD 类型一般具有以下几种特征（包括 class、union 和 struct等）：</p>
<ol>
<li><p>没有用户自定义的构造函数、析构函数、拷贝构造函数和移动构造函数。</p>
</li>
<li><p>不能包含虚函数和虚基类。</p>
</li>
<li><p>非静态成员必须声明为 public。</p>
</li>
<li><p>类中的第一个非静态成员的类型与其基类不同，例如：</p>
</li>
</ol>
<p>class B1{};<br>class B2 : B1 { B1 b; };</p>
<p>class B2 的第一个非静态成员 b 是基类类型，所以它不是 POD 类型。</p>
<ol start="5">
<li>在类或者结构体继承时，满足以下两种情况之一：</li>
</ol>
<ul>
<li>派生类中有非静态成员，且只有一个仅包含静态成员的基类；</li>
<li>基类有非静态成员，而派生类没有非静态成员。</li>
</ul>
<p>我们来看具体的例子：</p>
<p>class B1 { static int n; };<br>class B2 : B1 { int n1; };<br>class B3 : B2 { static int n2; };</p>
<p>对于 B2，派生类 B2 中有非静态成员，且只有一个仅包含静态成员的基类 B1，所以它是 POD 类型。对于 B3，基类 B2 有非静态成员，而派生类 B3 没有非静态成员，所以它也是 POD 类型。</p>
<ol start="6">
<li><p>所有非静态数据成员均和其基类也符合上述规则（递归定义），也就是说 POD 类型不能包含非 POD 类型的数据。</p>
</li>
<li><p>此外，所有兼容C语言的数据类型都是 POD 类型（struct、union 等不能违背上述规则）。</p>
</li>
</ol>
<h3 id="2-C-11-允许联合体有静态成员"><a href="#2-C-11-允许联合体有静态成员" class="headerlink" title="2. C++11 允许联合体有静态成员"></a>2. C++11 允许联合体有静态成员</h3><p>C++11 删除了联合体不允许拥有静态成员的限制。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，静态成员变量只能在联合体内定义，却不能在联合体外使用，这使得该规则很没用。</p>
<h2 id="非受限联合体的赋值注意事项"><a href="#非受限联合体的赋值注意事项" class="headerlink" title="非受限联合体的赋值注意事项"></a>非受限联合体的赋值注意事项</h2><p>C++11 规定，如果非受限联合体内有一个非 POD 的成员，而该成员拥有自定义的构造函数，那么这个非受限联合体的默认构造函数将被编译器删除；其他的特殊成员函数，例如默认拷贝构造函数、拷贝赋值操作符以及析构函数等，也将被删除。</p>
<p>这条规则可能导致对象构造失败，请看下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;   <span class="comment">// 构造失败，因为 U 的构造函数被删除</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>在上面的例子中，因为 string 类拥有自定义的构造函数，所以 U 的构造函数被删除；定义 U 的类型变量 u 需要调用默认构造函数，所以 u 也就无法定义成功。</p>
<p>解决上面问题的一般需要用到 placement new（稍后会讲解这个概念），代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">U</span> &#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">U</span>() &#123; <span class="keyword">new</span>(&amp;s) string; &#125;</span><br><span class="line">    ~<span class="built_in">U</span>() &#123; s.~<span class="built_in">string</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    U u;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>构造时，采用 placement new 将 s 构造在其地址 &amp;s 上，这里 placement new 的唯一作用只是调用了一下 string 类的构造函数。注意，在析构时还需要调用 string 类的析构函数。</p>
<h3 id="placement-new-是什么？"><a href="#placement-new-是什么？" class="headerlink" title="placement new 是什么？"></a>placement new 是什么？</h3><p>placement new 是 new 关键字的一种进阶用法，既可以在栈（stack）上生成对象，也可以在堆（heap）上生成对象。相对应地，我们把常见的 new 的用法称为 operator new，它只能在 heap 上生成对象。</p>
<p>placement new 的语法格式如下：</p>
<p>new(address) ClassConstruct(…)</p>
<p>address 表示已有内存的地址，该内存可以在栈上，也可以在堆上；ClassConstruct(…) 表示调用类的构造函数，如果构造函数没有参数，也可以省略括号。</p>
<p>placement new 利用已经申请好的内存来生成对象，它不再为对象分配新的内存，而是将对象数据放在 address 指定的内存中。在本例中，placement new 使用的是 s 的内存空间。</p>
<h2 id="非受限联合体的匿名声明和“枚举式类”"><a href="#非受限联合体的匿名声明和“枚举式类”" class="headerlink" title="非受限联合体的匿名声明和“枚举式类”"></a>非受限联合体的匿名声明和“枚举式类”</h2><p>匿名联合体是指不具名的联合体（也即没有名字的联合体），一般定义如下：</p>
<p>union U{<br>union { int x; }; &#x2F;&#x2F;此联合体为匿名联合体<br>};</p>
<p>可以看到，联合体 U 内定义了一个不具名的联合体，该联合体包含一个 int 类型的成员变量，我们称这个联合体为匿名联合体。</p>
<p>同样的，非受限联合体也可以匿名，而当非受限的匿名联合体运用于类的声明时，这样的类被称为“枚举式类”。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">bool</span> g, <span class="type">int</span> a): <span class="built_in">gender</span>(g), <span class="built_in">age</span>(a)&#123;&#125;</span><br><span class="line">    <span class="type">bool</span> gender;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Type</span> &#123; STUDENT, NATIVE, FOREIGENR &#125;;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">bool</span> g, <span class="type">int</span> a) : <span class="built_in">s</span>(g, a) &#123; t = STUDENT; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">int</span> i) : <span class="built_in">id</span>(i) &#123; t = NATIVE; &#125;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="type">const</span> <span class="type">char</span>* n, <span class="type">int</span> s) &#123;</span><br><span class="line">        <span class="type">int</span> size = (s &gt; <span class="number">9</span>) ? <span class="number">9</span> : s;</span><br><span class="line">        <span class="built_in">memcpy</span>(name , n, size);</span><br><span class="line">        name[s] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        t = FOREIGENR;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Singer</span>()&#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Type t;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        Student s;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        <span class="type">char</span> name[<span class="number">10</span>];</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="literal">true</span>, <span class="number">13</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="number">310217</span>);</span><br><span class="line">    <span class="built_in">Singer</span>(<span class="string">&quot;J Michael&quot;</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure>

<p>上面的代码中使用了一个匿名非受限联合体，它作为类 Singer 的“变长成员”来使用，这样的变长成员给类的编写带来了更大的灵活性，这是 C++98 标准中无法达到的（编译器会报<code>member &#39;Student Singer::&lt;anonymous union&gt;::s&#39; with constructor not allowed in union</code>错误）。</p>
<h2 id="C-11-for循环（基于范围的循环）详解"><a href="#C-11-for循环（基于范围的循环）详解" class="headerlink" title="C++11 for循环（基于范围的循环）详解"></a>C++11 for循环（基于范围的循环）详解</h2><p>C++ 11标准之前（C++ 98&#x2F;03 标准），如果要用 for 循环语句遍历一个数组或者容器，只能套用如下结构：</p>
<p>for(表达式 1; 表达式 2; 表达式 3){<br>&#x2F;&#x2F;循环体<br>}</p>
<p>例如，下面程序演示了用上述结构遍历数组和容器的具体实现过程（实例一）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arc[] = <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(arc); i++) &#123;</span><br><span class="line">        cout &lt;&lt; arc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;<span class="built_in">myvector</span>(arc,arc<span class="number">+23</span>);</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;::iterator iter;</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (iter = myvector.<span class="built_in">begin</span>(); iter != myvector.<span class="built_in">end</span>(); ++iter) &#123;</span><br><span class="line">        cout &lt;&lt; *iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p><a href="http://c.biancheng.net/cplus/11/">http://c.biancheng.net/cplus/11/</a><br><a href="http://c.biancheng.net/">http://c.biancheng.net/</a></p>
<blockquote>
<p>此示例中，vector 为 STL 标准库提供的序列式容器，关于该容器的具体用法，可阅读《<a href="http://c.biancheng.net/view/6749.html">C++ STL vector容器详解</a>》一节，这里不再做重复赘述。</p>
</blockquote>
<p>而 C++ 11 标准中，除了可以沿用前面介绍的用法外，还为 for 循环添加了一种全新的语法格式，如下所示：</p>
<p>for (declaration : expression){<br>&#x2F;&#x2F;循环体<br>}</p>
<p>其中，两个参数各自的含义如下：</p>
<ul>
<li>declaration：表示此处要定义一个变量，该变量的类型为要遍历序列中存储元素的类型。需要注意的是，C++ 11 标准中，declaration参数处定义的变量类型可以用 auto 关键字表示，该关键字可以使编译器自行推导该变量的数据类型。</li>
<li>expression：表示要遍历的序列，常见的可以为事先定义好的普通数组或者容器，还可以是用 {} 大括号初始化的序列。</li>
</ul>
<p>可以看到，同 C++ 98&#x2F;03 中 for 循环的语法格式相比较，此格式并没有明确限定 for 循环的遍历范围，这是它们最大的区别，即旧格式的 for 循环可以指定循环的范围，而 C++11 标准增加的 for 循环，只会逐个遍历 expression 参数处指定序列中的每个元素。</p>
<p>下面程序演示了如何用 C++ 11 标准中的 for 循环遍历实例一定义的 arc 数组和 myvector 容器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arc[] = <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : arc) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;!&#x27;</span> &lt;&lt; endl;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;<span class="built_in">myvector</span>(arc, arc + <span class="number">23</span>);</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;!&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p><a href="http://c.biancheng.net/cplus/11/">http://c.biancheng.net/cplus/11/</a> !<br><a href="http://c.biancheng.net/">http://c.biancheng.net/</a>!</p>
<p>这里有以下 2 点需要说明：</p>
<ol>
<li><p>程序中在遍历 myvector 容器时，定义了 auto 类型的 ch 变量，当编译器编译程序时，会通过 myvector 容器中存储的元素类型自动推导出 ch 为 char 类型。注意，这里的 ch 不是迭代器类型，而表示的是 myvector 容器中存储的每个元素。</p>
</li>
<li><p>仔细观察程序的输出结果，其中第一行输出的字符串和 “!” 之间还输出有一个空格，这是因为新格式的 for 循环在遍历字符串序列时，不只是遍历到最后一个字符，还会遍历位于该字符串末尾的 ‘\0’（字符串的结束标志）。之所以第二行输出的字符串和 “!” 之间没有空格，是因为 myvector 容器中没有存储 ‘\0’。</p>
</li>
</ol>
<p>除此之外，新语法格式的 for 循环还支持遍历用<code>&#123; &#125;</code>大括号初始化的列表，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>1 2 3 4 5</p>
<p>另外值得一提的是，在使用新语法格式的 for 循环遍历某个序列时，如果需要遍历的同时修改序列中元素的值，实现方案是在 declaration 参数处定义引用形式的变量。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arc[] = <span class="string">&quot;abcde&quot;</span>;</span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;<span class="built_in">myvector</span>(arc, arc + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">//for循环遍历并修改容器中各个字符的值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;ch : myvector) &#123;</span><br><span class="line">        ch++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//for循环遍历输出容器中各个字符</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>bcdef</p>
<p>此程序中先后使用了 2 个新语法格式的 for 循环，其中前者用于修改 myvector 容器中各个元素的值，后者用于输出修改后的 myvector 容器中的各个元素。</p>
<p>有读者可能会问，declaration 参数既可以定义普通形式的变量，也可以定义引用形式的变量，应该如何选择呢？其实很简单，如果需要在遍历序列的过程中修改器内部元素的值，就必须定义引用形式的变量；反之，建议定义<code>const &amp;</code>（常引用）形式的变量（避免了底层复制变量的过程，效率更高），也可以定义普通变量。</p>
<h2 id="C-11-for循环使用注意事项"><a href="#C-11-for循环使用注意事项" class="headerlink" title="C++11 for循环使用注意事项"></a>C++11 for循环使用注意事项</h2><p>《<a href="http://c.biancheng.net/view/7759.html">C++11 for循环</a>》一节已经详细介绍了 C++11 标准中 for 循环的基本用法。在此基础上，本节将介绍一些 for 循环的使用注意事项，帮助读者更准确高效地使用基于范围的 for 循环。</p>
<ol>
<li>首先需要明确的一点是，当使用 for 循环遍历某个序列时，无论该序列是普通数组、容器还是用<code>&#123; &#125;</code>大括号包裹的初始化列表，遍历序列的变量都表示的是当前序列中的各个元素。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//for循环遍历初始化列表</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> ch : &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//for循环遍历普通数组</span></span><br><span class="line">    <span class="type">char</span> arc[] = <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : arc) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//for循环遍历 vector 容器</span></span><br><span class="line">    vector&lt;<span class="type">char</span>&gt;<span class="built_in">myvector</span>(arc, arc + <span class="number">23</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ch : myvector) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>12345<br><a href="http://c.biancheng.net/cplus/11/">http://c.biancheng.net/cplus/11/</a><br><a href="http://c.biancheng.net/">http://c.biancheng.net/</a></p>
<p>上面程序演示了用 for 循环遍历 3 种序列的过程，其中前两种情况很容易理解，但对于用基于范围的 for 循环遍历容器中的元素，很多读者会将 ch 误认为指向各个元素的迭代器，其实不然，它表示的仍是容器中的各个元素。</p>
<p>为了加深读者对遍历容器的理解，下面程序以 map 容器为例，再举一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map&lt;string, string&gt;mymap&#123; &#123;<span class="string">&quot;C++11&quot;</span>,<span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>&#125;,</span><br><span class="line">                              &#123;<span class="string">&quot;Python&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>&#125;,</span><br><span class="line">                              &#123;<span class="string">&quot;Java&quot;</span>,<span class="string">&quot;http://c.biancheng.net/java/&quot;</span>&#125; &#125;;</span><br><span class="line">    <span class="keyword">for</span> (pair&lt;string,string&gt; ch : mymap) &#123;</span><br><span class="line">        cout &lt;&lt; ch.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ch.second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>C++11 <a href="http://c.biancheng.net/cplus/11/">http://c.biancheng.net/cplus/11/</a><br>Java <a href="http://c.biancheng.net/java/">http://c.biancheng.net/java/</a><br>Python <a href="http://c.biancheng.net/python/">http://c.biancheng.net/python/</a></p>
<p>要知道，map 容器中存储的不再是普通数据类型的数据，而是 pair 类型的数据，因此程序中在使用基于范围的 for 循环遍历 map 容器时，定义的是 pair 类型的变量。</p>
<p>值得初学者注意的一点是，基于范围的 for 循环也可以直接遍历某个字符串，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">char</span> ch : <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>) &#123;</span><br><span class="line">    cout &lt;&lt; ch;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>前面提到，普通数组可以作为被遍历的序列。拿此程序中的字符串来说，其数据类型为<code>const char[33]</code>，即在编译器看来字符串就是一个普通数组，因此完全可以直接作为被遍历的序列。</p>
<blockquote>
<p>当然，基于范围的 for 循环也可以遍历 string 类型的字符串，这种情况下冒号前定义 char 类型的变量即可。</p>
</blockquote>
<ol start="2">
<li>总的来说，基于范围的 for 循环可以遍历普通数组、string字符串、容器以及初始化列表。除此之外，for 循环冒号后还可以放置返回 string 字符串以及容器对象的函数，比如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str = <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; myvector = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">string <span class="title">retStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">retVector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> myvector;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历函数返回的 string 字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : <span class="built_in">retStr</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//遍历函数返回的 vector 容器</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : <span class="built_in">retVector</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p><a href="http://c.biancheng.net/cplus/11/">http://c.biancheng.net/cplus/11/</a><br>1 2 3 4 5</p>
<p>注意，基于范围的 for 循环不支持遍历函数返回的以指针形式表示的数组，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误示例</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">char</span>* <span class="title">retStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : <span class="built_in">retStr</span>()) <span class="comment">//直接报错</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p>原因很简单，此格式的 for 循环只能遍历有明确范围的一组数据，上面程序中 retStr() 函数返回的是指针变量，遍历范围并未明确指明，所以编译失败。</p>
<ol start="3">
<li>值得一提的是，当基于范围的 for 循环遍历的是某函数返回的 string 对象或者容器时，整个遍历过程中，函数只会执行一次。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string str= <span class="string">&quot;http://c.biancheng.net/cplus/11/&quot;</span>;</span><br><span class="line"><span class="function">string <span class="title">retStr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;retStr:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历函数返回的 string 字符串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> ch : <span class="built_in">retStr</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; ch;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>retStr:<br><a href="http://c.biancheng.net/cplus/11/">http://c.biancheng.net/cplus/11/</a></p>
<p>借助执行结果不难分析出，整个 for 循环遍历 str 字符串对象的过程中，retStr() 函数仅在遍历开始前执行了 1 次。</p>
<ol start="4">
<li><p>系统学过 STL 标准库的读者应该知道，基于关联式容器（包括哈希容器）底层存储机制的限制：</p>
</li>
<li><p>不允许修改 map、unordered_map、multimap 以及 unordered_multimap 容器存储的键的值；</p>
</li>
<li><p>不允许修改 set、unordered_set、multiset 以及 unordered_multiset 容器中存储的元素的值。</p>
</li>
</ol>
<blockquote>
<p>关于以上各个容器的具体用法，读者可猛击《<a href="http://c.biancheng.net/stl/">C++ STL教程</a>》进行系统学习。</p>
</blockquote>
<p>因此，当使用基于范围的 for 循环遍历此类型容器时，切勿修改容器中不允许被修改的数据部分，否则会导致程序的执行出现各种 Bug。</p>
<p>另外，基于范围的 for 循环完成对容器的遍历，其底层也是借助容器的迭代器实现的。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt;arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> val : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; std::endl;</span><br><span class="line">        arr.<span class="built_in">push_back</span>(<span class="number">10</span>); <span class="comment">//向容器中添加元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果可能为（输出结果不唯一）：</p>
<p>1<br>-572662307<br>-572662307<br>4<br>5</p>
<p>可以看到，程序的执行结果并不是我们想要的。就是因为在 for 循环遍历 arr 容器的同时向该容器尾部添加了新的元素（对 arr 容器进行了扩增），致使遍历容器所使用的迭代器失效，整个遍历过程出现错误。</p>
<blockquote>
<p>如果读者想要彻底搞清楚程序执行失败的原因，读了解 vector 容器的底层存储机制，可阅读《<a href="http://c.biancheng.net/view/vip_7710.html">C++ vector容器底层实现机制</a>》一文。</p>
</blockquote>
<p>因此，在使用基于范围的 for 循环遍历容器时，应避免在循环体中修改容器存储元素的个数。</p>
<h2 id="C-11-constexpr：验证是否为常量表达式（长篇神文）"><a href="#C-11-constexpr：验证是否为常量表达式（长篇神文）" class="headerlink" title="C++11 constexpr：验证是否为常量表达式（长篇神文）"></a>C++11 constexpr：验证是否为常量表达式（长篇神文）</h2><p>constexpr 是 C++ 11 标准新引入的关键字，不过在讲解其具体用法和功能之前，读者需要先搞清楚 C++ 常量表达式的含义。</p>
<p>所谓常量表达式，指的就是由多个（≥1）常量组成的表达式。换句话说，如果表达式中的成员都是常量，那么该表达式就是一个常量表达式。这也意味着，常量表达式一旦确定，其值将无法修改。</p>
<p>实际开发中，我们经常会用到常量表达式。以定义数组为例，数组的长度就必须是一个常量表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1)</span></span><br><span class="line"><span class="type">int</span> url[<span class="number">10</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 2)</span></span><br><span class="line"><span class="type">int</span> url[<span class="number">6</span> + <span class="number">4</span>];<span class="comment">//正确</span></span><br><span class="line"><span class="comment">// 3)</span></span><br><span class="line"><span class="type">int</span> length = <span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> url[length];<span class="comment">//错误，length是变量</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>上述代码演示了 3 种定义 url 数组的方式，其中第 1、2 种定义 url 数组时，长度分别为 10 和 6+4，显然它们都是常量表达式，可以用于表示数组的长度；第 3 种 url 数组的长度为 length，它是变量而非常量，因此不是一个常量表达式，无法用于表示数组的长度。</p>
<blockquote>
<p>常量表达式的应用场景还有很多，比如匿名枚举、switch-case 结构中的 case 表达式等，感兴趣的读者可自行编码测试，这里不再过多举例。</p>
</blockquote>
<p>我们知道，C++ 程序的执行过程大致要经历编译、链接、运行这 3 个阶段。值得一提的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果；而常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>对于用 C++ 编写的程序，性能往往是永恒的追求。那么在实际开发中，如何才能判定一个表达式是否为常量表达式，进而获得在编译阶段即可执行的“特权”呢？除了人为判定外，C++11 标准还提供有 constexpr 关键字。</p>
<p>constexpr 关键字的功能是使指定的常量表达式获得在程序编译阶段计算出结果的能力，而不必等到程序运行阶段。C++ 11 标准中，constexpr 可用于修饰普通变量、函数（包括模板函数）以及类的构造函数。</p>
<blockquote>
<p>注意，获得在编译阶段计算出结果的能力，并不代表 constexpr 修饰的表达式一定会在程序编译阶段被执行，具体的计算时机还是编译器说了算。</p>
</blockquote>
<h3 id="constexpr修饰普通变量"><a href="#constexpr修饰普通变量" class="headerlink" title="constexpr修饰普通变量"></a>constexpr修饰普通变量</h3><p>C++11 标准中，定义变量时可以用 constexpr 修饰，从而使该变量获得在编译阶段即可计算出结果的能力。</p>
<p>值得一提的是，使用 constexpr 修改普通变量时，变量必须经过初始化且初始值必须是一个常量表达式。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> num = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> url[num] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    couts&lt;&lt; url[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>2</p>
<blockquote>
<p>读者可尝试将 constexpr 删除，此时编译器会提示“url[num] 定义中 num 不可用作常量”。</p>
</blockquote>
<p>可以看到，程序第 6 行使用 constexpr 修饰 num 变量，同时将 “1+2+3” 这个常量表达式赋值给 num。由此，编译器就可以在编译时期对 num 这个表达式进行计算，因为 num 可以作为定义数组时的长度。</p>
<p>有读者可能发现，将此示例程序中的 constexpr 用 const 关键字替换也可以正常执行，这是因为 num 的定义同时满足“num 是 const 常量且使用常量表达式为其初始化”这 2 个条件，由此编译器会认定 num 是一个常量表达式。</p>
<blockquote>
<p>注意，const 和 constexpr 并不相同，关于它们的区别，我们会在下一节做详细讲解。</p>
</blockquote>
<p>另外需要重点提出的是，当常量表达式中包含浮点数时，考虑到程序编译和运行所在的系统环境可能不同，常量表达式在编译阶段和运行阶段计算出的结果精度很可能会受到影响，因此 C++11 标准规定，浮点常量表达式在编译阶段计算的精度要至少等于（或者高于）运行阶段计算出的精度。</p>
<h3 id="constexpr修饰函数"><a href="#constexpr修饰函数" class="headerlink" title="constexpr修饰函数"></a>constexpr修饰函数</h3><p>constexpr 还可以用于修饰函数的返回值，这样的函数又称为“常量表达式函数”。</p>
<p>注意，constexpr 并非可以修改任意函数的返回值。换句话说，一个函数要想成为常量表达式函数，必须满足如下 4 个条件。</p>
<ol>
<li>整个函数的函数体中，除了可以包含 using 指令、typedef 语句以及 static_assert 断言外，只能包含一条 return 返回语句。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>注意，这个函数是无法通过编译的，因为该函数的返回值用 constexpr 修饰，但函数内部包含多条语句。</p>
<p>如下是正确的定义 display() 常量表达式函数的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//可以添加 using 执行、typedef 语句以及 static_assert 断言</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>可以看到，display() 函数的返回值是用 constexpr 修饰的 int 类型值，且该函数的函数体中只包含一个 return 语句。</p>
<ol start="2">
<li>该函数必须有返回值，即函数的返回值类型不能是 void。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>像上面这样定义的返回值类型为 void 的函数，不属于常量表达式函数。原因很简单，因为通过类似的函数根本无法获得一个常量。</p>
<ol start="3">
<li>函数在使用之前，必须有对应的定义语句。我们知道，函数的使用分为“声明”和“定义”两部分，普通的函数调用只需要提前写好该函数的声明部分即可（函数的定义部分可以放在调用位置之后甚至其它文件中），但常量表达式函数在使用前，必须要有该函数的定义。</li>
</ol>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//普通函数的声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的声明</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="comment">//常量表达式函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    cout &lt;&lt; a[<span class="number">2</span>] &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//调用普通函数</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">noconst_dis</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//普通函数的定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">noconst_dis</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + <span class="number">2</span> + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>3<br>6</p>
<blockquote>
<p>读者可自行将 display() 常量表达式函数的定义调整到 main() 函数之后，查看编译器的报错信息。</p>
</blockquote>
<p>可以看到，普通函数在调用时，只需要保证调用位置之前有相应的声明即可；而常量表达式函数则不同，调用位置之前必须要有该函数的定义，否则会导致程序编译失败。</p>
<ol start="4">
<li>return 返回的表达式必须是常量表达式，举个例子：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num = <span class="number">3</span>;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">display</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用常量表达式函数</span></span><br><span class="line">    <span class="type">int</span> a[<span class="built_in">display</span>(<span class="number">3</span>)] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>该程序无法通过编译，编译器报“display(3) 的结果不是常量”的异常。</p>
<p>常量表达式函数的返回值必须是常量表达式的原因很简单，如果想在程序编译阶段获得某个函数返回的常量，则该函数的 return 语句中就不能包含程序运行阶段才能确定值的变量。</p>
<blockquote>
<p>注意，在常量表达式函数的 return 语句中，不能包含赋值的操作（例如 return x&#x3D;1 在常量表达式函数中不允许的）。另外，用 constexpr 修改函数时，函数本身也是支持递归的，感兴趣的读者可自行尝试编码测试。</p>
</blockquote>
<h3 id="constexpr修饰类的构造函数"><a href="#constexpr修饰类的构造函数" class="headerlink" title="constexpr修饰类的构造函数"></a>constexpr修饰类的构造函数</h3><p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p>此程序是无法通过编译的，编译器会抛出“constexpr不能修饰自定义类型”的异常。</p>
<p>当我们想自定义一个可产生常量的类型时，正确的做法是在该类型的内部添加一个常量构造函数。例如，修改上面的错误示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    cout &lt;&lt; mt.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; mt.age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10</p>
<p>可以看到，在 myType 结构体中自定义有一个构造函数，借助此函数，用 constexpr 修饰的 myType 类型的 my 常量即可通过编译。</p>
<p>注意，constexpr 修饰类的构造函数时，要求该构造函数的函数体必须为空，且采用初始化列表的方式为各个成员赋值时，必须使用常量表达式。</p>
<p>前面提到，constexpr 可用于修饰函数，而类中的成员方法完全可以看做是“位于类这个命名空间中的函数”，所以 constexpr 也可以修饰类中的成员函数，只不过此函数必须满足前面提到的 4 个条件。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myType</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">myType</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,<span class="type">int</span> age)</span>:name(name),age(age)&#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> * <span class="title">getname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">getage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">struct</span> <span class="title class_">myType</span> mt &#123; <span class="string">&quot;zhangsan&quot;</span>, <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span> * name = mt.<span class="built_in">getname</span>();</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> age = mt.<span class="built_in">getage</span>();</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10</p>
<blockquote>
<p>注意，C++11 标准中，不支持用 constexpr 修饰带有 virtual 的成员方法。</p>
</blockquote>
<h3 id="constexpr修饰模板函数"><a href="#constexpr修饰模板函数" class="headerlink" title="constexpr修饰模板函数"></a>constexpr修饰模板函数</h3><p>C++11 语法中，constexpr 可以修饰模板函数，但由于模板中类型的不确定性，因此模板函数实例化后的函数是否符合常量表达式函数的要求也是不确定的。</p>
<p>针对这种情况下，C++11 标准规定，如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该函数就等同于一个普通函数。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//自定义类型的定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myType</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">//其它结构体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">dispaly</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> stu&#123;<span class="string">&quot;zhangsan&quot;</span>,<span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//普通函数</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">myType</span> ret = <span class="built_in">dispaly</span>(stu);</span><br><span class="line">    cout &lt;&lt; ret.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; ret.age &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//常量表达式函数</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> ret1 = <span class="built_in">dispaly</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; ret1 &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>zhangsan 10<br>10</p>
<p>可以看到，示例程序中定义了一个模板函数 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<ul>
<li>第 20 行代码处，当模板函数中以自定义结构体 myType 类型进行实例化时，由于该结构体中没有定义常量表达式构造函数，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的；</li>
<li>第 23 行代码处，模板函数的类型 T 为 int 类型，实例化后的函数符合常量表达式函数的要求，所以该函数的返回值就是一个常量表达式。</li>
</ul>
<h2 id="C-11-constexpr和const的区别"><a href="#C-11-constexpr和const的区别" class="headerlink" title="C++11 constexpr和const的区别"></a>C++11 constexpr和const的区别</h2><p>《<a href="http://c.biancheng.net/view/7781.html">C++11 constexpr</a>》一节中，详细讲解了 constexpr 关键字的功能和用法。一些读者在学习过程中，经常会把 const 和 constexpr 搞混，不知道什么时候用 const，什么时候用 constexpr。本节就带领大家对 const 和 constexpr 做系统地区分。</p>
<p>我们知道，constexpr 是 C++ 11 标准新添加的关键字，在此之前（C++ 98&#x2F;03标准）只有 const 关键字，其在实际使用中经常会表现出两种不同的语义。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_1</span><span class="params">(<span class="type">const</span> <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="comment">//错误，x是只读的变量</span></span><br><span class="line">    array &lt;<span class="type">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dis_2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    array &lt;<span class="type">int</span>,x&gt; myarr&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    cout &lt;&lt; myarr[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">dis_1</span>(<span class="number">5</span>);</span><br><span class="line">   <span class="built_in">dis_2</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>可以看到，dis_1() 和 dis_2() 函数中都包含一个 const int x，但 dis_1() 函数中的 x 无法完成初始化 array 容器的任务，而 dis_2() 函数中的 x 却可以。</p>
<p>这是因为，dis_1() 函数中的“const int x”只是想强调 x 是一个只读的变量，其本质仍为变量，无法用来初始化 array 容器；而 dis_2() 函数中的“const int x”，表明 x 是一个只读变量的同时，x 还是一个值为 5 的常量，所以可以用来初始化 array 容器。</p>
<p>C++ 11标准中，为了解决 const 关键字的双重语义问题，保留了 const 表示“只读”的语义，而将“常量”的语义划分给了新添加的 constexpr 关键字。因此 C++11 标准中，建议将 const 和 constexpr 的功能区分开，即凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。</p>
<blockquote>
<p>在上面的实例程序中，dis_2() 函数中使用 const int x 是不规范的，应使用 constexpr 关键字。</p>
</blockquote>
<p>有读者可能会问，“只读”不就意味着其不能被修改吗？答案是否定的，“只读”和“不允许被修改”之间并没有必然的联系，举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> &amp; con_b = a;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; con_b &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>20</p>
<p>可以看到，程序中用 const 修饰了 con_b 变量，表示该变量“只读”，即无法通过变量自身去修改自己的值。但这并不意味着 con_b 的值不能借助其它变量间接改变，通过改变 a 的值就可以使 con_b 的值发生变化。</p>
<p>在大部分实际场景中，const 和 constexpr 是可以混用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> a = <span class="number">5</span> + <span class="number">4</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>它们是完全等价的，都可以在程序的编译阶段计算出结果。但在某些场景中，必须明确使用 constexpr，例如：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">sqr1</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">int</span> <span class="title">sqr2</span><span class="params">(<span class="type">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arg*arg;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>,sqr1(10)&gt; mylist1;<span class="comment">//可以，因为sqr1时constexpr函数</span></span><br><span class="line">    array&lt;<span class="type">int</span>,sqr2(10)&gt; mylist1;<span class="comment">//不可以，因为sqr2不是constexpr函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<p>其中，因为 sqr2() 函数的返回值仅有 const 修饰，而没有用更明确的 constexpr 修饰，导致其无法用于初始化 array 容器（只有常量才能初始化 array 容器）。</p>
<p>总的来说在 C++ 11 标准中，const 用于为修饰的变量添加“只读”属性；而 constexpr 关键字则用于指明其后是一个常量（或者常量表达式），编译器在编译程序时可以顺带将其结果计算出来，而无需等到程序运行阶段，这样的优化极大地提高了程序的执行效率。</p>
<h2 id="C-11-long-long超长整形详解"><a href="#C-11-long-long超长整形详解" class="headerlink" title="C++11 long long超长整形详解"></a>C++11 long long超长整形详解</h2><p>C++ 11 标准中，基于整数大小的考虑，共提供了如表 1 所示的这些数据类型。与此同时，标准中还明确限定了各个数据类型最少占用的位数。</p>
<table>
<thead>
<tr>
<th>整数类型</th>
<th>等价类型</th>
<th>C++11标准规定占用最少位数</th>
</tr>
</thead>
<tbody><tr>
<td>short</td>
<td>short int（有符号短整型）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed short</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed short int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned short</td>
<td>unsigned short int（无符号短整型）</td>
<td></td>
</tr>
<tr>
<td>unsigned short int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>int</td>
<td>int（有符号整形）</td>
<td>至少 16 位（2 个字节）</td>
</tr>
<tr>
<td>signed</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned</td>
<td>unsigned int（无符号整形）</td>
<td></td>
</tr>
<tr>
<td>unsigned int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long</td>
<td>long int（有符号长整形）</td>
<td>至少 32 位（4 个字节）</td>
</tr>
<tr>
<td>long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned long</td>
<td>unsigned long int（无符号长整形）</td>
<td></td>
</tr>
<tr>
<td>unsigned long int</td>
<td></td>
<td></td>
</tr>
<tr>
<td>long long（C++11）</td>
<td>long long int（有符号超长整形）</td>
<td>至少 64 位（8 个字节）</td>
</tr>
<tr>
<td>long long int（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long long（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>signed long long int（C++11）</td>
<td></td>
<td></td>
</tr>
<tr>
<td>unsigned long long（C++11）</td>
<td>unsigned long long int（无符号超长整型）</td>
<td></td>
</tr>
<tr>
<td>unsigned long long int（C++11）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p>C++11 标准规定，每种整数类型必须同时具备有符号（signed）和无符号（unsigned）两种类型，且每种具体的有符号整形和无符号整形所占用的存储空间（也就是位数）必须相同。注意，C++11 标准中只限定了每种类型最少占用多少存储空间，不同的平台可以占用不同的存储空间。</p>
</blockquote>
<p>在表 1 罗列的这些数据类型中，long long 超长整型是 C++ 11 标准新添加的，接下来就对该整数类型做具体的介绍。</p>
<p>说道 C++ 标准委员会将 long long 整形写入 C++ 11 标准中，其实早在 1995 年，就有人提议将 long long 整形写入 C++ 98 标准，但被委员会拒绝了。而后 long long 整形被 C99 标准（C语言标准之一）采纳，并逐渐被很多编译器支持，于是 C++ 标准委员会重新决定将 long long 整形写入 C++ 11 标准中。</p>
<p>如同 long 类型整数需明确标注 “L” 或者 “l” 后缀一样，要使用 long long 类型的整数，也必须标注对应的后缀：</p>
<ul>
<li>对于有符号 long long 整形，后缀用 “LL” 或者 “ll” 标识。例如，“10LL” 就表示有符号超长整数 10；</li>
<li>对于无符号 long long 整形，后缀用 “ULL”、“ull”、“Ull” 或者 “uLL” 标识。例如，“10ULL” 就表示无符号超长整数 10；</li>
</ul>
<blockquote>
<p>如果不添加任何标识，则所有的整数都会默认为 int 类型。</p>
</blockquote>
<p>对于任意一种数据类型，读者可能更关心的是此类型的取值范围。对于 long long 类型来说，如果想了解当前平台上 long long 整形的取值范围，可以使用<code>&lt;climits&gt;</code>头文件中与 long long 整形相关的 3 个宏，分别为 LLONG_MIN、LLONG_MAX 和 ULLONG_MIN：</p>
<ol>
<li>LLONG_MIN：代表当前平台上最小的 long long 类型整数；</li>
<li>LLONG_MAX：代表当前平台上最大的 long long 类型整数；</li>
<li>ULLONG_MIN：代表当前平台上最大的 unsigned long long 类型整数（无符号超长整型的最小值为 0）；</li>
</ol>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt;<span class="string">&quot;long long最大值：&quot;</span> &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt; hex &lt;&lt; LLONG_MIN &lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; dec &lt;&lt;<span class="string">&quot;long long最小值：&quot;</span> &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; hex &lt;&lt; LLONG_MAX &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    cout &lt;&lt; dec &lt;&lt; <span class="string">&quot;unsigned long long最大值：&quot;</span> &lt;&lt; ULLONG_MAX &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; hex &lt;&lt; ULLONG_MAX;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为（不唯一）：</p>
<p>long long最大值：-9223372036854775808 8000000000000000<br>long long最小值：9223372036854775807 7fffffffffffffff<br>unsigned long long最大值：18446744073709551615 ffffffffffffffff</p>
<blockquote>
<p>关于整形在内存中到底是如何存储的，读者可阅读《<a href="http://c.biancheng.net/view/vip_1761.html">整数在内存中是如何存储的，为什么它堪称天才般的设计</a>》一节。</p>
</blockquote>
<p>此程序中，输出了各最大值和最小值对应的十六进制，显然在当前平台（Windows10 64位操作系统）上，long long 超长整型占用 64 位（也就是 16 个字节）的存储空间。读者可自行在自己的机器上运行此段代码，即可轻松得知 long long 类型在自己机器上所占用的字节数。</p>
<h2 id="C-11右值引用（一看即懂）"><a href="#C-11右值引用（一看即懂）" class="headerlink" title="C++11右值引用（一看即懂）"></a>C++11右值引用（一看即懂）</h2><p>《<a href="http://c.biancheng.net/view/7751.html">C++11是什么</a>》一节中提到，在 C++98&#x2F;03 标准的基础上，C++11 标准对 C++ 语言增添了约 140 个新特性。本节要讲的右值引用就是众多新特性中的一个，同时也是最重要的特性之一。</p>
<p>很多初学者都感觉右值引用晦涩难懂，其实不然。右值引用只不过是一种新的 C++ 语法，真正理解起来有难度的是基于右值引用引申出的 2 种 C++ 编程技巧，分别为移动语义和完美转发。本节先给读者讲解什么是右值引用以及它的基本用法，至于移动语义和完美转发则放到后续章节讲解。</p>
<h3 id="C-左值和右值"><a href="#C-左值和右值" class="headerlink" title="C++左值和右值"></a>C++左值和右值</h3><p>右值引用可以从字面意思上理解，指的是以引用传递（而非值传递）的方式使用 C++ 右值。关于 C++ 引用，已经在《<a href="http://c.biancheng.net/cplus/25/">C++引用</a>》专题给大家做了详细的讲解，这里不再重复赘述。接下来重点给大家介绍什么是 C++ 右值。</p>
<p>在 C++ 或者 C 语言中，一个表达式（可以是字面量、变量、对象、函数的返回值等）根据其使用场景不同，分为左值表达式和右值表达式。确切的说 C++ 中左值和右值的概念是从 C 语言继承过来的。</p>
<blockquote>
<p>值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、“right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p>
</blockquote>
<p>通常情况下，判断某个表达式是左值还是右值，最常用的有以下 2 种方法。</p>
<ol>
<li>可位于赋值号（&#x3D;）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。举个例子：</li>
</ol>
<p>int a &#x3D; 5;<br>5 &#x3D; a; &#x2F;&#x2F;错误，5 不能为左值</p>
<p>其中，变量 a 就是一个左值，而字面量 5 就是一个右值。值得一提的是，C++ 中的左值也可以当做右值使用，例如：</p>
<p>int b &#x3D; 10; &#x2F;&#x2F; b 是一个左值<br>a &#x3D; b; &#x2F;&#x2F; a、b 都是左值，只不过将 b 可以当做右值使用</p>
<ol start="2">
<li>有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</li>
</ol>
<p>以上面定义的变量 a、b 为例，a 和 b 是变量名，且通过 &amp;a 和 &amp;b 可以获得他们的存储地址，因此 a 和 b 都是左值；反之，字面量 5、10，它们既没有名称，也无法获取其存储地址（字面量通常存储在寄存器中，或者和代码存储在一起），因此 5、10 都是右值。</p>
<blockquote>
<p>注意，以上 2 种判定方法只适用于大部分场景。由于本节主要讲解右值引用，因此这里适可而止，不再对 C++ 左值和右值做深度剖析，感兴趣的读者可自行研究。</p>
</blockquote>
<h3 id="C-右值引用"><a href="#C-右值引用" class="headerlink" title="C++右值引用"></a>C++右值引用</h3><p>前面提到，其实 C++98&#x2F;03 标准中就有引用，使用 “&amp;” 表示。但此种引用方式有一个缺陷，即正常情况下只能操作 C++ 中的左值，无法对右值添加引用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp;b = num; <span class="comment">//正确</span></span><br><span class="line"><span class="type">int</span> &amp;c = <span class="number">10</span>; <span class="comment">//错误</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>如上所示，编译器允许我们为 num 左值建立一个引用，但不可以为 10 这个右值建立引用。因此，C++98&#x2F;03 标准中的引用又称为左值引用。</p>
<p>注意，虽然 C++98&#x2F;03 标准不支持为右值建立非常量左值引用，但允许使用常量左值引用操作右值。也就是说，常量左值引用既可以操作左值，也可以操作右值，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>我们知道，右值往往是没有名称的，因此要使用它只能借助引用的方式。这就产生一个问题，实际开发中我们可能需要对右值进行修改（实现移动语义时就需要），显然左值引用的方式是行不通的。</p>
<p>为此，C++11 标准新引入了另一种引用方式，称为右值引用，用 “&amp;&amp;” 表示。</p>
<blockquote>
<p>话说，C++标准委员会在选定右值引用符号时，既希望能选用现有 C++ 内部已有的符号，还不能与 C++ 98 &#x2F;03 标准产生冲突，最终选定了 2 个 ‘&amp;’ 表示右值引用。</p>
</blockquote>
<p>需要注意的，和声明左值引用一样，右值引用也必须立即进行初始化操作，且只能使用右值进行初始化，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;b = num;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;c = <span class="number">10</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>和常量左值引用不同的是，右值引用还可以对右值进行修改。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int &amp;&amp; a = num;  //右值引用不能初始化为左值</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>程序输出结果为 100。</p>
<p>另外值得一提的是，C++ 语法上是支持定义常量右值引用的，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> &amp;&amp; a = <span class="number">10</span>;</span><br><span class="line">a = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>但这种定义出来的右值引用并无实际用处。一方面，右值引用主要用于移动语义和完美转发，其中前者需要有修改右值的权限；其次，常量右值引用的作用就是引用一个不可修改的右值，这项工作完全可以交给常量左值引用完成。</p>
<p>学到这里，一些读者可能无法记清楚左值引用和右值引用各自可以引用左值还是右值，这里给大家一张表格，方便大家记忆：</p>
<table>
<thead>
<tr>
<th>引用类型</th>
<th>可以引用的值类型</th>
<th>使用场景</th>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>非常量左值</td>
<td>常量左值</td>
<td>非常量右值</td>
<td>常量右值</td>
<td></td>
<td></td>
</tr>
<tr>
<td>非常量左值引用</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>无</td>
</tr>
<tr>
<td>常量左值引用</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>常用于类中构建拷贝构造函数</td>
</tr>
<tr>
<td>非常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>N</td>
<td>移动语义、完美转发</td>
</tr>
<tr>
<td>常量右值引用</td>
<td>N</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>无实际用途</td>
</tr>
</tbody></table>
<p>表中，Y 表示支持，N 表示不支持。</p>
<blockquote>
<p>其实，C++11 标准中对右值做了更细致的划分，分别称为纯右值（Pure value，简称 pvalue）和将亡值（eXpiring value，简称 xvalue ）。其中纯右值就是 C++98&#x2F;03 标准中的右值（本节中已经做了大篇幅的讲解），而将亡值则指的是和右值引用相关的表达式（比如某函数返回的 T &amp;&amp; 类型的表达式）。对于纯右值和将亡值，都属于右值，读者知道即可，不必深究。</p>
</blockquote>
<h2 id="C-11移动构造函数的功能和用法"><a href="#C-11移动构造函数的功能和用法" class="headerlink" title="C++11移动构造函数的功能和用法"></a>C++11移动构造函数的功能和用法</h2><p>《<a href="http://c.biancheng.net/view/7829.html">C++11右值引用</a>》一节中，给读者详细介绍了 C++ 右值引用的含义和用法，同时还提到“右值引用主要用于实现移动（move）语义和完美转发”。有关完美转发，后续章节会做详细介绍，本节主要讲解移动语义的含义以及实现它的方式。</p>
<h3 id="C-11移动语义是什么"><a href="#C-11移动语义是什么" class="headerlink" title="C++11移动语义是什么"></a>C++11移动语义是什么</h3><p>在 C++ 11 标准之前（C++ 98&#x2F;03 标准中），如果想用其它对象初始化一个同类的新对象，只能借助类中的复制（拷贝）构造函数。通过《<a href="http://c.biancheng.net/view/2334.html">C++拷贝构造函数</a>》一节的学习我们知道，拷贝构造函数的实现原理很简单，就是为新对象复制一份和其它对象一模一样的数据。</p>
<blockquote>
<p>需要注意的是，当类中拥有指针类型的成员变量时，拷贝构造函数中需要以深拷贝（而非浅拷贝）的方式复制该指针成员。有关深拷贝和浅拷贝以及它们的区别，读者可阅读《<a href="http://c.biancheng.net/view/2336.html">C++深拷贝和浅拷贝</a>》一文做详细了解。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//拷贝构造函数</span></span><br><span class="line">   <span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line">   ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">      cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>如上所示，我们为 demo 类自定义了一个拷贝构造函数。该函数在拷贝 d.num 指针成员时，必须采用深拷贝的方式，即拷贝该指针成员本身的同时，还要拷贝指针指向的内存资源。否则一旦多个对象中的指针成员指向同一块堆空间，这些对象析构时就会对该空间释放多次，这是不允许的。</p>
</blockquote>
<p>可以看到，程序中定义了一个可返回 demo 对象的 get_demo() 函数，用于在 main() 主函数中初始化 a 对象，其整个初始化的流程包含以下几个阶段：</p>
<ol>
<li>执行 get_demo() 函数内部的 demo() 语句，即调用 demo 类的默认构造函数生成一个匿名对象；</li>
<li>执行 return demo() 语句，会调用拷贝构造函数复制一份之前生成的匿名对象，并将其作为 get_demo() 函数的返回值（函数体执行完毕之前，匿名对象会被析构销毁）；</li>
<li>执行 a &#x3D; get_demo() 语句，再调用一次拷贝构造函数，将之前拷贝得到的临时对象复制给 a（此行代码执行完毕，get_demo() 函数返回的对象会被析构）；</li>
<li>程序执行结束前，会自行调用 demo 类的析构函数销毁 a。</li>
</ol>
<p>注意，目前多数编译器都会对程序中发生的拷贝操作进行优化，因此如果我们使用 VS 2017、codeblocks 等这些编译器运行此程序时，看到的往往是优化后的输出结果：</p>
<p>construct!<br>class destruct!</p>
<p>而同样的程序，如果在 Linux 上使用<code>g++ demo.cpp -fno-elide-constructors</code>命令运行（其中 demo.cpp 是程序文件的名称），就可以看到完整的输出结果：</p>
<p>construct! &lt;– 执行 demo()<br>copy construct! &lt;– 执行 return demo()<br>class destruct! &lt;– 销毁 demo() 产生的匿名对象<br>copy construct! &lt;– 执行 a &#x3D; get_demo()<br>class destruct! &lt;– 销毁 get_demo() 返回的临时对象<br>class destruct! &lt;– 销毁 a</p>
<p>如上所示，利用拷贝构造函数实现对 a 对象的初始化，底层实际上进行了 2 次拷贝（而且是深拷贝）操作。当然，对于仅申请少量堆空间的临时对象来说，深拷贝的执行效率依旧可以接受，但如果临时对象中的指针成员申请了大量的堆空间，那么 2 次深拷贝操作势必会影响 a 对象初始化的执行效率。</p>
<blockquote>
<p>事实上，此问题一直存留在以 C++ 98&#x2F;03 标准编写的 C++ 程序中。由于临时变量的产生、销毁以及发生的拷贝操作本身就是很隐晦的（编译器对这些过程做了专门的优化），且并不会影响程序的正确性，因此很少进入程序员的视野。</p>
</blockquote>
<p>那么当类中包含指针类型的成员变量，使用其它对象来初始化同类对象时，怎样才能避免深拷贝导致的效率问题呢？C++11 标准引入了解决方案，该标准中引入了右值引用的语法，借助它可以实现移动语义。</p>
<h3 id="C-移动构造函数（移动语义的具体实现）"><a href="#C-移动构造函数（移动语义的具体实现）" class="headerlink" title="C++移动构造函数（移动语义的具体实现）"></a>C++移动构造函数（移动语义的具体实现）</h3><p>所谓移动语义，指的就是以移动而非深拷贝的方式初始化含有指针成员的类对象。简单的理解，移动语义指的就是将其他对象（通常是临时对象）拥有的内存资源“移为已用”。</p>
<p>以前面程序中的 demo 类为例，该类的成员都包含一个整形的指针成员，其默认指向的是容纳一个整形变量的堆空间。当使用 get_demo() 函数返回的临时对象初始化 a 时，我们只需要将临时对象的 num 指针直接浅拷贝给 a.num，然后修改该临时对象中 num 指针的指向（通常另其指向 NULL），这样就完成了 a.num 的初始化。</p>
<blockquote>
<p>事实上，对于程序执行过程中产生的临时对象，往往只用于传递数据（没有其它的用处），并且会很快会被销毁。因此在使用临时对象初始化新对象时，我们可以将其包含的指针成员指向的内存资源直接移给新对象所有，无需再新拷贝一份，这大大提高了初始化的执行效率。</p>
</blockquote>
<p>例如，下面程序对 demo 类进行了修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">const</span> demo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加移动构造函数</span></span><br><span class="line">    <span class="built_in">demo</span>(demo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">demo</span>()&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;class destruct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">demo <span class="title">get_demo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">demo</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    demo a = <span class="built_in">get_demo</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728</span></span><br></pre></td></tr></table></figure>

<p>可以看到，在之前 demo 类的基础上，我们又手动为其添加了一个构造函数。和其它构造函数不同，此构造函数使用右值引用形式的参数，又称为移动构造函数。并且在此构造函数中，num 指针变量采用的是浅拷贝的复制方式，同时在函数内部重置了 d.num，有效避免了“同一块对空间被释放多次”情况的发生。</p>
<p>在 Linux 系统中使用<code>g++ demo.cpp -o demo.exe -std=c++0x -fno-elide-constructors</code>命令执行此程序，输出结果为：</p>
<p>construct!<br>move construct!<br>class destruct!<br>move construct!<br>class destruct!<br>class destruct!</p>
<p>通过执行结果我们不难得知，当为 demo 类添加移动构造函数之后，使用临时对象初始化 a 对象过程中产生的 2 次拷贝操作，都转由移动构造函数完成。</p>
<p>我们知道，非 const 右值引用只能操作右值，程序执行结果中产生的临时对象（例如函数返回值、lambda 表达式等）既无名称也无法获取其存储地址，所以属于右值。当类中同时包含拷贝构造函数和移动构造函数时，如果使用临时对象初始化当前类的对象，编译器会优先调用移动构造函数来完成此操作。只有当类中没有合适的移动构造函数时，编译器才会退而求其次，调用拷贝构造函数。</p>
<blockquote>
<p>在实际开发中，通常在类中自定义移动构造函数的同时，会再为其自定义一个适当的拷贝构造函数，由此当用户利用右值初始化类对象时，会调用移动构造函数；使用左值（非右值）初始化类对象时，会调用拷贝构造函数。</p>
</blockquote>
<p>读者可能会问，如果使用左值初始化同类对象，但也想调用移动构造函数完成，有没有办法可以实现呢？</p>
<p>默认情况下，左值初始化同类对象只能通过拷贝构造函数完成，如果想调用移动构造函数，则必须使用右值进行初始化。C++11 标准中为了满足用户使用左值初始化同类对象时也通过移动构造函数完成的需求，新引入了 std::move() 函数，它可以将左值强制转换成对应的右值，由此便可以使用移动构造函数。</p>
<blockquote>
<p>有关 std::move() 函数的用法，后续章节会做详细讲解。</p>
</blockquote>
<h2 id="C-11-move-函数：将左值强制转换为右值"><a href="#C-11-move-函数：将左值强制转换为右值" class="headerlink" title="C++11 move()函数：将左值强制转换为右值"></a>C++11 move()函数：将左值强制转换为右值</h2><p>通过学习 《<a href="http://c.biancheng.net/view/7847.html">C++11移动构造函数</a>》一节我们知道，C++11 标准中借助右值引用可以为指定类添加移动构造函数，这样当使用该类的右值对象（可以理解为临时对象）初始化同类对象时，编译器会优先选择移动构造函数。</p>
<p>注意，移动构造函数的调用时机是：用同类的右值对象初始化新对象。那么，用当前类的左值对象（有名称，能获取其存储地址的实例对象）初始化同类对象时，是否就无法调用移动构造函数了呢？当然不是，C++11 标准中已经给出了解决方案，即调用 move() 函数。</p>
<p>move 本意为 “移动”，但该函数并不能移动任何数据，它的功能很简单，就是将某个左值强制转化为右值。</p>
<blockquote>
<p>基于 move() 函数特殊的功能，其常用于实现移动语义。</p>
</blockquote>
<p>move() 函数的用法也很简单，其语法格式如下：</p>
<p>move( arg )</p>
<p>其中，arg 表示指定的左值对象。该函数会返回 arg 对象的右值形式。</p>
<p>【例 1】move() 函数的基础应用。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">movedemo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">movedemo</span>():<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//拷贝构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(<span class="type">const</span> movedemo &amp;d):<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(*d.num))&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;copy construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">movedemo</span>(movedemo &amp;&amp;d):<span class="built_in">num</span>(d.num)&#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;move construct!&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:     <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    movedemo demo;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo2:\n&quot;</span>;</span><br><span class="line">    movedemo demo2 = demo;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo2.num &lt;&lt; endl;   //可以执行</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;demo3:\n&quot;</span>;</span><br><span class="line">    movedemo demo3 = std::<span class="built_in">move</span>(demo);</span><br><span class="line">    <span class="comment">//此时 demo.num = NULL，因此下面代码会报运行时错误</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; *demo.num &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>construct!<br>demo2:<br>copy construct!<br>demo3:<br>move construct!</p>
<p>通过观察程序的输出结果，以及对比 demo2 和 demo3 初始化操作不难得知，demo 对象作为左值，直接用于初始化 demo2 对象，其底层调用的是拷贝构造函数；而通过调用 move() 函数可以得到 demo 对象的右值形式，用其初始化 demo3 对象，编译器会优先调用移动构造函数。</p>
<blockquote>
<p>注意，调用拷贝构造函数，并不影响 demo 对象，但如果调用移动构造函数，由于函数内部会重置 demo.num 指针的指向为 NULL，所以程序中第 30 行代码会导致程序运行时发生错误。</p>
</blockquote>
<p>【例 2】灵活使用 move() 函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">first</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">first</span>() :<span class="built_in">num</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">0</span>)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//移动构造函数</span></span><br><span class="line">    <span class="built_in">first</span>(first &amp;&amp;d) :<span class="built_in">num</span>(d.num) &#123;</span><br><span class="line">        d.num = <span class="literal">NULL</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;first move construct!&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    <span class="type">int</span> *num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">second</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">second</span>() :<span class="built_in">fir</span>() &#123;&#125;</span><br><span class="line">    <span class="comment">//用 first 类的移动构造函数初始化 fir</span></span><br><span class="line">    <span class="built_in">second</span>(second &amp;&amp; sec) :<span class="built_in">fir</span>(<span class="built_in">move</span>(sec.fir)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;second move construct&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:    <span class="comment">//这里也应该是 private，使用 public 是为了更方便说明问题</span></span><br><span class="line">    first fir;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    second oth;</span><br><span class="line">    second oth2 = <span class="built_in">move</span>(oth);</span><br><span class="line">    <span class="comment">//cout &lt;&lt; *oth.fir.num &lt;&lt; endl;   //程序报运行时错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>construct!<br>first move construct!<br>second move construct</p>
<p>程序中分别构建了 first 和 second 这 2 个类，其中 second 类中包含一个 first 类对象。如果读者仔细观察不难发现，程序中使用了 2 此 move() 函数：</p>
<ul>
<li>程序第 31 行：由于 oth 为左值，如果想调用移动构造函数为 oth2 初始化，需先利用 move() 函数生成一个 oth 的右值版本；</li>
<li>程序第 22 行：oth 对象内部还包含一个 first 类对象，对于 oth.fir 来说，其也是一个左值，所以在初始化 oth.fir 时，还需要再调用一次 move() 函数。</li>
</ul>
<h2 id="C-11引用限定符的用法"><a href="#C-11引用限定符的用法" class="headerlink" title="C++11引用限定符的用法"></a>C++11引用限定符的用法</h2><p>在《<a href="http://c.biancheng.net/view/7829.html">C++右值引用</a>》一节中，我们给您介绍了左值和右值。值得一提的是，左值和右值的区分也同样适用于类对象，本节中将左值的类对象称为左值对象，将右值的类对象称为右值对象。</p>
<p>默认情况下，对于类中用 public 修饰的成员函数，既可以被左值对象调用，也可以被右值对象调用。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>可以看到，demo 类中的 get_num() 成员函数既可以被 a 左值对象调用，也可以被 move(a) 生成的右值 demo 对象调用，运行程序会输出两个 10。</p>
<p>某些场景中，我们可能需要限制调用成员函数的对象的类型（左值还是右值），为此 C++11 新添加了引用限定符。所谓引用限定符，就是在成员函数的后面添加 “&amp;” 或者 “&amp;&amp;”，从而限制调用者的类型（左值还是右值）。</p>
<p>修改上面程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;          <span class="comment">// 正确</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; move(a).get_num() &lt;&lt; endl;  // 错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>和之前的程序相比，我们仅在 get_num() 成员函数的后面添加了 “&amp;”，它可以限定调用该函数的对象必须是左值对象。因此第 16 行代码中，move(a) 生成的右值对象是不允许调用 get_num() 函数的。</p>
<p>同理，我们再次修改程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num):<span class="built_in">num</span>(num)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span>&amp;&amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num() &lt;&lt; endl;      // 错误</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;  <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>和先前程序不同的是，get_num() 函数后根有 “&amp;&amp;” 限定符，它可以限定调用该函数的对象必须是一个右值对象。</p>
<blockquote>
<p>注意，引用限定符不适用于静态成员函数和友元函数。</p>
</blockquote>
<h3 id="const和引用限定符"><a href="#const和引用限定符" class="headerlink" title="const和引用限定符"></a>const和引用限定符</h3><p>我们知道，const 也可以用于修饰类的成员函数，我们习惯称为常成员函数，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>这里的 get_num() 就是一个常成员函数。</p>
<p>const 和引用限定符修饰类的成员函数时，都位于函数的末尾。C++11 标准规定，当引用限定符和 const 修饰同一个类的成员函数时，const 必须位于引用限定符前面。</p>
<p>需要注意的一点是，当 const &amp;&amp; 修饰类的成员函数时，调用它的对象只能是右值对象；当 const &amp; 修饰类的成员函数时，调用它的对象既可以是左值对象，也可以是右值对象。无论是 const &amp;&amp; 还是 const &amp; 限定的成员函数，内部都不允许对当前对象做修改操作。</p>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">demo</span>(<span class="type">int</span> num,<span class="type">int</span> num2) :<span class="built_in">num</span>(num),<span class="built_in">num2</span>(num2) &#123;&#125;</span><br><span class="line">    <span class="comment">//左值和右值对象都可以调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num</span><span class="params">()</span> <span class="type">const</span> &amp;</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//仅供右值对象调用</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_num2</span><span class="params">()</span> <span class="type">const</span> &amp;&amp; </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;num2;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">int</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">demo <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">get_num</span>() &lt;&lt; endl;        <span class="comment">// 正确</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num</span>() &lt;&lt; endl;  <span class="comment">// 正确</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">//cout &lt;&lt; a.get_num2() &lt;&lt; endl;     // 错误 </span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">move</span>(a).<span class="built_in">get_num2</span>() &lt;&lt; endl; <span class="comment">// 正确</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526</span></span><br></pre></td></tr></table></figure>

<h2 id="C-11完美转发及其实现"><a href="#C-11完美转发及其实现" class="headerlink" title="C++11完美转发及其实现"></a>C++11完美转发及其实现</h2><p>C++11 标准为 C++ 引入右值引用语法的同时，还解决了一个 C++ 98&#x2F;03 标准长期存在的短板，即使用简单的方式即可在函数模板中实现参数的完美转发。那么，什么是完美转发？它为什么是 C++98&#x2F;03 标准存在的一个短板？C++11 标准又是如何为 C++ 弥补这一短板的？别急，本节将就这些问题给读者做一一讲解。</p>
<p>首先解释一下什么是完美转发，它指的是函数模板可以将自己的参数“完美”地转发给内部调用的其它函数。所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。</p>
<blockquote>
<p>在 C++ 中，一个表达式不是左值就是右值。有关如何判断一个表达式是左值还是右值，可阅读《<a href="http://c.biancheng.net/view/7829.html">C++右值引用</a>》一文做详细了解。</p>
</blockquote>
<p>举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>如上所示，function() 函数模板中调用了 otherdef() 函数。在此基础上，完美转发指的是：如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值；反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值。</p>
<p>显然，function() 函数模板并没有实现完美转发。一方面，参数 t 为非引用类型，这意味着在调用 function() 函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作；另一方面，无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于函数内部的参数 t 来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值，也就是说，传递给 otherdef() 函数的参数 t 永远都是左值。总之，无论从那个角度看，function() 函数的定义都不“完美”。</p>
<blockquote>
<p>读者可能会问，完美转发这样严苛的参数传递机制，很常用吗？C++98&#x2F;03 标准中几乎不会用到，但 C++11 标准为 C++ 引入了右值引用和移动语义，因此很多场景中是否实现完美转发，直接决定了该参数的传递过程使用的是拷贝语义（调用拷贝构造函数）还是移动语义（调用移动构造函数）。</p>
</blockquote>
<p>事实上，C++98&#x2F;03 标准下的 C++ 也可以实现完美转发，只是实现方式比较笨拙。通过前面的学习我们知道，C++ 98&#x2F;03 标准中只有左值引用，并且可以细分为非 const 引用和 const 引用。其中，使用非 const 引用作为函数模板参数时，只能接收左值，无法接收右值；而 const 左值引用既可以接收左值，也可以接收右值，但考虑到其 const 属性，除非被调用函数的参数也是 const 属性，否则将无法直接传递。</p>
<p>这也就意味着，单独使用任何一种引用形式，可以实现转发，但无法保证完美。因此如果使用 C++ 98&#x2F;03 标准下的 C++ 语言，我们可以采用函数模板重载的方式实现完美转发，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载函数模板，分别接收左值和右值</span></span><br><span class="line"><span class="comment">//接收右值参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="type">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收左值参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>);<span class="comment">//5 是右值</span></span><br><span class="line">    <span class="type">int</span>  x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);<span class="comment">//x 是左值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>rvalue<br>lvalue</p>
<p>从输出结果中可以看到，对于右值 5 来说，它实际调用的参数类型为 const T&amp; 的函数模板，由于 t 为 const 类型，所以 otherdef() 函数实际调用的也是参数用 const 修饰的函数，所以输出“rvalue”；对于左值 x 来说，2 个重载模板函数都适用，C++编译器会选择最适合的参数类型为 T&amp; 的函数模板，进而 therdef() 函数实际调用的是参数类型为非 const 的函数，输出“lvalue”。</p>
<p>显然，使用重载的模板函数实现完美转发也是有弊端的，此实现方式仅适用于模板函数仅有少量参数的情况，否则就需要编写大量的重载函数模板，造成代码的冗余。为了方便用户更快速地实现完美转发，C++ 11 标准中允许在函数模板中使用右值引用来实现完美转发。</p>
<p>C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）。</p>
<p>仍以 function() 函数为例，在 C++11 标准中实现完美转发，只需要编写如下一个模板函数即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>此模板函数的参数 t 既可以接收左值，也可以接收右值。但仅仅使用右值引用作为函数模板的参数是远远不够的，还有一个问题继续解决，即如果调用 function() 函数时为其传递一个左值引用或者右值引用的实参，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp; num = n;</span><br><span class="line"><span class="built_in">function</span>(num); <span class="comment">// T 为 int&amp;</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; num2 = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">function</span>(num2); <span class="comment">// T 为 int &amp;&amp;</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>其中，由 function(num) 实例化的函数底层就变成了 function(int &amp; &amp; t)，同样由 function(num2) 实例化的函数底层则变成了 function(int &amp;&amp; &amp;&amp; t)。要知道，C++98&#x2F;03 标准是不支持这种用法的，而 C++ 11标准为了更好地实现完美转发，特意为其指定了新的类型匹配规则，又称为引用折叠规则（假设用 A 表示实际传递参数的类型）：</p>
<ul>
<li>当实参为左值或者左值引用（A&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;（A&amp; &amp;&amp; &#x3D; A&amp;）；</li>
<li>当实参为右值或者右值引用（A&amp;&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;&amp;（A&amp;&amp; &amp;&amp; &#x3D; A&amp;&amp;）。</li>
</ul>
<blockquote>
<p>读者只需要知道，在实现完美转发时，只要函数模板的参数类型为 T&amp;&amp;，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。</p>
</blockquote>
<p>通过将函数模板的形参类型设置为 T&amp;&amp;，我们可以很好地解决接收左、右值的问题。但除此之外，还需要解决一个问题，即无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。那么如何才能将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数呢？</p>
<p>C++11 标准的开发者已经帮我们想好的解决方案，该新标准还引入了一个模板函数 forword()，我们只需要调用该函数，就可以很方便地解决此问题。仍以 function 模板函数为例，如下演示了该函数模板的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现完美转发的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span>  x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>rvalue<br>lvalue</p>
<p>注意程序中第 12~16 行，此 function() 模板函数才是实现完美转发的最终版本。可以看到，forword() 函数模板用于修饰被调用函数中需要维持参数左、右值属性的参数。</p>
<p>总的来说，在定义模板函数时，我们采用右值引用的语法格式定义参数类型，由此该函数既可以接收外界传入的左值，也可以接收右值；其次，还需要使用 C++11 标准库提供的 forword() 模板函数修饰被调用函数中需要维持左、右值属性的参数。由此即可轻松实现函数模板中参数的完美转发。</p>
<h2 id="C-11-nullptr：初始化空指针"><a href="#C-11-nullptr：初始化空指针" class="headerlink" title="C++11 nullptr：初始化空指针"></a>C++11 nullptr：初始化空指针</h2><p>实际开发中，避免产生“野指针”最有效的方法，就是在定义指针的同时完成初始化操作，即便该指针的指向尚未明确，也要将其初始化为空指针。</p>
<blockquote>
<p>所谓“野指针”，又称“悬挂指针”，指的是没有明确指向的指针。野指针往往指向的是那些不可用的内存区域，这就意味着像操作普通指针那样使用野指针（例如 &amp;p），极可能导致程序发生异常。</p>
</blockquote>
<p>C++98&#x2F;03 标准中，将一个指针初始化为空指针的方式有 2 种：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> *p = <span class="literal">NULL</span>; <span class="comment">//推荐使用</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们可以将指针明确指向 0（0x0000 0000）这个内存空间。一方面，明确指针的指向可以避免其成为野指针；另一方面，大多数操作系统都不允许用户对地址为 0 的内存空间执行写操作，若用户在程序中尝试修改其内容，则程序运行会直接报错。</p>
<p>相比第一种方式，我们更习惯将指针初始化为 NULL。值得一提的是，NULL 并不是 C++ 的关键字，它是 C++ 为我们事先定义好的一个宏，并且它的值往往就是字面量 0（#define NULL 0）。</p>
<p>C++ 中将 NULL 定义为字面常量 0，虽然能满足大部分场景的需要，但个别情况下，它会导致程序的运行和我们的预期不符。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">void</span> *c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void*c&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>int n<br>int n</p>
<p>对于 isnull(0) 来说，显然它真正调用的是参数为整形的 isnull() 函数；而对于 isnull(NULL)，我们期望它实际调用的是参数为 void*c 的 isnull() 函数，但观察程序的执行结果不难看出，并不符合我们的预期。</p>
<p>C++ 98&#x2F;03 标准中，如果我们想令 isnull(NULL) 实际调用的是 isnull(void* c)，就需要对 NULL（或者 0）进行强制类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isnull</span>( (<span class="type">void</span>*)<span class="literal">NULL</span> );</span><br><span class="line"><span class="built_in">isnull</span>( (<span class="type">void</span>*)<span class="number">0</span> );</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>如此，才会成功调用我们预期的函数（读者可自行执行此代码，观察输出结果）。</p>
<p>由于 C++ 98 标准使用期间，NULL 已经得到了广泛的应用，出于兼容性的考虑，C++11 标准并没有对 NULL 的宏定义做任何修改。为了修正 C++ 存在的这一 BUG，C++ 标准委员会最终决定另其炉灶，在 C++11 标准中引入一个新关键字，即 nullptr。</p>
<blockquote>
<p>在使用 nullptr 之前，读者需保证自己使用的编译器支持该关键字。以 Visual Studio 和 codeblocks 为例，前者早在 2010 版本就对 C++ 11 标准中的部分特性提供了支持，其中就包括 nullptr；如果使用后者，读者需将其 G++ 编译器版本至少升级至 4.6.1（同时开启 -std&#x3D;c++0x 编译选项）。</p>
</blockquote>
<p>nullptr 是 nullptr_t 类型的右值常量，专用于初始化空类型指针。nullptr_t 是 C++11 新增加的数据类型，可称为“指针空值类型”。也就是说，nullpter 仅是该类型的一个实例对象（已经定义好，可以直接使用），如果需要我们完全定义出多个同 nullptr 完全一样的实例对象。</p>
<p>值得一提的是，nullptr 可以被隐式转换成任意的指针类型。举个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> * a1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">char</span> * a2 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">double</span> * a3 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>显然，不同类型的指针变量都可以使用 nullptr 来初始化，编译器分别将 nullptr 隐式转换成 int*、char* 以及 double* 指针类型。</p>
<p>另外，通过将指针初始化为 nullptr，可以很好地解决 NULL 遗留的问题，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">void</span> *c)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;void*c&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">isnull</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int n&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">isnull</span>(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>int n<br>void*c</p>
<p>借助执行结果不难看出，由于 nullptr 无法隐式转换为整形，而可以隐式匹配指针类型，因此执行结果和我们的预期相符。</p>
<blockquote>
<p>总之在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</p>
</blockquote>
<h2 id="C-11-shared-ptr智能指针（超级详细）"><a href="#C-11-shared-ptr智能指针（超级详细）" class="headerlink" title="C++11 shared_ptr智能指针（超级详细）"></a>C++11 shared_ptr智能指针（超级详细）</h2><p>在实际的 C++ 开发中，我们经常会遇到诸如程序运行中突然崩溃、程序运行所用内存越来越多最终不得不重启等问题，这些问题往往都是内存资源管理不当造成的。比如：</p>
<ul>
<li>有些内存资源已经被释放，但指向它的指针并没有改变指向（成为了野指针），并且后续还在使用；</li>
<li>有些内存资源已经被释放，后期又试图再释放一次（重复释放同一块内存会导致程序运行崩溃）；</li>
<li>没有及时释放不再使用的内存资源，造成内存泄漏，程序占用的内存资源越来越多。</li>
</ul>
<p>针对以上这些情况，很多程序员认为 C++ 语言应该提供更友好的内存管理机制，这样就可以将精力集中于开发项目的各个功能上。</p>
<p>事实上，显示内存管理的替代方案很早就有了，早在 1959 年前后，就有人提出了“垃圾自动回收”机制。所谓垃圾，指的是那些不再使用或者没有任何指针指向的内存空间，而“回收”则指的是将这些“垃圾”收集起来以便再次利用。</p>
<p>如今，垃圾回收机制已经大行其道，得到了诸多编程语言的支持，例如 Java、Python、C#、PHP 等。而 C++ 虽然从来没有公开得支持过垃圾回收机制，但 C++98&#x2F;03 标准中，支持使用 auto_ptr 智能指针来实现堆内存的自动回收；C++11 新标准在废弃 auto_ptr 的同时，增添了 unique_ptr、shared_ptr 以及 weak_ptr 这 3 个智能指针来实现堆内存的自动回收。</p>
<p>所谓智能指针，可以从字面上理解为“智能”的指针。具体来讲，智能指针和普通指针的用法是相似的，不同之处在于，智能指针可以在适当时机自动释放分配的内存。也就是说，使用智能指针可以很好地避免“忘记释放内存而导致内存泄漏”问题出现。由此可见，C++ 也逐渐开始支持垃圾回收机制了，尽管目前支持程度还有限。</p>
<blockquote>
<p>C++ 智能指针底层是采用引用计数的方式实现的。简单的理解，智能指针在申请堆内存空间的同时，会为其配备一个整形值（初始值为 1），每当有新对象使用此堆内存时，该整形值 +1；反之，每当使用此堆内存的对象被释放时，该整形值减 1。当堆空间对应的整形值为 0 时，即表明不再有对象使用它，该堆空间就会被释放掉。</p>
</blockquote>
<p>接下来，我们将分别对 shared_ptr、unique_ptr 以及 weak_ptr 这 3 个智能指针的特性和用法做详细的讲解，本节先介绍 shared_ptr 智能指针。</p>
<h3 id="C-11-shared-ptr智能指针"><a href="#C-11-shared-ptr智能指针" class="headerlink" title="C++11 shared_ptr智能指针"></a>C++11 shared_ptr智能指针</h3><p>实际上，每种智能指针都是以类模板的方式实现的，shared_ptr 也不例外。shared_ptr（其中 T 表示指针指向的具体数据类型）的定义位于<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中，因此在使用该类型指针时，程序中应包含如下 2 行代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，第 2 行代码并不是必须的，也可以不添加，则后续在使用 shared_ptr 智能指针时，就需要明确指明<code>std::</code>。</p>
</blockquote>
<p>值得一提的是，和 unique_ptr、weak_ptr 不同之处在于，多个 shared_ptr 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 shared_ptr 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 shared_ptr 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p>
<h4 id="1、shared-ptr智能指针的创建"><a href="#1、shared-ptr智能指针的创建" class="headerlink" title="1、shared_ptr智能指针的创建"></a>1、shared_ptr智能指针的创建</h4><p>shared_ptr 类模板中，提供了多种实用的构造函数，这里给读者列举了几个常用的构造函数（以构建指向 int 类型数据的智能指针为例）。</p>
<ol>
<li>通过如下 2 种方式，可以构造出 shared_ptr 类型的空智能指针：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">//不传入任何实参std::shared_ptr&lt;int&gt; p2(nullptr);    //传入空指针 nullptr</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>注意，空的 shared_ptr 指针，其初始引用计数为 0，而不是 1。</p>
<ol start="2">
<li>在构建 shared_ptr 智能指针，也可以明确其指向。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>由此，我们就成功构建了一个 shared_ptr 智能指针，其指向一块存有 10 这个 int 类型数据的堆内存空间。</p>
<p>同时，C++11 标准中还提供了 std::make_shared 模板函数，其可以用于初始化 shared_ptr 智能指针，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>以上 2 种方式创建的 p3 是完全相同。</p>
<ol start="3">
<li>除此之外，shared_ptr 模板还提供有相应的拷贝构造函数和移动构造函数，例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;<span class="comment">//或者 std::shared_ptr&lt;int&gt; p4 = p3;</span></span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; <span class="comment">//或者 std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>有关拷贝构造函数，读者可阅读《<a href="http://c.biancheng.net/view/2334.html">C++拷贝构造函数</a>》一节做系统了解；有关移动构造函数，读者可阅读《<a href="http://c.biancheng.net/view/7847.html">C++移动构造函数</a>》做详细了解；有关 move() 函数的功能和用法，读者可阅读《<a href="http://c.biancheng.net/view/7863.html">C++11 move()</a>》一节。</p>
</blockquote>
<p>如上所示，p3 和 p4 都是 shared_ptr 类型的智能指针，因此可以用 p3 来初始化 p4，由于 p3 是左值，因此会调用拷贝构造函数。需要注意的是，如果 p3 为空智能指针，则 p4 也为空智能指针，其引用计数初始值为 0；反之，则表明 p4 和 p3 指向同一块堆内存，同时该堆空间的引用计数会加 1。</p>
<p>而对于 std::move(p4) 来说，该函数会强制将 p4 转换成对应的右值，因此初始化 p5 调用的是移动构造函数。另外和调用拷贝构造函数不同，用 std::move(p4) 初始化 p5，会使得 p5 拥有了 p4 的堆内存，而 p4 则变成了空智能指针。</p>
<p>注意，同一普通指针不能同时为多个 shared_ptr 对象赋值，否则会导致程序发生异常。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="type">int</span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(ptr)</span></span>;</span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(ptr)</span></span>;<span class="comment">//错误</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在初始化 shared_ptr 智能指针时，还可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。</li>
</ol>
<p>在某些场景中，自定义释放规则是很有必要的。比如，对于申请的动态数组来说，shared_ptr 指针默认的释放规则是不支持释放数组的，只能自定义对应的释放规则，才能正确地释放申请的堆内存。</p>
<p>对于申请的动态数组，释放规则可以使用 C++11 标准中提供的 default_delete 模板类，我们也可以自定义释放规则：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//指定 default_delete 作为释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], std::default_delete&lt;<span class="type">int</span>[]&gt;())</span></span>;</span><br><span class="line"><span class="comment">//自定义释放规则</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deleteInt</span><span class="params">(<span class="type">int</span>*p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化智能指针，并自定义释放规则</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], deleteInt)</span></span>;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<p>实际上借助 lambda 表达式，我们还可以像如下这样初始化 p7，它们是完全相同的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>shared_ptr 模板类还提供有其它一些初始化智能指针的方法，感兴趣的读者可前往讲解 <a href="http://www.cplusplus.com/reference/memory/shared_ptr/shared_ptr/">shared_ptr 的官网</a>做系统了解。</p>
</blockquote>
<h4 id="2、shared-ptr模板类提供的成员方法"><a href="#2、shared-ptr模板类提供的成员方法" class="headerlink" title="2、shared_ptr模板类提供的成员方法"></a>2、shared_ptr模板类提供的成员方法</h4><p>为了方便用户使用 shared_ptr 智能指针，shared_ptr 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员方法名</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator&#x3D;()</td>
<td>重载赋值号，使得同一类型的 shared_ptr 智能指针可以相互赋值。</td>
</tr>
<tr>
<td>operator*()</td>
<td>重载 * 号，获取当前 shared_ptr 智能指针对象指向的数据。</td>
</tr>
<tr>
<td>operator-&gt;()</td>
<td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td>
</tr>
<tr>
<td>swap()</td>
<td>交换 2 个相同类型 shared_ptr 智能指针的内容。</td>
</tr>
<tr>
<td>reset()</td>
<td>当函数没有实参时，该函数会使当前 shared_ptr 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 shared_ptr 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。</td>
</tr>
<tr>
<td>get()</td>
<td>获得 shared_ptr 对象内部包含的普通指针。</td>
</tr>
<tr>
<td>use_count()</td>
<td>返回同当前 shared_ptr 对象（包括它）指向相同的所有 shared_ptr 对象的数量。</td>
</tr>
<tr>
<td>unique()</td>
<td>判断当前 shared_ptr 对象指向的堆内存，是否不再有其它 shared_ptr 对象再指向它。</td>
</tr>
<tr>
<td>operator bool()</td>
<td>判断当前 shared_ptr 对象是否为空智能指针，如果是空指针，返回 false；反之，返回 true。</td>
</tr>
</tbody></table>
<blockquote>
<p>除此之外，C++11 标准还支持同一类型的 shared_ptr 对象，或者 shared_ptr 和 nullptr 之间，进行 &#x3D;&#x3D;，!&#x3D;，&lt;，&lt;&#x3D;，&gt;，&gt;&#x3D; 运算。</p>
</blockquote>
<p>下面程序给大家演示了 shared_ptr 智能指针的基本用法，以及该模板类提供了一些成员方法的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//构建 2 个智能指针</span></span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p1)</span></span>;</span><br><span class="line">    <span class="comment">//输出 p2 指向的数据</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    p<span class="number">1.</span><span class="built_in">reset</span>();<span class="comment">//引用计数减 1,p1为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p1) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 不为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p1 为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以上操作，并不会影响 p2</span></span><br><span class="line">    cout &lt;&lt; *p2 &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断当前和 p2 同指向的智能指针有多少个</span></span><br><span class="line">    cout &lt;&lt; p<span class="number">2.</span><span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>p1 为空<br>10<br>1</p>
<h2 id="C-11-unique-ptr智能指针"><a href="#C-11-unique-ptr智能指针" class="headerlink" title="C++11 unique_ptr智能指针"></a>C++11 unique_ptr智能指针</h2><p>在《<a href="http://c.biancheng.net/view/7898.html">C++11 shared_ptr智能指针</a>》的基础上，本节继续讲解 C++11 标准提供的另一种智能指针，即 unique_ptr 智能指针。</p>
<p>作为智能指针的一种，unique_ptr 指针自然也具备“在适当时机自动释放堆内存空间”的能力。和 shared_ptr 指针最大的不同之处在于，unique_ptr 指针指向的堆内存无法同其它 unique_ptr 共享，也就是说，每个 unique_ptr 指针都独自拥有对其所指堆内存空间的所有权。</p>
<blockquote>
<p>这也就意味着，每个 unique_ptr 指针指向的堆内存空间的引用计数，都只能为 1，一旦该 unique_ptr 指针放弃对所指堆内存空间的所有权，则该空间会被立即释放回收。</p>
</blockquote>
<p>unique_ptr 智能指针是以模板类的形式提供的，unique_ptr（T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中。因此，要想使用 unique_ptr 类型指针，程序中应首先包含如下 2 条语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第 2 句并不是必须的，可以不添加，则后续在使用 unique_ptr 指针时，必须标注<code>std::</code>。</p>
</blockquote>
<h3 id="unique-ptr智能指针的创建"><a href="#unique-ptr智能指针的创建" class="headerlink" title="unique_ptr智能指针的创建"></a>unique_ptr智能指针的创建</h3><p>考虑到不同实际场景的需要，unique_ptr 模板类提供了多个实用的构造函数，这里给读者列举了几种常用的构造 unique_ptr 智能指针的方式。</p>
<ol>
<li>通过以下 2 种方式，可以创建出空的 unique_ptr 指针：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建 unique_ptr 指针的同时，也可以明确其指向。例如：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">std::unique_ptr&lt;int&gt; p3(new int);</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>由此就创建出了一个 p3 智能指针，其指向的是可容纳 1 个整数的堆存储空间。</p>
<blockquote>
<p>和可以用 make_shared() 模板函数初始化 shared_ptr 指针不同，C++11 标准中并没有为 unique_ptr 类型指针添加类似的模板函数。</p>
</blockquote>
<ol start="3">
<li>基于 unique_ptr 类型指针不共享各自拥有的堆内存，因此 C++11 标准中的 unique_ptr 模板类没有提供拷贝构造函数，只提供了移动构造函数。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(p4)</span></span>;<span class="comment">//错误，堆内存不共享</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>;<span class="comment">//正确，调用移动构造函数</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>值得一提的是，对于调用移动构造函数的 p4 和 p5 来说，p5 将获取 p4 所指堆空间的所有权，而 p4 将变成空指针（nullptr）。</p>
<ol start="4">
<li>默认情况下，unique_ptr 指针采用 std::default_delete 方法释放堆内存。当然，我们也可以自定义符合实际场景的释放规则。值得一提的是，和 shared_ptr 指针不同，为 unique_ptr 自定义释放规则，只能采用函数对象的方式。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义的释放规则</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">myDel</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> *p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">std::unique_ptr&lt;<span class="type">int</span>, myDel&gt; <span class="title">p6</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="comment">//std::unique_ptr&lt;int, myDel&gt; p6(new int, myDel());</span></span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<h3 id="unique-ptr模板类提供的成员方法"><a href="#unique-ptr模板类提供的成员方法" class="headerlink" title="unique_ptr模板类提供的成员方法"></a>unique_ptr模板类提供的成员方法</h3><p>为了方便用户使用 unique_ptr 智能指针，unique_ptr 模板类还提供有一些实用的成员方法，它们各自的功能如表 1 所示。</p>
<table>
<thead>
<tr>
<th>成员函数名</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator*()</td>
<td>获取当前 unique_ptr 指针指向的数据。</td>
</tr>
<tr>
<td>operator-&gt;()</td>
<td>重载 -&gt; 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td>
</tr>
<tr>
<td>operator &#x3D;()</td>
<td>重载了 &#x3D; 赋值号，从而可以将 nullptr 或者一个右值 unique_ptr 指针直接赋值给当前同类型的 unique_ptr 指针。</td>
</tr>
<tr>
<td>operator<a href="https://blog.csdn.net/qq_41854911/article/details/119657617?ydreferer=aHR0cHM6Ly9jbi5iaW5nLmNvbS8="></a></td>
<td>重载了 [] 运算符，当 unique_ptr 指针指向一个数组时，可以直接通过 [] 获取指定下标位置处的数据。</td>
</tr>
<tr>
<td>get()</td>
<td>获取当前 unique_ptr 指针内部包含的普通指针。</td>
</tr>
<tr>
<td>get_deleter()</td>
<td>获取当前 unique_ptr 指针释放堆内存空间所用的规则。</td>
</tr>
<tr>
<td>operator bool()</td>
<td>unique_ptr 指针可直接作为 if 语句的判断条件，以判断该指针是否为空，如果为空，则为 false；反之为 true。</td>
</tr>
<tr>
<td>release()</td>
<td>释放当前 unique_ptr 指针对所指堆内存的所有权，但该存储空间并不会被销毁。</td>
</tr>
<tr>
<td>reset§</td>
<td>其中 p 表示一个普通指针，如果 p 为 nullptr，则当前 unique_ptr 也变成空指针；反之，则该函数会释放当前 unique_ptr 指针指向的堆内存（如果有），然后获取 p 所指堆内存的所有权（p 为 nullptr）。</td>
</tr>
<tr>
<td>swap(x)</td>
<td>交换当前 unique_ptr 指针和同类型的 x 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>除此之外，C++11标准还支持同类型的 unique_ptr 指针之间，以及 unique_ptr 和 nullptr 之间，做 &#x3D;&#x3D;，!&#x3D;，&lt;，&lt;&#x3D;，&gt;，&gt;&#x3D; 运算。</p>
</blockquote>
<p>下面程序给大家演示了 unique_ptr 智能指针的基本用法，以及该模板类提供了一些成员方法的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line">    *p5 = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// p 接收 p5 释放的堆内存</span></span><br><span class="line">    <span class="type">int</span> * p = p<span class="number">5.</span><span class="built_in">release</span>();</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//判断 p5 是否为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (p5) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p5 is not nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;p5 is nullptr&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    std::unique_ptr&lt;<span class="type">int</span>&gt; p6;</span><br><span class="line">    <span class="comment">//p6 获取 p 的所有权</span></span><br><span class="line">    p<span class="number">6.</span><span class="built_in">reset</span>(p);</span><br><span class="line">    cout &lt;&lt; *p6 &lt;&lt; endl;;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>10<br>p5 is nullptr<br>10</p>
<h2 id="C-11-weak-ptr智能指针"><a href="#C-11-weak-ptr智能指针" class="headerlink" title="C++11 weak_ptr智能指针"></a>C++11 weak_ptr智能指针</h2><p>在 C++98&#x2F;03 的基础上，C++11 标准新引入了 shared_ptr、unique_ptr 以及 weak_ptr 这 3 个智能指针。其中，shared_ptr 和 unique_ptr 已经在前面章节做了详细地介绍，本节重点讲解 weak_ptr 智能指针的特性和用法。</p>
<blockquote>
<p>注意学习 weak_ptr 智能指针之前，读者必须对 shared_ptr 智能指针有一定的了解，可阅读《<a href="http://c.biancheng.net/view/7898.html">C++11 shared_ptr智能指针</a>》一节；关于 unique_ptr 指针，读者可阅读《<a href="http://c.biancheng.net/view/vip_8672.html">C++11 unique_ptr智能指针</a>》一节做系统学习。</p>
</blockquote>
<h3 id="C-11-weak-ptr智能指针-1"><a href="#C-11-weak-ptr智能指针-1" class="headerlink" title="C++11 weak_ptr智能指针"></a>C++11 weak_ptr智能指针</h3><p>和 shared_ptr、unique_ptr 类型指针一样，weak_ptr 智能指针也是以模板类的方式实现的。weak_ptr（ T 为指针所指数据的类型）定义在<code>&lt;memory&gt;</code>头文件，并位于 std 命名空间中。因此，要想使用 weak_ptr 类型指针，程序中应首先包含如下 2 条语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>第 2 句并不是必须的，可以不添加，则后续在使用 unique_ptr 指针时，必须标注<code>std::</code>。</p>
</blockquote>
<p>需要注意的是，C++11标准虽然将 weak_ptr 定位为智能指针的一种，但该类型指针通常不单独使用（没有实际用处），只能和 shared_ptr 类型指针搭配使用。甚至于，我们可以将 weak_ptr 类型指针视为 shared_ptr 指针的一种辅助工具，借助 weak_ptr 类型指针， 我们可以获取 shared_ptr 指针的一些状态信息，比如有多少指向相同的 shared_ptr 指针、shared_ptr 指针指向的堆内存是否已经被释放等等。</p>
<p>需要注意的是，当 weak_ptr 类型指针的指向和某一 shared_ptr 指针相同时，weak_ptr 指针并不会使所指堆内存的引用计数加 1；同样，当 weak_ptr 指针被释放时，之前所指堆内存的引用计数也不会因此而减 1。也就是说，weak_ptr 类型指针并不会影响所指堆内存空间的引用计数。</p>
<p>除此之外，weak_ptr 模板类中没有重载 * 和 -&gt; 运算符，这也就意味着，weak_ptr 类型指针只能访问所指的堆内存，而无法修改它。</p>
<h4 id="1、weak-ptr指针的创建"><a href="#1、weak-ptr指针的创建" class="headerlink" title="1、weak_ptr指针的创建"></a>1、weak_ptr指针的创建</h4><p>创建一个 weak_ptr 指针，有以下 3 种方式：</p>
<ol>
<li>可以创建一个空 weak_ptr 指针，例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::weak_ptr&lt;<span class="type">int</span>&gt; wp1;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>凭借已有的 weak_ptr 指针，可以创建一个新的 weak_ptr 指针，例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp2</span> <span class="params">(wp1)</span></span>;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>若 wp1 为空指针，则 wp2 也为空指针；反之，如果 wp1 指向某一 shared_ptr 指针拥有的堆内存，则 wp2 也指向该块存储空间（可以访问，但无所有权）。</p>
<ol start="3">
<li>weak_ptr 指针更常用于指向某一 shared_ptr 指针拥有的堆内存，因为在构建 weak_ptr 指针对象时，可以利用已有的 shared_ptr 指针为其初始化。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span> <span class="params">(<span class="keyword">new</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp3</span> <span class="params">(sp)</span></span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<p>由此，wp3 指针和 sp 指针有相同的指针。再次强调，weak_ptr 类型指针不会导致堆内存空间的引用计数增加或减少。</p>
<h4 id="2-weak-ptr模板类提供的成员方法"><a href="#2-weak-ptr模板类提供的成员方法" class="headerlink" title="2) weak_ptr模板类提供的成员方法"></a>2) weak_ptr模板类提供的成员方法</h4><p>和 shared_ptr、unique_ptr 相比，weak_ptr 模板类提供的成员方法不多，表 1 罗列了常用的成员方法及各自的功能。</p>
<table>
<thead>
<tr>
<th>成员方法</th>
<th>功 能</th>
</tr>
</thead>
<tbody><tr>
<td>operator&#x3D;()</td>
<td>重载 &#x3D; 赋值运算符，是的 weak_ptr 指针可以直接被 weak_ptr 或者 shared_ptr 类型指针赋值。</td>
</tr>
<tr>
<td>swap(x)</td>
<td>其中 x 表示一个同类型的 weak_ptr 类型指针，该函数可以互换 2 个同类型 weak_ptr 指针的内容。</td>
</tr>
<tr>
<td>reset()</td>
<td>将当前 weak_ptr 指针置为空指针。</td>
</tr>
<tr>
<td>use_count()</td>
<td>查看指向和当前 weak_ptr 指针相同的 shared_ptr 指针的数量。</td>
</tr>
<tr>
<td>expired()</td>
<td>判断当前 weak_ptr 指针为否过期（指针为空，或者指向的堆内存已经被释放）。</td>
</tr>
<tr>
<td>lock()</td>
<td>如果当前 weak_ptr 已经过期，则该函数会返回一个空的 shared_ptr 指针；反之，该函数返回一个和当前 weak_ptr 指向相同的 shared_ptr 指针。</td>
</tr>
</tbody></table>
<blockquote>
<p>再次强调，weak_ptr 模板类没有重载 * 和 -&gt; 运算符，因此 weak_ptr 类型指针只能访问某一 shared_ptr 指针指向的堆内存空间，无法对其进行修改。</p>
</blockquote>
<p>下面的样例演示了 weak_ptr 指针以及表 1 中部分成员方法的基本用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp2</span><span class="params">(sp1)</span></span>;</span><br><span class="line">    <span class="function">std::weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(sp2)</span></span>;</span><br><span class="line">    <span class="comment">//输出和 wp 同指向的 shared_ptr 类型指针的数量</span></span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//释放 sp2</span></span><br><span class="line">    sp<span class="number">2.</span><span class="built_in">reset</span>();</span><br><span class="line">    cout &lt;&lt; wp.<span class="built_in">use_count</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="comment">//借助 lock() 函数，返回一个和 wp 同指向的 shared_ptr 类型指针，获取其存储的数据</span></span><br><span class="line">    cout &lt;&lt; *(wp.<span class="built_in">lock</span>()) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>2<br>1<br>10</p>
<blockquote>
<p>有关表 1 中其它成员函数的用法，感兴趣的读者可直接查看 <a href="http://www.cplusplus.com/reference/memory/weak_ptr/">weak_ptr 官网</a>。</p>
</blockquote>
<h2 id="C-14-新特性总结"><a href="#C-14-新特性总结" class="headerlink" title="C++14 新特性总结"></a>C++14 新特性总结</h2><h3 id="函数返回值类型推导"><a href="#函数返回值类型推导" class="headerlink" title="函数返回值类型推导"></a>函数返回值类型推导</h3><p>C++14对函数返回类型推导规则做了优化，先看一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<p>使用C++11编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~/test$ g++ test.cc -std=c+<span class="number">+11</span></span><br><span class="line">test.cc:<span class="number">5</span>:<span class="number">16</span>: error: ‘func’ function uses ‘<span class="keyword">auto</span>’ type specifier without trailing <span class="keyword">return</span> type</span><br><span class="line"> <span class="keyword">auto</span> <span class="built_in">func</span>(<span class="type">int</span> i) &#123;</span><br><span class="line">                ^</span><br><span class="line">test.cc:<span class="number">5</span>:<span class="number">16</span>: note: deduced <span class="keyword">return</span> type only available with -std=c+<span class="number">+14</span> <span class="keyword">or</span> -std=gnu+<span class="number">+14</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>上面的代码使用C++11是不能通过编译的，通过编译器输出的信息也可以看见这个特性需要到C++14才被支持。</p>
<p>返回值类型推导也可以用在模板中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">auto</span> <span class="title">func</span><span class="params">(T t)</span> </span>&#123; <span class="keyword">return</span> t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">func</span>(<span class="number">3.4</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：</p>
<p>）函数内如果有多个return语句，它们必须返回相同的类型，否则编译失败。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">bool</span> flag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">2.3</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// inconsistent deduction for auto return tags: ‘int’ and then ‘double’</span></span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<p>）如果return语句返回初始化列表，返回值类型推导也会失败</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// error returning initializer list</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>) 如果函数是虚函数，不能使用返回值类型推导</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="comment">// error: virtual function cannot have deduced return type</span></span><br><span class="line">    virtual <span class="keyword">auto</span> <span class="title function_">func</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>） 返回类型推导可以用在前向声明中，但是在使用它们之前，翻译单元中必须能够得到函数定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="title function_">f</span><span class="params">()</span>;               <span class="comment">// declared, not yet defined</span></span><br><span class="line"><span class="keyword">auto</span> <span class="title function_">f</span><span class="params">()</span> &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125; <span class="comment">// defined, return type is int</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>）返回类型推导可以用在递归函数中，但是递归调用必须以至少一个返回语句作为先导，以便编译器推导出返回类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> i;              <span class="comment">// return int</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> sum(i - <span class="number">1</span>) + i; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h3 id="lambda参数auto"><a href="#lambda参数auto" class="headerlink" title="lambda参数auto"></a>lambda参数auto</h3><p>在C++11中，lambda表达式参数需要使用具体的类型声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] (<span class="type">int</span> a) &#123; <span class="keyword">return</span> a; &#125;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>在C++14中，对此进行优化，lambda表达式参数可以直接是auto：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] (<span class="keyword">auto</span> a) &#123; <span class="keyword">return</span> a; &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f(<span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f(<span class="number">2.3f</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h3 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h3><p>C++14支持变量模板：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">constexpr</span> T pi = <span class="built_in">T</span>(<span class="number">3.1415926535897932385L</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">int</span>&gt; &lt;&lt; endl; <span class="comment">// 3</span></span><br><span class="line">    cout &lt;&lt; pi&lt;<span class="type">double</span>&gt; &lt;&lt; endl; <span class="comment">// 3.14159</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<h3 id="别名模板"><a href="#别名模板" class="headerlink" title="别名模板"></a>别名模板</h3><p>C++14也支持别名模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    T t;</span><br><span class="line">    U u;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> B = A&lt;T, <span class="type">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    B&lt;<span class="type">double</span>&gt; b;</span><br><span class="line">    b.t = <span class="number">10</span>;</span><br><span class="line">    b.u = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; b.t &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; b.u &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<h3 id="constexpr的限制"><a href="#constexpr的限制" class="headerlink" title="constexpr的限制"></a>constexpr的限制</h3><p>C++14相较于C++11对constexpr减少了一些限制：</p>
<p>）C++11中constexpr函数可以使用递归，在C++14中可以使用局部变量和循环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="comment">// C++14 和 C++11均可</span></span><br><span class="line">    <span class="keyword">return</span> n &lt;= <span class="number">1</span> ? <span class="number">1</span> : (n * <span class="built_in">factorial</span>(n - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>在C++14中可以这样做：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; <span class="comment">// C++11中不可，C++14中可以</span></span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        ret += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>）C++11中constexpr函数必须必须把所有东西都放在一个单独的return语句中，而constexpr则无此限制：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">bool</span> flag)</span> </span>&#123; <span class="comment">// C++14 和 C++11均可</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>在C++14中可以这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">func</span><span class="params">(<span class="type">bool</span> flag)</span> </span>&#123; <span class="comment">// C++11中不可，C++14中可以</span></span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h3 id="deprecated-标记"><a href="#deprecated-标记" class="headerlink" title="[[deprecated]]标记"></a>[[<code>deprecated</code>]]标记</h3><p>C++14中增加了deprecated标记，修饰类、变、函数等，当程序中使用到了被其修饰的代码时，编译时被产生警告，用户提示开发者该标记修饰的内容将来可能会被丢弃，尽量不要使用。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> [[deprecated]] A &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>当编译时，会出现如下警告：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~/test$ g++ test.cc -std=c+<span class="number">+14</span></span><br><span class="line">test.cc: In function ‘<span class="type">int</span> <span class="built_in">main</span>()’:</span><br><span class="line">test.cc:<span class="number">11</span>:<span class="number">7</span>: warning: ‘A’ is deprecated [-Wdeprecated-declarations]</span><br><span class="line">     A a;</span><br><span class="line">       ^</span><br><span class="line">test.cc:<span class="number">6</span>:<span class="number">23</span>: note: declared here</span><br><span class="line"> <span class="keyword">struct</span> [[deprecated]] A &#123;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<h3 id="二进制字面量与整形字面量分隔符"><a href="#二进制字面量与整形字面量分隔符" class="headerlink" title="二进制字面量与整形字面量分隔符"></a>二进制字面量与整形字面量分隔符</h3><p>C++14引入了二进制字面量，也引入了分隔符，防止看起来眼花哈~</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0b0001&#x27;0011&#x27;1010</span>;</span><br><span class="line"><span class="type">double</span> b = <span class="number">3.14&#x27;1234&#x27;1234&#x27;1234</span>;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="std-make-unique"><a href="#std-make-unique" class="headerlink" title="std::make_unique"></a>std::make_unique</h3><p>我们都知道C++11中有std::make_shared，却没有std::make_unique，在C++14已经改善。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line">std::unique_ptr&lt;A&gt; ptr = std::<span class="built_in">make_unique</span>&lt;A&gt;();</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="std-shared-timed-mutex与std-shared-lock"><a href="#std-shared-timed-mutex与std-shared-lock" class="headerlink" title="std::shared_timed_mutex与std::shared_lock"></a>std::shared_timed_mutex与std::shared_lock</h3><p>C++14通过std::shared_timed_mutex和std::shared_lock来实现读写锁，保证多个线程可以同时读，但是写线程必须独立运行，写操作不可以同时和读操作一起进行。</p>
<p>实现方式如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ThreadSafe</span> &#123;</span><br><span class="line">    <span class="keyword">mutable</span> std::shared_timed_mutex mutex_;</span><br><span class="line">    <span class="type">int</span> value_;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">ThreadSafe</span>() &#123;</span><br><span class="line">        value_ = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="function">std::shared_lock&lt;std::shared_timed_mutex&gt; <span class="title">loc</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">std::unique_lock&lt;std::shared_timed_mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        value_ += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>为什么是timed的锁呢，因为可以带超时时间，具体可以自行查询相关资料哈，网上有很多。</p>
<h3 id="std-integer-sequence"><a href="#std-integer-sequence" class="headerlink" title="std::integer_sequence"></a>std::integer_sequence</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T... ints&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print_sequence</span><span class="params">(std::integer_sequence&lt;T, ints...&gt; int_seq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The sequence of size &quot;</span> &lt;&lt; int_seq.<span class="built_in">size</span>() &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    ((std::cout &lt;&lt; ints &lt;&lt; <span class="string">&#x27; &#x27;</span>), ...);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print_sequence</span>(std::integer_sequence&lt;<span class="type">int</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">6</span>&gt;&#123;&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出：<span class="number">7</span> <span class="number">9</span> <span class="number">2</span> <span class="number">5</span> <span class="number">1</span> <span class="number">9</span> <span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p>std::integer_sequence和std::tuple的配合使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span>... Is, <span class="keyword">typename</span> F, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">map_filter_tuple</span><span class="params">(F f, T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="built_in">f</span>(std::<span class="built_in">get</span>&lt;Is&gt;(t))...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;std::<span class="type">size_t</span>... Is, <span class="keyword">typename</span> F, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">map_filter_tuple</span><span class="params">(std::index_sequence&lt;Is...&gt;, F f, T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="built_in">f</span>(std::<span class="built_in">get</span>&lt;Is&gt;(t))...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> S, <span class="keyword">typename</span> F, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">map_filter_tuple</span><span class="params">(F&amp;&amp; f, T&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">map_filter_tuple</span>(S&#123;&#125;, std::forward&lt;F&gt;(f), t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<h3 id="std-exchange"><a href="#std-exchange" class="headerlink" title="std::exchange"></a>std::exchange</h3><p>直接看代码吧：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">std</span>::exchange(v, &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> a : v) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<p>看样子貌似和std::swap作用相同，那它俩有什么区别呢？</p>
<p>可以看下exchange的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> U </span>= T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">exchange</span><span class="params">(T&amp; obj, U&amp;&amp; new_value)</span> </span>&#123;</span><br><span class="line">    T old_value = std::<span class="built_in">move</span>(obj);</span><br><span class="line">    obj = std::forward&lt;U&gt;(new_value);</span><br><span class="line">    <span class="keyword">return</span> old_value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>可以看见new_value的值给了obj，而没有对new_value赋值，这里相信您已经知道了它和swap的区别了吧！</p>
<h3 id="std-quoted"><a href="#std-quoted" class="headerlink" title="std::quoted"></a>std::quoted</h3><p>C++14引入std::quoted用于给字符串添加双引号，直接看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; std::<span class="built_in">quoted</span>(str) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>编译&amp;输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">~/test$ g++ test.cc -std=c+<span class="number">+14</span></span><br><span class="line">~/test$ ./a.out</span><br><span class="line">hello world</span><br><span class="line"><span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h2 id="C-17新特性总结"><a href="#C-17新特性总结" class="headerlink" title="C++17新特性总结"></a>C++17新特性总结</h2><p>主要新特性如下：</p>
<ul>
<li>构造函数模板推导</li>
<li>结构化绑定</li>
<li>if-switch语句初始化</li>
<li>内联变量</li>
<li>折叠表达式</li>
<li>constexpr lambda表达式</li>
<li>namespace嵌套</li>
<li>__has_include预处理表达式</li>
<li>在lambda表达式用*this捕获对象副本</li>
<li>新增Attribute</li>
<li>字符串转换</li>
<li>std::variant</li>
<li>std::optional</li>
<li>std::any</li>
<li>std::apply</li>
<li>std::make_from_tuple</li>
<li>as_const</li>
<li>std::string_view</li>
<li>file_system</li>
<li>std::shared_mutex</li>
</ul>
<p>下面程序喵一一介绍：</p>
<h3 id="构造函数模板推导"><a href="#构造函数模板推导" class="headerlink" title="构造函数模板推导"></a>构造函数模板推导</h3><p>在C++17前构造一个模板类对象需要指明类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title function_">p</span><span class="params">(<span class="number">1</span>, <span class="number">2.2</span>)</span>; <span class="comment">// before c++17</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>C++17就不需要特殊指定，直接可以推导出类型，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">pair</span> <span class="title function_">p</span><span class="params">(<span class="number">1</span>, <span class="number">2.2</span>)</span>; <span class="comment">// c++17 自动推导</span></span><br><span class="line"><span class="built_in">vector</span> v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// c++17</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="结构化绑定"><a href="#结构化绑定" class="headerlink" title="结构化绑定"></a>结构化绑定</h3><p>通过结构化绑定，对于tuple、map等类型，获取相应值会方便很多，看代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::tuple&lt;<span class="type">int</span>, <span class="type">double</span>&gt; <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::tuple(<span class="number">1</span>, <span class="number">2.2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">auto</span>[i, d] = func(); <span class="comment">//是C++11的tie吗？更高级</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//==========================</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">f</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="type">int</span>, <span class="built_in">string</span>&gt; m = &#123;</span><br><span class="line">      &#123;<span class="number">0</span>, <span class="string">&quot;a&quot;</span>&#125;,</span><br><span class="line">      &#123;<span class="number">1</span>, <span class="string">&quot;b&quot;</span>&#125;,  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;[i, s] : m) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ====================</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span> <span class="title function_">a</span><span class="params">(<span class="number">1</span>, <span class="number">2.3f</span>)</span>;</span><br><span class="line">    <span class="keyword">auto</span>[i, f] = a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; f &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 2.3f</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617181920212223242526272829</span></span><br></pre></td></tr></table></figure>

<p>结构化绑定还可以改变对象的值，使用引用即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 进化，可以通过结构化绑定改变对象的值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">pair</span> <span class="title function_">a</span><span class="params">(<span class="number">1</span>, <span class="number">2.3f</span>)</span>;</span><br><span class="line">    <span class="keyword">auto</span>&amp; [i, f] = a;</span><br><span class="line">    i = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a.first &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 2 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p><em>注意结构化绑定不能应用于constexpr</em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">constexpr</span> <span class="keyword">auto</span>[x, y] = <span class="built_in">std</span>::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2.3f</span>); <span class="comment">// compile error, C++20可以</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>结构化绑定不止可以绑定pair和tuple，还可以绑定数组和结构体等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> array[<span class="number">3</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> [a, b, c] = array;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意这里的struct的成员一定要是public的</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">Point <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="keyword">auto</span> [x, y] = <span class="built_in">func</span>();</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<p>这里其实可以实现自定义类的结构化绑定，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要实现相关的tuple_size和tuple_element和get&lt;N&gt;方法。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Entry</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        name_ = <span class="string">&quot;name&quot;</span>;</span><br><span class="line">        age_ = <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string <span class="title">GetName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name_; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">GetAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age_; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name_;</span><br><span class="line">    <span class="type">int</span> age_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="type">size_t</span> I&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="type">const</span> Entry&amp; e)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(I == <span class="number">0</span>)</span> <span class="keyword">return</span> e.<span class="title">GetName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">constexpr</span> (I == <span class="number">1</span>) <span class="keyword">return</span> e.<span class="built_in">GetAge</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> std &#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_size</span>&lt;Entry&gt; : integral_constant&lt;<span class="type">size_t</span>, <span class="number">2</span>&gt; &#123;&#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">0</span>, Entry&gt; &#123; <span class="keyword">using</span> type = std::string; &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt; <span class="keyword">struct</span> <span class="title class_">tuple_element</span>&lt;<span class="number">1</span>, Entry&gt; &#123; <span class="keyword">using</span> type = <span class="type">int</span>; &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry e;</span><br><span class="line">    e.<span class="built_in">Init</span>();</span><br><span class="line">    <span class="keyword">auto</span> [name, age] = e;</span><br><span class="line">    cout &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; age &lt;&lt; endl; <span class="comment">// name 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure>

<h3 id="if-switch语句初始化"><a href="#if-switch语句初始化" class="headerlink" title="if-switch语句初始化"></a>if-switch语句初始化</h3><p>C++17前if语句需要这样写代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="built_in">GetValue</span>();</span><br><span class="line"><span class="keyword">if</span> (a &lt; <span class="number">101</span>) &#123;</span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>C++17之后可以这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// if (init; condition)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="type">int</span> a = <span class="built_in">GetValue</span>()); a &lt; <span class="number">101</span>) &#123;</span><br><span class="line">    cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string str = <span class="string">&quot;Hi World&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> [pos, size] = <span class="built_in">pair</span>(str.<span class="built_in">find</span>(<span class="string">&quot;Hi&quot;</span>), str.<span class="built_in">size</span>()); pos != string::npos) &#123;</span><br><span class="line">    std::cout &lt;&lt; pos &lt;&lt; <span class="string">&quot; Hello, size is &quot;</span> &lt;&lt; size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>使用这种方式可以尽可能约束作用域，让代码更简洁，可读性可能略有下降，但是还好</p>
<h3 id="内联变量"><a href="#内联变量" class="headerlink" title="内联变量"></a>内联变量</h3><p>C++17前只有内联函数，现在有了内联变量，我们印象中C++类的静态成员变量在头文件中是不能初始化的，但是有了内联变量，就可以达到此目的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// header file</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> <span class="type">int</span> <span class="type">const</span> A::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==========或者========</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="keyword">inline</span> <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<h3 id="折叠表达式"><a href="#折叠表达式" class="headerlink" title="折叠表达式"></a>折叠表达式</h3><p>C++17引入了折叠表达式使可变参数模板编程更方便：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">sum</span><span class="params">(Ts ... ts)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ts + ...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a &#123;<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)&#125;; <span class="comment">// 15</span></span><br><span class="line">std::string a&#123;<span class="string">&quot;hello &quot;</span>&#125;;</span><br><span class="line">std::string b&#123;<span class="string">&quot;world&quot;</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sum</span>(a, b) &lt;&lt; endl; <span class="comment">// hello world</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<h3 id="constexpr-lambda表达式"><a href="#constexpr-lambda表达式" class="headerlink" title="constexpr lambda表达式"></a>constexpr lambda表达式</h3><p>C++17前lambda表达式只能在运行时使用，C++17引入了constexpr lambda表达式，可以用于在编译期进行计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// c++17可编译</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> lamb = [] (<span class="type">int</span> n) &#123; <span class="keyword">return</span> n * n; &#125;;</span><br><span class="line">    <span class="built_in">static_assert</span>(<span class="built_in">lamb</span>(<span class="number">3</span>) == <span class="number">9</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>注意：constexpr函数有如下限制：</p>
<p>函数体不能包含汇编语句、goto语句、label、try块、静态变量、线程局部存储、没有初始化的普通变量，不能动态分配内存，不能有new delete等，不能虚函数。</p>
<h3 id="namespace嵌套"><a href="#namespace嵌套" class="headerlink" title="namespace嵌套"></a>namespace嵌套</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">    <span class="keyword">namespace</span> B &#123;</span><br><span class="line">        <span class="keyword">namespace</span> C &#123;</span><br><span class="line">            <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// c++17，更方便更舒适</span></span><br><span class="line"><span class="keyword">namespace</span> A::B::C &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<h3 id="has-include预处理表达式"><a href="#has-include预处理表达式" class="headerlink" title="__has_include预处理表达式"></a>__has_include预处理表达式</h3><p>可以判断是否有某个头文件，代码可能会在不同编译器下工作，不同编译器的可用头文件有可能不同，所以可以使用此来判断：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined __has_include</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __has_include(<span class="string">&lt;charconv&gt;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> has_charconv 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;charconv&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">ConvertToInt</span><span class="params">(<span class="type">const</span> std::string&amp; str)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value&#123;&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> has_charconv</span></span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> last = str.<span class="built_in">data</span>() + str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> res = std::<span class="built_in">from_chars</span>(str.<span class="built_in">data</span>(), last, value);</span><br><span class="line">    <span class="keyword">if</span> (res.ec == std::errc&#123;&#125; &amp;&amp; res.ptr == last) <span class="keyword">return</span> value;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// alternative implementation...</span></span><br><span class="line">    其它方式实现</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516171819</span></span><br></pre></td></tr></table></figure>

<h3 id="在lambda表达式用-this捕获对象副本"><a href="#在lambda表达式用-this捕获对象副本" class="headerlink" title="在lambda表达式用*this捕获对象副本"></a>在lambda表达式用*this捕获对象副本</h3><p>正常情况下，lambda表达式中访问类的对象成员变量需要捕获this，但是这里捕获的是this指针，指向的是对象的引用，正常情况下可能没问题，但是如果多线程情况下，函数的作用域超过了对象的作用域，对象已经被析构了，还访问了成员变量，就会有问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> f = [<span class="keyword">this</span>] &#123;</span><br><span class="line">            cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<p>所以C++17增加了新特性，捕获*this，不持有this指针，而是持有对象的拷贝，这样生命周期就与对象的生命周期不相关啦。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> f = [*<span class="keyword">this</span>] &#123; <span class="comment">// 这里</span></span><br><span class="line">            cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="built_in">f</span>();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    A a;</span><br><span class="line">    a.<span class="built_in">func</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314</span></span><br></pre></td></tr></table></figure>

<h3 id="新增Attribute"><a href="#新增Attribute" class="headerlink" title="新增Attribute"></a>新增Attribute</h3><p>我们可能平时在项目中见过__declspec, <strong>attribute</strong> , #pragma指示符，使用它们来给编译器提供一些额外的信息，来产生一些优化或特定的代码，也可以给其它开发者一些提示信息。</p>
<p>例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">short</span> f[<span class="number">3</span>]; &#125; __attribute__((<span class="built_in">aligned</span>(<span class="number">8</span>)));</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fatal</span><span class="params">()</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>在C++11和C++14中有更方便的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[carries_dependency]] 让编译期跳过不必要的内存栅栏指令</span><br><span class="line">[[noreturn]] 函数不会返回</span><br><span class="line">[[deprecated]] 函数将弃用的警告</span><br><span class="line"></span><br><span class="line">[[noreturn]] <span class="function"><span class="type">void</span> <span class="title">terminate</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line">[[<span class="built_in">deprecated</span>(<span class="string">&quot;use new func instead&quot;</span>)]] <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>C++17又新增了三个：</p>
<p>[[fallthrough]]，用在switch中提示可以直接落下去，不需要break，让编译期忽略警告</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (i) &#123;&#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        xxx; <span class="comment">// warning</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        xxx; </span><br><span class="line">        [[fallthrough]];      <span class="comment">// 警告消除</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        xxx;</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<p>使得编译器和其它开发者都可以理解开发者的意图。</p>
<p>[[nodiscard]] ：表示修饰的内容不能被忽略，可用于修饰函数，标明返回值一定要被处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">[[nodiscard]] <span class="type">int</span> <span class="title function_">func</span><span class="params">()</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">F</span><span class="params">()</span> &#123;</span><br><span class="line">    func(); <span class="comment">// warning 没有处理函数返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>[[maybe_unused]] ：提示编译器修饰的内容可能暂时没有使用，避免产生警告</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">[[maybe_unused]] <span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;&#125; <span class="comment">// 警告消除</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func3</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">    [[maybe_unused]] <span class="type">int</span> y = <span class="number">2</span>; <span class="comment">// 警告消除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h3><p>新增from_chars函数和to_chars函数，直接看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;charconv&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> std::string str&#123;<span class="string">&quot;123456098&quot;</span>&#125;;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">auto</span> res = std::<span class="built_in">from_chars</span>(str.<span class="built_in">data</span>(), str.<span class="built_in">data</span>() + <span class="number">4</span>, value);</span><br><span class="line">    <span class="keyword">if</span> (res.ec == std::<span class="built_in">errc</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">&quot;, distance &quot;</span> &lt;&lt; res.ptr - str.<span class="built_in">data</span>() &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (res.ec == std::errc::invalid_argument) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;invalid&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    str = std::<span class="built_in">string</span>(<span class="string">&quot;12.34);</span></span><br><span class="line"><span class="string">    double val = 0;</span></span><br><span class="line"><span class="string">    const auto format = std::chars_format::general;</span></span><br><span class="line"><span class="string">    res = std::from_chars(str.data(), str.data() + str.size(), value, format);</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    str = std::string(&quot;</span>xxxxxxxx<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    const int v = 1234;</span></span><br><span class="line"><span class="string">    res = std::to_chars(str.data(), str.data() + str.size(), v);</span></span><br><span class="line"><span class="string">    cout &lt;&lt; str &lt;&lt; &quot;</span>, filled <span class="string">&quot; &lt;&lt; res.ptr - str.data() &lt;&lt; &quot;</span> characters \n<span class="string">&quot;;</span></span><br><span class="line"><span class="string">    // 1234xxxx, filled 4 characters</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">12345678910111213141516171819202122</span></span><br></pre></td></tr></table></figure>

<h3 id="std-variant"><a href="#std-variant" class="headerlink" title="std::variant"></a>std::variant</h3><p>C++17增加std::variant实现类似union的功能，但却比union更高级，举个例子union里面不能有string这种类型，但std::variant却可以，还可以支持更多复杂类型，如map等，看代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// c++17可编译</span></span><br><span class="line">    <span class="function">std::variant&lt;<span class="type">int</span>, std::string&gt; <span class="title">var</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; var.<span class="built_in">index</span>() &lt;&lt; endl;</span><br><span class="line">    var = <span class="number">123</span>;</span><br><span class="line">    cout &lt;&lt; var.<span class="built_in">index</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        std::string str = std::<span class="built_in">get</span>&lt;std::string&gt;(var); <span class="comment">// 通过类型获取值</span></span><br><span class="line">        var = <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> i = std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(var); <span class="comment">// 通过index获取对应值</span></span><br><span class="line">        cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="comment">// xxx;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718</span></span><br></pre></td></tr></table></figure>

<p>注意：一般情况下variant的第一个类型一般要有对应的构造函数，否则编译失败：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A(<span class="type">int</span> i)&#123;&#125;  </span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::variant&lt;A, <span class="type">int</span>&gt; var; <span class="comment">// 编译失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<p>如何避免这种情况呢，可以使用std::monostate来打个桩，模拟一个空状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::variant&lt;<span class="built_in">std</span>::monostate, A&gt; var; <span class="comment">// 可以编译成功</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h2 id="std-optional"><a href="#std-optional" class="headerlink" title="std::optional"></a>std::optional</h2><p>我们有时候可能会有需求，让函数返回一个对象，如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123;&#125;;</span><br><span class="line"><span class="function">A <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (flag) <span class="keyword">return</span> <span class="built_in">A</span>();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 异常情况下，怎么返回异常值呢，想返回个空呢</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<p>有一种办法是返回对象指针，异常情况下就可以返回nullptr啦，但是这就涉及到了内存管理，也许你会使用智能指针，但这里其实有更方便的办法就是std::optional。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::optional&lt;<span class="type">int</span>&gt; <span class="title">StoI</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">stoi</span>(s);</span><br><span class="line">    &#125; <span class="built_in">catch</span>(...) &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="literal">nullopt</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s&#123;<span class="string">&quot;123&quot;</span>&#125;;</span><br><span class="line">    std::optional&lt;<span class="type">int</span>&gt; o = <span class="built_in">StoI</span>(s);</span><br><span class="line">    <span class="keyword">if</span> (o) &#123;</span><br><span class="line">        cout &lt;&lt; *o &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;error&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011121314151617</span></span><br></pre></td></tr></table></figure>

<h3 id="std-any"><a href="#std-any" class="headerlink" title="std::any"></a>std::any</h3><p>C++17引入了any可以存储任何类型的单个值，见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; <span class="comment">// c++17可编译</span></span><br><span class="line">    std::any a = <span class="number">1</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">int</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    a = <span class="number">2.2f</span>;</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;<span class="type">float</span>&gt;(a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a.<span class="built_in">reset</span>();</span><br><span class="line">    <span class="keyword">if</span> (a.<span class="built_in">has_value</span>()) &#123;</span><br><span class="line">        cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    a = std::<span class="built_in">string</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    cout &lt;&lt; a.<span class="built_in">type</span>().<span class="built_in">name</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; std::<span class="built_in">any_cast</span>&lt;std::string&gt;(a) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213141516</span></span><br></pre></td></tr></table></figure>

<h3 id="std-apply"><a href="#std-apply" class="headerlink" title="std::apply"></a>std::apply</h3><p>使用std::apply可以将tuple展开作为函数的参数传入，见代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> first, <span class="type">int</span> second)</span> </span>&#123; <span class="keyword">return</span> first + second; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> add_lambda = [](<span class="keyword">auto</span> first, <span class="keyword">auto</span> second) &#123; <span class="keyword">return</span> first + second; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add, std::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">add</span>(std::<span class="built_in">pair</span>(<span class="number">1</span>, <span class="number">2</span>)) &lt;&lt; <span class="string">&quot;\n&quot;</span>; <span class="comment">// error</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">apply</span>(add_lambda, std::<span class="built_in">tuple</span>(<span class="number">2.0f</span>, <span class="number">3.0f</span>)) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<h3 id="std-make-from-tuple"><a href="#std-make-from-tuple" class="headerlink" title="std::make_from_tuple"></a>std::make_from_tuple</h3><p>使用make_from_tuple可以将tuple展开作为构造函数参数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123;</span><br><span class="line">    <span class="built_in">Foo</span>(<span class="type">int</span> first, <span class="type">float</span> second, <span class="type">int</span> third) &#123;</span><br><span class="line">        std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; second &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; third &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">auto</span> tuple = std::<span class="built_in">make_tuple</span>(<span class="number">42</span>, <span class="number">3.14f</span>, <span class="number">0</span>);</span><br><span class="line">   std::<span class="built_in">make_from_tuple</span>&lt;Foo&gt;(std::<span class="built_in">move</span>(tuple));</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<h3 id="std-string-view"><a href="#std-string-view" class="headerlink" title="std::string_view"></a>std::string_view</h3><p>通常我们传递一个string时会触发对象的拷贝操作，大字符串的拷贝赋值操作会触发堆内存分配，很影响运行效率，有了string_view就可以避免拷贝操作，平时传递过程中传递string_view即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(std::string_view stv)</span> </span>&#123; cout &lt;&lt; stv &lt;&lt; endl; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::string str = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::string_view <span class="title">stv</span><span class="params">(str.c_str(), str.size())</span></span>;</span><br><span class="line">    cout &lt;&lt; stv &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">func</span>(stv);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567891011</span></span><br></pre></td></tr></table></figure>

<h3 id="as-const"><a href="#as-const" class="headerlink" title="as_const"></a>as_const</h3><p>C++17使用as_const可以将左值转成const类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;str&quot;</span>;</span><br><span class="line"><span class="type">const</span> std::string&amp; constStr = std::<span class="built_in">as_const</span>(str);</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h3 id="file-system"><a href="#file-system" class="headerlink" title="file_system"></a>file_system</h3><p>C++17正式将file_system纳入标准中，提供了关于文件的大多数功能，基本上应有尽有，这里简单举几个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> fs = std::filesystem;</span><br><span class="line">fs::<span class="built_in">create_directory</span>(dir_path);</span><br><span class="line">fs::<span class="built_in">copy_file</span>(src, dst, fs::copy_options::skip_existing);</span><br><span class="line">fs::<span class="built_in">exists</span>(filename);</span><br><span class="line">fs::<span class="built_in">current_path</span>(err_code);</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h3 id="std-shared-mutex"><a href="#std-shared-mutex" class="headerlink" title="std::shared_mutex"></a>std::shared_mutex</h3><p>C++17引入了shared_mutex，可以实现读写锁</p>
<h2 id="C-20-新增特性总结"><a href="#C-20-新增特性总结" class="headerlink" title="C++20 新增特性总结"></a>C++20 新增特性总结</h2><ul>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E6%96%B0%E5%A2%9E%E5%85%B3%E9%94%AE%E5%AD%97keywords">新增关键字(keywords)</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E6%96%B0%E5%A2%9E%E6%A0%87%E8%AF%86%E7%AC%A6identifies">新增标识符(Identifies)</a></p>
</li>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E6%A8%A1%E5%9D%97modules">模块(Modules)</a></p>
</li>
<li><ul>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E4%BC%98%E7%82%B9">优点</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%9D%97">创建模块</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E5%BC%95%E7%94%A8%E6%A8%A1%E5%9D%97">引用模块</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23import-%E5%A4%B4%E6%96%87%E4%BB%B6">import 头文件</a></li>
</ul>
</li>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23ranges">Ranges</a></p>
</li>
<li><ul>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E4%BE%8B%E5%AD%90">例子</a></li>
</ul>
</li>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E5%8D%8F%E7%A8%8Bcoroutines">协程(Coroutines)</a></p>
</li>
<li><ul>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E7%A8%8B">什么是协程</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E4%BE%8B%E5%AD%90vc">例子(VC++)</a></li>
</ul>
</li>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23concepts">Concepts</a></p>
</li>
<li><ul>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E5%A6%82%E4%BD%95%E5%AE%9A%E4%B9%89">如何定义</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E4%BD%BF%E7%94%A8">使用</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E4%BE%8B%E5%AD%90-1">例子</a></li>
</ul>
</li>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9B%B4%E6%96%B0">Lambda 表达式的更新</a></p>
</li>
<li><ul>
<li>[<a href="https://link.zhihu.com/?target=http://%3Ccode%3Ejimm%3C/code%3Eysue.me/c-20-features/%23-this-%E9%9C%80%E8%A6%81%E6%98%BE%E5%BC%8F%E6%8D%95%E8%8E%B7this%E5%8F%98%E9%87%8F">=, this] 需要显式捕获this变量</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%BC%8F%E7%9A%84-lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F">模板形式的 Lambda 表达式</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23lambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%89%93%E5%8C%85%E6%8D%95%E8%8E%B7pack-expansion">Lambda 表达式打包捕获(Pack Expansion)</a></li>
</ul>
</li>
<li><p>常量表达式(constexpr) 的更新</p>
</li>
<li><ul>
<li><code>constexpr string &amp; vector</code></li>
</ul>
</li>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E5%8E%9F%E5%AD%90atomic%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88">原子(Atomic)智能指针</a></p>
</li>
<li><ul>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E4%BE%8B%E5%AD%90-2">例子</a></li>
</ul>
</li>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E8%87%AA%E5%8A%A8%E5%90%88%E6%B5%81joining-%E5%8F%AF%E4%B8%AD%E6%96%ADcancellable-%E7%9A%84%E7%BA%BF%E7%A8%8B">自动合流(Joining), 可中断(Cancellable) 的线程</a></p>
</li>
<li><ul>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E4%BE%8B%E5%AD%90-3">例子</a></li>
</ul>
</li>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23c20-%E5%90%8C%E6%AD%A5synchronization%E5%BA%93">C++20 同步(Synchronization)库</a></p>
</li>
<li><ul>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23stdatomic_ref">std::atomic_ref</a></li>
</ul>
</li>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E5%85%B6%E4%BB%96%E6%9B%B4%E6%96%B0">其他更新</a></p>
</li>
<li><ul>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E6%8C%87%E5%AE%9A%E5%88%9D%E5%A7%8B%E5%8C%96designated-initializers">指定初始化(Designated Initializers)</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E8%88%AA%E5%A4%A9%E9%A3%9E%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%AC%A6-">航天飞机操作符 &lt;&#x3D;&gt;</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E8%8C%83%E5%9B%B4-for-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E6%94%AF%E6%8C%81%E5%88%9D%E5%A7%8B%E5%8C%96">范围 for 循环语句支持初始化</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E9%9D%9E%E7%B1%BB%E5%9E%8B%E6%A8%A1%E6%9D%BF%E5%BD%A2%E5%8F%82%E6%94%AF%E6%8C%81%E5%AD%97%E7%AC%A6%E4%B8%B2">非类型模板形参支持字符串</a></li>
<li>[<a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23likely-unlikely">[likely]], [[unlikely]]</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E6%97%A5%E5%8E%86calendar%E5%92%8C%E6%97%B6%E5%8C%BAtimezone%E5%8A%9F%E8%83%BD">日历(Calendar)和时区(Timezone)功能</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23stdspan">std::span</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E7%89%B9%E6%80%A7%E6%B5%8B%E8%AF%95%E5%AE%8F">特性测试宏</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23version"></a></li>
<li><code>consteval 函数</code></li>
<li><code>constinit</code></li>
<li>用 using 引用 enum 类型</li>
<li>格式化库(std::format)</li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E5%A2%9E%E5%8A%A0%E6%95%B0%E5%AD%A6%E5%B8%B8%E9%87%8F">增加数学常量</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23stdsource_location">std::source_location</a></li>
<li>[<a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23nodiscardreason">[nodiscard(reason)]]</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E4%BD%8D%E8%BF%90%E7%AE%97">位运算</a></li>
<li><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%9B%B4%E6%96%B0">一些小更新</a></li>
</ul>
</li>
<li><p><a href="https://link.zhihu.com/?target=http://jimmysue.me/c-20-features/%23%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</a></p>
</li>
</ul>
<hr>
<h3 id="新增关键字-keywords"><a href="#新增关键字-keywords" class="headerlink" title="新增关键字(keywords)"></a>新增关键字(keywords)</h3><ul>
<li>concept</li>
<li>requires</li>
<li>constinit</li>
<li>consteval</li>
<li>co_await</li>
<li>co_return</li>
<li>co_yield</li>
<li>char8_t</li>
</ul>
<h3 id="新增标识符-Identifies"><a href="#新增标识符-Identifies" class="headerlink" title="新增标识符(Identifies)"></a>新增标识符(Identifies)</h3><ul>
<li>import</li>
<li>module</li>
</ul>
<h3 id="模块-Modules"><a href="#模块-Modules" class="headerlink" title="模块(Modules)"></a>模块(Modules)</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>没有头文件</li>
<li>声明实现仍然可分离, 但非必要</li>
<li>可以<strong>显式</strong>指定那些导出(类, 函数等)</li>
<li>不需要头文件重复引入宏 (include guards)</li>
<li>模块之间名称可以相同不会冲突</li>
<li>模块只处理一次, 编译更快 (<em>头文件每次引入都需要处理</em>)</li>
<li>预处理宏只在模块内有效</li>
<li>模块引入顺序无关紧要</li>
</ul>
<h4 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cppcon.cpp </span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">module</span> cppcon; </span><br><span class="line"><span class="keyword">namespace</span> CppCon &#123; </span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">GetWelcomeHelper</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> <span class="string">&quot;Welcome to CppCon 2019!&quot;</span>;  &#125; </span><br><span class="line">    <span class="function"><span class="keyword">export</span> <span class="keyword">auto</span> <span class="title">GetWelcome</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">GetWelcomeHelper</span>();&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h4 id="引用模块"><a href="#引用模块" class="headerlink" title="引用模块"></a>引用模块</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// main.cpp </span></span><br><span class="line"><span class="keyword">import</span> cppcon; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    std::cout &lt;&lt; CppCon::<span class="built_in">GetWelcome</span>(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h4 id="import-头文件"><a href="#import-头文件" class="headerlink" title="import 头文件"></a>import 头文件</h4><ul>
<li>import</li>
<li>隐式地将 <code>iostream</code> 转换为模块</li>
<li>加速构建, 因为 iostream 只会处理一次</li>
<li>和预编译头 (PCH) 具有相似的效果</li>
</ul>
<h3 id="Ranges"><a href="#Ranges" class="headerlink" title="Ranges"></a>Ranges</h3><p><strong>Ranges</strong> 是什么 ?</p>
<ul>
<li><code>Range</code> 代表一串元素, 或者一串元素中的一段</li>
<li>类似 begin&#x2F;end 对</li>
</ul>
<p><strong>好处</strong>:</p>
<ul>
<li>简化语法和方便使用</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; data&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;; </span><br><span class="line"><span class="built_in">sort</span>(<span class="built_in">begin</span>(data), <span class="built_in">end</span>(data)); </span><br><span class="line"><span class="built_in">sort</span>(data); <span class="comment">// 使用 Ranges</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>防止 begin&#x2F;end 不配对</li>
<li>使变换&#x2F;过滤等串联操作成为可能</li>
</ul>
<p><strong>相关功能</strong></p>
<ul>
<li><strong>视图</strong>(View): 延迟计算, 不持有, 不改写</li>
<li><strong>Actions</strong>: 即时处理(eagerly evaluated), 改写</li>
<li><strong>Algorithms</strong>: 所有接受 begin&#x2F;end 对的算法都可用</li>
<li>Views 和 actions 使用管道符<code>|</code>串联</li>
</ul>
<h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul>
<li>串联视图</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; data &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;; </span><br><span class="line"><span class="keyword">auto</span> result = data | </span><br><span class="line">              views::<span class="built_in">remove_if</span>([](<span class="type">int</span> i) &#123; <span class="keyword">return</span> i % <span class="number">2</span> == <span class="number">1</span>;&#125;) | </span><br><span class="line">              views::<span class="built_in">transform</span>([](<span class="type">int</span> i) &#123; <span class="keyword">return</span> <span class="built_in">to_string</span>(i);&#125;); </span><br><span class="line"><span class="comment">// result = &#123;&quot;2&quot;, &quot;4&quot;, &quot;6&quot;, &quot;8&quot;, &quot;10&quot; &#125;;</span></span><br><span class="line"><span class="comment">// 注意 以上操作被延迟, 当你遍历result的时候才触发</span></span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<ul>
<li>串联actions</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; data&#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">8</span>&#125;; </span><br><span class="line">vector&lt;<span class="type">int</span>&gt; result = data | actions::sort | actions::unique;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>排序然后去重</li>
<li>操作会原地对<code>data</code>进行更改, 然后返回</li>
</ul>
</li>
<li>过滤和变换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> total = <span class="built_in">accumulate</span> (</span><br><span class="line">                        view::<span class="built_in">ints</span>(<span class="number">1</span>) | </span><br><span class="line">                        view::<span class="built_in">transform</span>([](<span class="type">int</span> i) &#123;<span class="keyword">return</span> i * i;&#125;) | </span><br><span class="line">                        view::<span class="built_in">take</span>(<span class="number">10</span>), </span><br><span class="line">                        <span class="number">0</span>);</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><code>view::ints(1)</code> 产生一个无限的整型数列</li>
<li>平方</li>
<li>取前10个元素, 然后累加(accumulate)<br><strong>所有的计算延迟到<code>accumulate</code>累加遍历的时候发生</strong></li>
</ul>
</li>
</ul>
<h3 id="协程-Coroutines"><a href="#协程-Coroutines" class="headerlink" title="协程(Coroutines)"></a>协程(Coroutines)</h3><h4 id="什么是协程"><a href="#什么是协程" class="headerlink" title="什么是协程"></a>什么是协程</h4><ul>
<li><p>它是一个函数</p>
</li>
<li><p>具备如下关键字之一:</p>
</li>
<li><ul>
<li><code>co_wait</code>: 挂起协程, 等待其它计算完成</li>
<li><code>co_return</code>: 从协程返回 (协程 <code>return</code> 禁止使用)</li>
<li><code>co_yield</code>: 同 python yield, 弹出一个值, 挂起协程, 下一次调用继续协程的运行</li>
<li><code>for co_await</code> 循环体</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> <span class="title">co_await</span> <span class="params">(<span class="keyword">for</span>-range-declaration: expression)</span> statement</span></span><br><span class="line"><span class="function">1</span></span><br></pre></td></tr></table></figure>

<p><strong>用处</strong></p>
<ul>
<li><p>简化如下问题的实现:</p>
</li>
<li><ul>
<li>generator</li>
<li>异步I&#x2F;O</li>
<li>延迟计算</li>
<li>事件驱动的程序</li>
</ul>
</li>
</ul>
<h4 id="例子-VC"><a href="#例子-VC" class="headerlink" title="例子(VC++)"></a>例子(VC++)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">experimental::generator&lt;<span class="type">int</span>&gt; <span class="title">GetSequenceGenerator</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">int</span> startValue, </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="type">size_t</span> numberOfValues)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span> startValue; i &lt; startValue + numberOfValues; ++i)&#123; </span><br><span class="line">        <span class="type">time_t</span> t = system_clock::<span class="built_in">to_time_t</span>(system_clock::<span class="built_in">now</span>()); </span><br><span class="line">        cout &lt;&lt; std:: <span class="built_in">ctime</span>(&amp;t); <span class="keyword">co_yield</span> i; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> gen = <span class="built_in">GetSequenceGenerator</span>(<span class="number">10</span>, <span class="number">5</span>); </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; value : gen) &#123; </span><br><span class="line">        cout &lt;&lt; value &lt;&lt; <span class="string">&quot;(Press enter for next value)&quot;</span> &lt;&lt; endl; </span><br><span class="line">        cin.<span class="built_in">ignore</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<h3 id="Concepts"><a href="#Concepts" class="headerlink" title="Concepts"></a>Concepts</h3><ul>
<li>对模板类和函数的模板形参的约束</li>
<li>编译期断言</li>
<li>可声明多个</li>
</ul>
<h4 id="如何定义"><a href="#如何定义" class="headerlink" title="如何定义"></a>如何定义</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">concept</span> Incrementable = <span class="built_in">requires</span>(T x) &#123;x++; ++x;&#125;;</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;Incrementable T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(T t)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">requires</span> Incrementable&lt;T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(T t)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(T t)</span> <span class="keyword">requires</span> Incrementable&lt;T&gt;</span>; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(Incrementable <span class="keyword">auto</span> t)</span></span>;</span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><ul>
<li>具备<code>size()</code> 方法, 且返回<code>size_t</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">concept</span> HasSize = <span class="built_in">requires</span> (T x)&#123; </span><br><span class="line">    &#123;x.<span class="built_in">size</span>()&#125; -&gt; std::convertible_to&lt;std::<span class="type">size_t</span>&gt;; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>组合concept</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">requires</span> Incrementable&lt;T&gt; &amp;&amp; Decrementable&lt;T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(T t)</span></span>; </span><br><span class="line"><span class="comment">// or </span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">concept</span> Incr_Decrementable = Incrementable&lt;T&gt; &amp;&amp; Decrementable&lt;T&gt;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;Incr_Decrementable T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(T t)</span></span>;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<h3 id="Lambda-表达式的更新"><a href="#Lambda-表达式的更新" class="headerlink" title="Lambda 表达式的更新"></a>Lambda 表达式的更新</h3><h4 id="this-需要显式捕获this变量"><a href="#this-需要显式捕获this变量" class="headerlink" title="[&#x3D;, this] 需要显式捕获this变量"></a>[&#x3D;, this] 需要显式捕获<code>this</code>变量</h4><ul>
<li>C++20 之前 <code>[=]</code> 隐式捕获<code>this</code></li>
<li>C++20 开始 需要显式捕获this: <code>[=, this]</code></li>
</ul>
<h4 id="模板形式的-Lambda-表达式"><a href="#模板形式的-Lambda-表达式" class="headerlink" title="模板形式的 Lambda 表达式"></a>模板形式的 Lambda 表达式</h4><p>可以在<code>lambda</code>表达式中使用模板语法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[]<span class="built_in">template</span>&lt;T&gt;(T x) &#123;<span class="comment">/* ... */</span>&#125;; </span><br><span class="line">[]<span class="built_in">template</span>&lt;T&gt;(T* p) &#123;<span class="comment">/* ... */</span>&#125;; </span><br><span class="line">[]<span class="built_in">template</span>&lt;T, <span class="type">int</span> N&gt;(<span class="built_in">T</span> (&amp;a)[N]) &#123;<span class="comment">/* ... */</span>&#125;;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>原因1</strong></p>
<ul>
<li>C++20之前: 获取 vector 元素类型, 你需要这么写</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [](<span class="keyword">auto</span> vec)&#123; </span><br><span class="line">    <span class="keyword">using</span> T = <span class="keyword">typename</span> <span class="keyword">decltype</span>(vec)::value_type; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>C++20 你可以:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span> T&gt;(vector&lt;T&gt; vec)&#123; </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<p><strong>原因2</strong>: 方便获取通用lambda形参类型, 访问静态函数</p>
<ul>
<li>c++20 以前</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [](<span class="keyword">auto</span> <span class="type">const</span>&amp; x)&#123; </span><br><span class="line">    <span class="keyword">using</span> T = std::<span class="type">decay_t</span>&lt;<span class="keyword">decltype</span>(x)&gt;; </span><br><span class="line">    T copy = x; T::<span class="built_in">static_function</span>(); </span><br><span class="line">    <span class="keyword">using</span> Iterator = <span class="keyword">typename</span> T::iterator; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<ul>
<li>C++20 开始</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span> T&gt;(<span class="type">const</span> T&amp; x)&#123; </span><br><span class="line">    T copy = x; T::<span class="built_in">static_function</span>(); </span><br><span class="line">    <span class="keyword">using</span> Iterator = <span class="keyword">typename</span> T::iterator; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p><strong>原因3</strong>: 完美转发</p>
<ul>
<li>pre C++20:</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [](<span class="keyword">auto</span>&amp;&amp; ...args) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(std::forward&lt;<span class="keyword">decltype</span>(args)&gt;(args)...); </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>since C++20</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = []&lt;<span class="keyword">typename</span> …T&gt;(T&amp;&amp; …args)&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">foo</span>(std::forward(args)...); </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<h4 id="Lambda-表达式捕获支持打包展开-Pack-Expansion"><a href="#Lambda-表达式捕获支持打包展开-Pack-Expansion" class="headerlink" title="Lambda 表达式捕获支持打包展开(Pack Expansion)"></a>Lambda 表达式捕获支持打包展开(Pack Expansion)</h4><ul>
<li>Pre C++20</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">delay_invoke</span><span class="params">(F f, Args... args)</span></span>&#123; </span><br><span class="line">    <span class="keyword">return</span> [f, args...]&#123; </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f, args...); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Since C++20</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> F, <span class="keyword">class</span>... Args&gt; </span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">delay_invoke</span><span class="params">(F f, Args... args)</span></span>&#123; </span><br><span class="line">    <span class="comment">// Pack Expansion:  args = std::move(args)...  </span></span><br><span class="line">    <span class="keyword">return</span> [f = std::<span class="built_in">move</span>(f), args = std::<span class="built_in">move</span>(args)...]()&#123; </span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">invoke</span>(f, args...); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<h3 id="常量表达式-constexpr-的更新"><a href="#常量表达式-constexpr-的更新" class="headerlink" title="常量表达式(constexpr) 的更新"></a>常量表达式(<code>constexpr</code>) 的更新</h3><ul>
<li><p><code>constexpr</code> 虚函数</p>
</li>
<li><ul>
<li><code>constexpr</code> 的虚函数可以重写非 <code>constexpr</code> 的虚函数</li>
<li>非 <code>constexpr</code> 虚函数可以重写 <code>constexpr</code> 的虚函数</li>
</ul>
</li>
<li><p><code>constexpr</code> 函数可以:</p>
</li>
<li><ul>
<li><p>使用 <code>dynamic_cast()</code> 和 <code>typeid</code></p>
</li>
<li><p>动态内存分配</p>
</li>
<li><p>更改<code>union</code>成员的值</p>
</li>
<li><p>包含 <code>try/catch</code></p>
</li>
<li><ul>
<li>但是**不允许****<code>throw</code>**<strong>语句</strong></li>
<li>在触发常量求值的时候 try&#x2F;catch 不发生作用</li>
<li>需要开启 <code>constexpr std::vector</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="constexpr-string-vector"><a href="#constexpr-string-vector" class="headerlink" title="constexpr string &amp; vector"></a><code>constexpr</code> string &amp; vector</h4><ul>
<li><code>std::string</code> 和 <code>std::vector</code> 类型现在可以作为 <code>constexpr</code></li>
<li>未来需要支持 <code>constexpr</code> 反射</li>
</ul>
<h3 id="原子-Atomic-智能指针"><a href="#原子-Atomic-智能指针" class="headerlink" title="原子(Atomic)智能指针"></a>原子(Atomic)智能指针</h3><ul>
<li><p>智能指针(shared_ptr)线程安全吗?</p>
</li>
<li><ul>
<li><strong>是</strong>: 引用计数控制单元线程安全, 保证对象只被释放一次</li>
<li><strong>否</strong>: 对于数据的读写没有线程安全</li>
</ul>
</li>
<li><p>如何将智能指针变成线程安全?</p>
</li>
<li><ul>
<li><p>使用 <code>mutex</code> 控制智能指针的访问</p>
</li>
<li><p>使用全局非成员原子操作函数访问, 诸如: std::atomic_load(), atomic_store(), …</p>
</li>
<li><ul>
<li><strong>缺点</strong>: 容易出错, 忘记使用这些操作</li>
</ul>
</li>
<li><p>C++20: <code>atomic&lt;shared_ptr&lt;T&gt;&gt;</code>, <code>atomic&lt;weak_ptr&lt;T&gt;&gt;</code></p>
</li>
<li><ul>
<li>内部原理可能使用了<code>mutex</code></li>
<li>全局非成员原子操作函数标记为不推荐使用(deprecated)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">concurrent_stack</span> &#123; </span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123; </span><br><span class="line">        T t; </span><br><span class="line">        shared_ptr&lt;Node&gt; next; </span><br><span class="line">    &#125;; </span><br><span class="line">    atomic_shared_ptr&lt;Node&gt; head; </span><br><span class="line">    <span class="comment">// C++11: 去掉 &quot;atomic_&quot; 并且在访问时, 需要用 </span></span><br><span class="line">    <span class="comment">// 特殊的函数控制线程安全, 例如用std::tomic_load </span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">reference</span> &#123; </span><br><span class="line">        shared_ptr&lt;Node&gt; p; </span><br><span class="line">        &lt;snip&gt; </span><br><span class="line">    &#125;; </span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">find</span><span class="params">(T t)</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">auto</span> p = head.<span class="built_in">load</span>(); <span class="comment">// C++11: atomic_load(&amp;head) </span></span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; p-&gt;t != t) </span><br><span class="line">            p = p-&gt;next; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reference</span>(<span class="built_in">move</span>(p)); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reference</span>(head); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_front</span><span class="params">(T t)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;Node&gt;(); </span><br><span class="line">        p-&gt;t = t; p-&gt;next = head; </span><br><span class="line">        <span class="keyword">while</span> (!head.<span class="built_in">compare_exchange_weak</span>(p-&gt;next, p))&#123; </span><br><span class="line">    &#125; <span class="comment">// C++11: atomic_compare_exchange_weak(&amp;head, &amp;p-&gt;next, p); &#125;     </span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">auto</span> p = head.<span class="built_in">load</span>(); </span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; !head.<span class="built_in">compare_exchange_weak</span>(p, p-&gt;next)) &#123;</span><br><span class="line">        &#125; <span class="comment">// C++11: atomic_compare_exchange_weak(&amp;head, &amp;p, p-&gt;next); </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">12345678910111213141516171819202122232425262728293031323334</span></span><br></pre></td></tr></table></figure>

<p><em>例子来自 Herb Sutter 的 N4162 论文</em></p>
<h3 id="自动合流-Joining-可中断-Cancellable-的线程"><a href="#自动合流-Joining-可中断-Cancellable-的线程" class="headerlink" title="自动合流(Joining), 可中断(Cancellable) 的线程"></a>自动合流(Joining), 可中断(Cancellable) 的线程</h3><ul>
<li><p>std::jthread</p>
</li>
<li><ul>
<li><p>头文件</p>
</li>
<li><p>支持中断</p>
</li>
<li><p>析构函数中自动 Join</p>
</li>
<li><ul>
<li>析构函数调用 <code>stop_source.request_stop()</code> 然后 <code>join()</code></li>
</ul>
</li>
</ul>
</li>
<li><p>中断线程执行</p>
</li>
<li><ul>
<li><p>头文件 &lt;stop_token&gt;</p>
</li>
<li><p><code>std::stop_token</code></p>
</li>
<li><ul>
<li>用来查询线程是否中断</li>
<li>可以和<code>condition_variable_any</code>配合使用</li>
</ul>
</li>
<li><p><code>std::stop_source</code></p>
</li>
<li><ul>
<li>用来请求线程停止运行</li>
<li>stop_resources 和 stop_tokens 都可以查询到停止请求</li>
</ul>
</li>
<li><p><code>std::stop_callback</code></p>
</li>
<li><ul>
<li>如果对应的<code>stop_token</code> 被要求终止, 将会触发回调函数</li>
<li>用法: std::stop_callback myCallback(myStopToken, []{ &#x2F;* … *&#x2F; });</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><ul>
<li>自动合流 Join</li>
</ul>
<blockquote>
<p><em>std::thread 在析构函数中如果线程</em> <em><code>joinable()</code></em> <em>会直接调用</em> <em><code>std::terminate()</code></em> <em>直接导致程序退出</em></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWorkPreCpp20</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="function">std::thread <span class="title">job</span><span class="params">([] &#123; <span class="comment">/* ... */</span> &#125;)</span></span>; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        <span class="comment">// ... Do something else ... </span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123; </span><br><span class="line">        job.<span class="built_in">join</span>(); </span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// rethrow </span></span><br><span class="line">    &#125; </span><br><span class="line">    job.<span class="built_in">join</span>(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">DoWork</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="function">std::jthread <span class="title">job</span><span class="params">([] &#123; <span class="comment">/* ... */</span> &#125;)</span></span>; </span><br><span class="line">    <span class="comment">// ... Do something else ... </span></span><br><span class="line">&#125; <span class="comment">// jthread destructor automatically calls join()</span></span><br><span class="line"><span class="number">123456789101112131415</span></span><br></pre></td></tr></table></figure>

<ul>
<li>中断</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">std::jthread <span class="title">job</span><span class="params">([](std::stop_token token) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span> (!token.stop_requested()) &#123; </span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">//... </span></span></span></span><br><span class="line"><span class="params"><span class="function">    &#125; </span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>; </span><br><span class="line"><span class="comment">//... job.request_stop(); </span></span><br><span class="line"><span class="comment">// auto source = job.get_stop_source() </span></span><br><span class="line"><span class="comment">// auto token = job.get_stop_token()</span></span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<h3 id="C-20-同步-Synchronization-库"><a href="#C-20-同步-Synchronization-库" class="headerlink" title="C++20 同步(Synchronization)库"></a>C++20 同步(Synchronization)库</h3><ul>
<li><p>信号量(Semaphore), 维基百科请走<a href="https://link.zhihu.com/?target=https://zh.wikipedia.org/wiki/%E4%BF%A1%E5%8F%B7%E9%87%8F">这里</a></p>
</li>
<li><ul>
<li><p>头文件<a href="https://link.zhihu.com/?target=https://en.cppreference.com/w/cpp/header/semaphore"></a></p>
</li>
<li><p>轻量级的同步原语</p>
</li>
<li><p>可用来实现任何其他同步概念, 如: mutex, latches, barriers, …</p>
</li>
<li><p>两种类型:</p>
</li>
<li><ul>
<li>多元信号量(counting semaphore): 建模非负值资源计数</li>
<li>二元信号量(binary semaphore): 只有一个插孔, 两种状态, 最适合实现<code>mutex</code></li>
</ul>
</li>
</ul>
</li>
<li><p><code>std::atomic</code> 等待和通知接口</p>
</li>
<li><ul>
<li><p>等待&#x2F;阻塞在原子对象直到其值发生改变, 通过通知函数发送通知</p>
</li>
<li><p>比轮训(polling)来的更高效</p>
</li>
<li><p>方法</p>
</li>
<li><ul>
<li><code>wait()</code></li>
<li><code>notify_one()</code></li>
<li><code>notify_all()</code></li>
</ul>
</li>
</ul>
</li>
<li><p>锁存器(Latch)和屏障(Barrier)</p>
</li>
<li><ul>
<li>辅助线程条件同步</li>
</ul>
</li>
<li><p>锁存器(Latches)</p>
</li>
<li><ul>
<li><p>头文件</p>
</li>
<li><p>线程的同步点</p>
</li>
<li><ul>
<li>线程将阻塞在这个位置, 直到到达的线程个数达标才放行, 放行之后不再关闭</li>
</ul>
</li>
<li><p>锁存器只会作用一次</p>
</li>
</ul>
</li>
<li><p>屏障(Barriers)</p>
</li>
<li><ul>
<li><p>多个阶段</p>
</li>
<li><p>每个阶段中</p>
</li>
<li><ul>
<li>一个参与者运行至屏障点时被阻塞，需要等待其他参与者都到达屏障点, 当到达线程数达标之后</li>
<li>阶段完成的回调将被执行</li>
<li>线程计数器被重置</li>
<li>开启下一阶段</li>
<li>线程得以继续执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="std-atomic-ref"><a href="#std-atomic-ref" class="headerlink" title="std::atomic_ref"></a>std::atomic_ref</h4><ul>
<li>头文件</li>
<li>Atomic 引用</li>
<li>通过引用访问变为原子操作, 被引用对象可以为非原子类型</li>
</ul>
<h3 id="其他更新"><a href="#其他更新" class="headerlink" title="其他更新"></a>其他更新</h3><h4 id="指定初始化-Designated-Initializers"><a href="#指定初始化-Designated-Initializers" class="headerlink" title="指定初始化(Designated Initializers)"></a>指定初始化(Designated Initializers)</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Data</span> &#123; </span><br><span class="line">    <span class="type">int</span> anInt = <span class="number">0</span>; </span><br><span class="line">    std::string aString; </span><br><span class="line">&#125;; </span><br><span class="line">Data d&#123; .aString = <span class="string">&quot;Hello&quot;</span> &#125;;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h4 id="航天飞机操作符"><a href="#航天飞机操作符" class="headerlink" title="航天飞机操作符 &lt;&#x3D;&gt;"></a>航天飞机操作符 &lt;&#x3D;&gt;</h4><ul>
<li><p>正规名称: <strong>三路比较运算符</strong></p>
</li>
<li><p>三路比较结果如下</p>
</li>
<li><ul>
<li>(a &lt;&#x3D;&gt; b) &lt; 0 &#x2F;&#x2F; 如果 a &lt; b 则为 true</li>
<li>(a &lt;&#x3D;&gt; b) &gt; 0 &#x2F;&#x2F; 如果 a &gt; b 则为 true</li>
<li>(a &lt;&#x3D;&gt; b) &#x3D;&#x3D; 0 &#x2F;&#x2F; 如果 a 与 b 相等或者等价 则为 true</li>
</ul>
</li>
<li><p>类似于C的strcmp 函数返回-1, 0, 1</p>
</li>
<li><p><strong>一般情况</strong>: 自动生成所有的比较操作符, 如果对象是结构体则逐个比较, 可以用下面代码代替所有的比较运算符</p>
</li>
<li><ul>
<li><code>auto X::operator&lt;=&gt;(const Y&amp;) = default;</code></li>
</ul>
</li>
<li><p><strong>高级情况</strong>: 指定返回类型(支持6种所有的比较运算符)</p>
</li>
</ul>
<p><strong>示例</strong>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; </span><br><span class="line">    <span class="type">int</span> x; <span class="type">int</span> y; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)&#123; </span><br><span class="line">        <span class="keyword">return</span> a.x==b.x &amp;&amp; a.y==b.y; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b)&#123; </span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x || (a.x == b.x &amp;&amp; a.y &lt; b.y);  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b) &#123; </span><br><span class="line">        <span class="keyword">return</span> !(a==b); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b) &#123; </span><br><span class="line">        <span class="keyword">return</span> !(<span class="built_in">b</span>&lt;a); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt; (<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b) &#123; </span><br><span class="line">        <span class="keyword">return</span> b&lt;a; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">friend</span> <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> Point&amp; a, <span class="type">const</span> Point&amp; b) &#123; </span><br><span class="line">        <span class="keyword">return</span> !(a&lt;b); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// ... 其他非比较函数 ... </span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;compare&gt;</span> </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123; </span><br><span class="line">    <span class="type">int</span> x; <span class="type">int</span> y; </span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Point&amp;)  <span class="type">const</span> = <span class="keyword">default</span>; <span class="comment">// 比较操作符自动生成</span></span><br><span class="line">    <span class="comment">// ... 其他非比较函数 ... </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627282930</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>标准库类型支持 &lt;&#x3D;&gt;</p>
</li>
<li><ul>
<li>vector, string, map, set, sub_match, …</li>
</ul>
</li>
<li><p>例如:</p>
</li>
</ul>
<h4 id="范围-for-循环语句支持初始化语句"><a href="#范围-for-循环语句支持初始化语句" class="headerlink" title="范围 for 循环语句支持初始化语句"></a>范围 for 循环语句支持初始化语句</h4><ul>
<li>switch 语句初始化 (C++17):</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">    <span class="type">int</span> value; <span class="type">int</span> result; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function">Foo <span class="title">GetData</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Foo</span>(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">auto</span> data = <span class="built_in">GetData</span>(); data.value) &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">        <span class="keyword">return</span> data.result; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<ul>
<li>if 语句初始化 (C++17):</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">    <span class="type">int</span> value; <span class="type">int</span> result; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function">Foo* <span class="title">GetData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Foo</span>(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> data = <span class="built_in">GetData</span>(); data) &#123; </span><br><span class="line">        <span class="comment">// Use &#x27;data’ </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112</span></span><br></pre></td></tr></table></figure>

<ul>
<li>现在范围 for 循环同样支持初始化 (C++20):</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Foo</span> &#123; </span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; values; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function">Foo <span class="title">GetData</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Foo</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> data = <span class="built_in">GetData</span>(); </span><br><span class="line">    <span class="keyword">auto</span>&amp; value : data.values) &#123; </span><br><span class="line">        <span class="comment">// Use &#x27;data’ </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="number">12345678910111213</span></span><br></pre></td></tr></table></figure>

<h4 id="非类型模板形参支持字符串"><a href="#非类型模板形参支持字符串" class="headerlink" title="非类型模板形参支持字符串"></a>非类型模板形参支持字符串</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">auto</span>&amp; s&gt; <span class="type">void</span> <span class="title">DoSomething</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    std::cout &lt;&lt; s &lt;&lt; std::endl; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">DoSomething</span>&lt;<span class="string">&quot;CppCon&quot;</span>&gt;(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456</span></span><br></pre></td></tr></table></figure>

<h4 id="likely-unlikely"><a href="#likely-unlikely" class="headerlink" title="[[likely]], [[unlikely]]"></a>[[likely]], [[unlikely]]</h4><p>先验概率指导编译器优化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (value) &#123; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">break</span>; </span><br><span class="line">    [[likely]] <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">break</span>; </span><br><span class="line">    [[unlikely]] <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<h4 id="日历-Calendar-和时区-Timezone-功能"><a href="#日历-Calendar-和时区-Timezone-功能" class="headerlink" title="日历(Calendar)和时区(Timezone)功能"></a>日历(Calendar)和时区(Timezone)功能</h4><ul>
<li><p>增加日历和时区的支持</p>
</li>
<li><p>只支持公历(Gregorian calendar)</p>
</li>
<li><ul>
<li>其他日历也可通过扩展加入, 并能和 进行交互</li>
</ul>
</li>
<li><p>初始化 年, 月 日的方法</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// creating a year </span></span><br><span class="line"><span class="keyword">auto</span> y1 = year&#123; <span class="number">2019</span> &#125;; </span><br><span class="line"><span class="keyword">auto</span> y2 = <span class="number">2019</span>y; </span><br><span class="line"><span class="comment">// creating a mouth</span></span><br><span class="line"><span class="keyword">auto</span> m1 = month&#123; <span class="number">9</span> &#125;; </span><br><span class="line"><span class="keyword">auto</span> m2 = September; </span><br><span class="line"><span class="comment">// creating a day </span></span><br><span class="line"><span class="keyword">auto</span> d1 = day&#123; <span class="number">18</span> &#125;; </span><br><span class="line"><span class="keyword">auto</span> d2 = <span class="number">18</span>d;</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure>

<ul>
<li>创建完整的日期</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">year_mouth_day fulldate1&#123;<span class="number">2019</span>y, September, <span class="number">18</span>d&#125;; </span><br><span class="line"><span class="keyword">auto</span> fulldate2 = <span class="number">2019</span>y / September / <span class="number">18</span>d; </span><br><span class="line">year_mouth_day fulldate3&#123;Monday[<span class="number">3</span>]/September/<span class="number">2019</span>&#125;; <span class="comment">// Monday[3] 表示第三个星期一</span></span><br><span class="line"><span class="number">123</span></span><br></pre></td></tr></table></figure>

<ul>
<li>新的事件间隔单位, 类似于秒, 分钟, …</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> days = duration&lt;<span class="type">signed</span> interger type of at least <span class="number">25</span>bits, </span><br><span class="line">                      ratio_multiply&lt;ratio&lt;<span class="number">24</span>&gt;, hours::period&gt;&gt;; </span><br><span class="line"><span class="keyword">using</span> weeks = ...; <span class="keyword">using</span> mouths = ...; </span><br><span class="line"><span class="keyword">using</span> years = ...;</span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<ul>
<li>例子</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">weeks w&#123;<span class="number">1</span>&#125;; <span class="comment">// 1 周 </span></span><br><span class="line">days d&#123;w&#125;; <span class="comment">// 将 1 周 转换成天数</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>新的时钟类型, (之前有 <code>system_clock</code>, <code>steady_clock</code>, <code>high_resolution_clock</code>):</p>
</li>
<li><ul>
<li><code>utc_clock</code>: represents Coordinated Universal Time (UTC), measures time since 00:00:00 UTC, Thursday, 1 January 1970, including leap seconds</li>
<li><code>tai_clock</code>: represents International Atomic Time (TAI), measures time since 00:00:00, 1 January 1958, and was offseted 10 seconds ahead of UTC at that date, it does not include leap seconds</li>
<li><code>gps_clock</code>: represents Global Positioning System (GPS) time, measures time since 00:00:00, 6 January 1980 UTC, it does not include leap seconds</li>
<li><code>file_clock</code>: alias for the clock used for <code>std::filesystem::file_time_type</code>, epoch is unspecified</li>
</ul>
</li>
<li><p>新增<code>system_clock</code>相关的别名</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">Duration</span>&gt; </span><br><span class="line"><span class="keyword">using</span> sys_time = std::chrono::time_point&lt;std::chrono::system_clock, Duration&gt;; </span><br><span class="line"><span class="keyword">using</span> sys_seconds = sys_time&lt;std::chrono::seconds&gt;; </span><br><span class="line"><span class="keyword">using</span> sys_days = sys_time&lt;std::chrono::days&gt;; </span><br><span class="line"><span class="comment">// 用例: </span></span><br><span class="line">system_clock::time_point t =  sys_days&#123; <span class="number">2019</span>y / September / <span class="number">18</span>d &#125;; <span class="comment">// date -&gt; time_point </span></span><br><span class="line"><span class="keyword">auto</span> yearmonthday =  year_month_day&#123; <span class="built_in">floor</span>&lt;days&gt;(t) &#125;; <span class="comment">// time_point -&gt; date</span></span><br><span class="line"><span class="number">1234567</span></span><br></pre></td></tr></table></figure>

<ul>
<li>日期 + 事件</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> t = sys_days&#123;<span class="number">2019</span>y/September/<span class="number">18</span>d&#125; + <span class="number">9</span>h + <span class="number">35</span>min + <span class="number">10</span>s; <span class="comment">// 2019-09-18 09:35:10 UTC</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<ul>
<li>时区转换</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Convert UTC to Denver </span></span><br><span class="line">time: zoned_time denver = &#123; <span class="string">&quot;America/Denver&quot;</span>, t &#125;; </span><br><span class="line"><span class="comment">// Construct a local time in Denver: </span></span><br><span class="line"><span class="keyword">auto</span> t = zoned_time&#123; </span><br><span class="line">    <span class="string">&quot;America/Denver&quot;</span>,  local_days&#123;Wednesday[<span class="number">3</span>] / September / <span class="number">2019</span>&#125; + <span class="number">9</span>h </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// Get current local time: </span></span><br><span class="line"><span class="keyword">auto</span> t = zoned_time&#123; <span class="built_in">current_zone</span>(), system_clock::<span class="built_in">now</span>() &#125;;</span><br><span class="line"><span class="number">12345678</span></span><br></pre></td></tr></table></figure>

<h4 id="std-span"><a href="#std-span" class="headerlink" title="std::span"></a>std::span</h4><ul>
<li>头文件</li>
<li>某段连续数据的”视图”</li>
<li>不持有数据, 不分配和销毁数据</li>
<li>拷贝非常快, 推荐复制的方式传参(类似 <code>string_view</code>)</li>
<li>不支持数据跨步(stride)</li>
<li>可通过运行期确定长度也可编译器确定长度</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> data[<span class="number">42</span>]; span&lt;<span class="type">int</span>, <span class="number">42</span>&gt; a &#123;data&#125;; <span class="comment">// fixed-size: 42 ints </span></span><br><span class="line">span&lt;<span class="type">int</span>&gt; b &#123;data&#125;; <span class="comment">// dynamic-size: 42 ints </span></span><br><span class="line">span&lt;<span class="type">int</span>, <span class="number">50</span>&gt; c &#123;data&#125;; <span class="comment">// compilation error </span></span><br><span class="line">span&lt;<span class="type">int</span>&gt; d&#123; ptr, len &#125;; <span class="comment">// dynamic-size: len ints</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>

<h4 id="特性测试宏"><a href="#特性测试宏" class="headerlink" title="特性测试宏"></a>特性测试宏</h4><p>通过它可以判断编译器是否支持某个功能, 例如</p>
<ul>
<li><p>语言特性</p>
</li>
<li><ul>
<li><code>__has_cpp_attribute(fallthrough)</code></li>
<li><code>__cpp_binary_literals</code></li>
<li><code>__cpp_char8_t</code></li>
<li><code>__cpp_coroutines</code></li>
</ul>
</li>
<li><p>标准库特性</p>
</li>
<li><ul>
<li><code>__cpp_lib_concepts</code></li>
<li><code>__cpp_lib_ranges</code></li>
<li><code>__cpp_lib_scoped_lock</code></li>
</ul>
</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4><p>包含 C++ 标准库版本, 发布日期, 版权证书, 特性宏等</p>
<h4 id="consteval-函数"><a href="#consteval-函数" class="headerlink" title="consteval 函数"></a><code>consteval</code> 函数</h4><p><code>constexpr</code> 函数可能编译期执行, 也可以在运行期执行, <code>consteval</code> 只能在编译器执行, 如果不满足要求编译不通过</p>
<h4 id="constinit"><a href="#constinit" class="headerlink" title="constinit"></a><code>constinit</code></h4><p>强制指定以常量方式初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">GetStringDyn</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;dynamic init&quot;</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">GetString</span><span class="params">(<span class="type">bool</span> constInit)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> constInit ? </span><br><span class="line">        <span class="string">&quot;constant init&quot;</span> : </span><br><span class="line">        <span class="built_in">GetStringDyn</span>(); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">constinit</span> <span class="type">const</span> <span class="type">char</span>* a = <span class="built_in">GetString</span>(<span class="literal">true</span>); <span class="comment">// ✔ </span></span><br><span class="line"><span class="keyword">constinit</span> <span class="type">const</span> <span class="type">char</span>* b = <span class="built_in">GetString</span>(<span class="literal">false</span>); <span class="comment">// ❌</span></span><br><span class="line"><span class="number">12345678910</span></span><br></pre></td></tr></table></figure>

<h4 id="用-using-引用-enum-类型"><a href="#用-using-引用-enum-类型" class="headerlink" title="用 using 引用 enum 类型"></a>用 <code>using</code> 引用 <code>enum</code> 类型</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum class</span> <span class="title class_">CardTypeSuit</span> &#123; </span><br><span class="line">    Clubs, </span><br><span class="line">    Diamonds, </span><br><span class="line">    Hearts, </span><br><span class="line">    Spades </span><br><span class="line">&#125;; </span><br><span class="line"><span class="function">std::string_view <span class="title">GetString</span><span class="params">(<span class="type">const</span> CardTypeSuit cardTypeSuit)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">switch</span> (cardTypeSuit) &#123; </span><br><span class="line">    <span class="keyword">case</span> CardTypeSuit::Clubs: </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Clubs&quot;</span>; </span><br><span class="line">    <span class="keyword">case</span> CardTypeSuit::Diamonds: </span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Diamonds&quot;</span>; </span><br><span class="line">    <span class="keyword">case</span> CardTypeSuit::Hearts: </span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;Hearts&quot;</span>; </span><br><span class="line">    <span class="keyword">case</span> CardTypeSuit::Spades: </span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;Spades&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function">std::string_view <span class="title">GetString</span><span class="params">(<span class="type">const</span> CardTypeSuit cardTypeSuit)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">switch</span> (cardTypeSuit) &#123; </span><br><span class="line">        <span class="keyword">using</span> <span class="keyword">enum</span> <span class="title class_">CardTypeSuit</span>; <span class="comment">// 这里 </span></span><br><span class="line">        <span class="keyword">case</span> Clubs: <span class="keyword">return</span> <span class="string">&quot;Clubs&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> Diamonds: <span class="keyword">return</span> <span class="string">&quot;Diamonds&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> Hearts: <span class="keyword">return</span> <span class="string">&quot;Hearts&quot;</span>; </span><br><span class="line">        <span class="keyword">case</span> Spades: <span class="keyword">return</span> <span class="string">&quot;Spades&quot;</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="number">123456789101112131415161718192021222324252627</span></span><br></pre></td></tr></table></figure>

<h4 id="格式化库-std-format"><a href="#格式化库-std-format" class="headerlink" title="格式化库(std::format)"></a>格式化库(<code>std::format</code>)</h4><p>不展开, 类似<code>Python</code> 的格式化,</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s = std::format(<span class="string">&quot;Hello CppCon &#123;&#125;!&quot;</span>, <span class="number">2019</span>);</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="增加数学常量"><a href="#增加数学常量" class="headerlink" title="增加数学常量"></a>增加数学常量</h4><p>再也不用为 M_PI 发愁啦</p>
<ul>
<li>头文件</li>
<li>包含 e, log2e, log10e pi, inv_pi, inv_sqrt pi ln2, ln10 sqrt2, sqrt3, inv_sqrt3 egamma</li>
</ul>
<h4 id="std-source-location"><a href="#std-source-location" class="headerlink" title="std::source_location"></a>std::source_location</h4><p>用于获取代码位置, 对于日志和错误信息尤其有用</p>
<h4 id="nodiscard-reason"><a href="#nodiscard-reason" class="headerlink" title="[[nodiscard(reason)]]"></a>[[nodiscard(reason)]]</h4><p>表明返回值不可抛弃, 加入理由的支持</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[[<span class="built_in">nodiscard</span>(<span class="string">&quot;Ignoring the return value will result in memory leaks.&quot;</span>)]] </span><br><span class="line"><span class="function"><span class="type">void</span>* <span class="title">GetData</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure>

<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><p>加入循环移位, 计数0和1位等功能</p>
<h4 id="一些小更新"><a href="#一些小更新" class="headerlink" title="一些小更新"></a>一些小更新</h4><ul>
<li>字符串支持 starts_with, ends_with</li>
<li>map 支持 contains 查询是否存在某个键</li>
<li>list 和 forward list 的 remove, remove_if 和 unique 操作返回 size_type 表明删除个数</li>
<li>增加 shift_left, shift_right</li>
<li><code>midpoint</code> 计算中位数, 可避免溢出</li>
<li><code>lerp</code> 线性插值 <code>lerp( float a, float b, float t )</code> 返回 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-SIYwBQJu-1628786141278)(<a href="https://www.zhihu.com/equation?tex=a+++t(b-a)%5C%5D">https://www.zhihu.com/equation?tex=a+%2B+t(b-a)\]</a>)</li>
<li>新的向量化策略 <code>unsequenced_policy(execution::unseq)</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string str = <span class="string">&quot;Hello world!&quot;</span>; </span><br><span class="line"><span class="type">bool</span> b = str.<span class="built_in">starts_with</span>(<span class="string">&quot;Hello&quot;</span>); <span class="comment">// starts_with, ends_with </span></span><br><span class="line">std::map myMap&#123; std::pair&#123;<span class="number">1</span>, <span class="string">&quot;one&quot;</span>s&#125;, &#123;<span class="number">2</span>, <span class="string">&quot;two&quot;</span>s&#125;, &#123;<span class="number">3</span>, <span class="string">&quot;three&quot;</span>s&#125; &#125;; </span><br><span class="line"><span class="type">bool</span> result = myMap.<span class="built_in">contains</span>(<span class="number">2</span>); <span class="comment">// contains, 再也不用  .find() == .end() 了</span></span><br><span class="line"><span class="number">1234</span></span><br></pre></td></tr></table></figure>




<p>专栏目录</p>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ol>
<li><a href="#t0">文章目录</a></li>
<li><a href="#t1">C++ 11是什么，C++ 11标准的由来</a></li>
<li><a href="#t2">C++ auto类型推导完全攻略</a></li>
<li><ol>
<li><a href="#t3">auto 类型推导的语法和规则</a></li>
<li><a href="#t4">auto 的高级用法</a></li>
<li><a href="#t5">auto 的限制</a></li>
<li><a href="#t6">auto 的应用</a></li>
</ol>
</li>
<li><a href="#t7">C++ decltype类型推导完全攻略</a></li>
<li><ol>
<li><a href="#t8">decltype 推导规则</a></li>
<li><a href="#t9">decltype 的实际应用</a></li>
</ol>
</li>
<li><a href="#t10">汇总auto和decltype的区别</a></li>
<li><ol>
<li><a href="#t11">语法格式的区别</a></li>
<li><a href="#t12">对 cv 限定符的处理</a></li>
<li><a href="#t13">对引用的处理</a></li>
<li><a href="#t14">总结</a></li>
</ol>
</li>
<li><a href="#t15">C++返回值类型后置（跟踪返回值类型）</a></li>
<li><a href="#t16">C++11对模板实例化中连续右尖括号&gt;&gt;的改进</a></li>
<li><a href="#t17">C++11使用using定义别名（替代typedef）</a></li>
<li><a href="#t18">C++11支持函数模板的默认模板参数</a></li>
<li><a href="#t19">C++11在函数模板和类模板中使用可变参数</a></li>
<li><ol>
<li><a href="#t20">可变参数模板</a></li>
</ol>
</li>
<li><a href="#t21">C++11 tuple元组详解</a></li>
<li><ol>
<li><a href="#t22">tuple对象的创建</a><ol start="2">
<li><a href="#t23">tuple常用函数</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#t24">C++11列表初始化（统一了初始化方式）</a></li>
<li><ol>
<li><a href="#t25">统一的初始化</a></li>
</ol>
</li>
<li><a href="#t26">C++11 lambda匿名函数用法详解</a></li>
<li><ol>
<li><a href="#t27">lambda匿名函数的定义</a></li>
</ol>
</li>
<li><a href="#t28">C++11非受限联合体（union）</a></li>
<li><ol>
<li><a href="#t29">非受限联合体的赋值注意事项</a><ol start="2">
<li><a href="#t30">非受限联合体的匿名声明和“枚举式类”</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#t31">C++11 for循环（基于范围的循环）详解</a></li>
<li><a href="#t32">C++11 for循环使用注意事项</a></li>
<li><a href="#t33">C++11 constexpr：验证是否为常量表达式（长篇神文）</a></li>
<li><ol>
<li><a href="#t34">constexpr修饰普通变量</a><ol start="2">
<li><a href="#t35">constexpr修饰函数</a></li>
<li><a href="#t36">constexpr修饰类的构造函数</a></li>
<li><a href="#t37">constexpr修饰模板函数</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#t38">C++11 constexpr和const的区别</a></li>
<li><a href="#t39">C++11 long long超长整形详解</a></li>
<li><a href="#t40">C++11右值引用（一看即懂）</a></li>
<li><ol>
<li><a href="#t41">C++左值和右值</a><ol start="2">
<li><a href="#t42">C++右值引用</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#t43">C++11移动构造函数的功能和用法</a></li>
<li><ol>
<li><a href="#t44">C++11移动语义是什么</a><ol start="2">
<li><a href="#t45">C++移动构造函数（移动语义的具体实现）</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#t46">C++11 move()函数：将左值强制转换为右值</a></li>
<li><a href="#t47">C++11引用限定符的用法</a></li>
<li><ol>
<li><a href="#t48">const和引用限定符</a></li>
</ol>
</li>
<li><a href="#t49">C++11完美转发及其实现</a></li>
<li><a href="#t50">C++11 nullptr：初始化空指针</a></li>
<li><a href="#t51">C++11 shared_ptr智能指针（超级详细）</a></li>
<li><ol>
<li><a href="#t52">C++11 shared_ptr智能指针</a></li>
</ol>
</li>
<li><a href="#t53">C++11 unique_ptr智能指针</a></li>
<li><ol>
<li><a href="#t54">unique_ptr智能指针的创建</a><ol start="2">
<li><a href="#t55">unique_ptr模板类提供的成员方法</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#t56">C++11 weak_ptr智能指针</a></li>
<li><ol>
<li><a href="#t57">C++11 weak_ptr智能指针</a></li>
</ol>
</li>
<li><a href="#t58">C++14 新特性总结</a></li>
<li><a href="#t59">C++17新特性总结</a></li>
<li><ol>
<li><a href="#t60">std::optional</a></li>
</ol>
</li>
<li><a href="#t61">C++20 新增特性总结</a></li>
<li><ol>
<li><a href="#t62">新增关键字(keywords)</a><ol start="2">
<li><a href="#t63">新增标识符(Identifies)</a></li>
<li><a href="#t64">模块(Modules)</a></li>
<li><ol>
<li><a href="#t65">优点</a></li>
</ol>
</li>
</ol>
</li>
<li><a href="#t66">创建模块</a></li>
<li><a href="#t67">引用模块</a></li>
<li><a href="#t68">import 头文件</a><br>5.  <a href="#t69">Ranges</a><br>6.  1.  <a href="#t70">例子</a><br>7.  <a href="#t71">协程(Coroutines)</a><br>8.  1.  <a href="#t72">什么是协程</a></li>
<li><a href="#t73">例子(VC++)</a><br>9.  <a href="#t74">Concepts</a><br>10.  1.  <a href="#t75">如何定义</a></li>
<li><a href="#t76">使用</a></li>
<li><a href="#t77">例子</a><br>11.  <a href="#t78">Lambda 表达式的更新</a><br>12.  1.  <a href="#t79">[&#x3D;, this] 需要显式捕获this变量</a></li>
<li><a href="#t80">模板形式的 Lambda 表达式</a></li>
<li><a href="#t81">Lambda 表达式捕获支持打包展开(Pack Expansion)</a><br>13.  <a href="#t82">常量表达式(constexpr) 的更新</a><br>14.  1.  <a href="#t83">constexpr string &amp; vector</a><br>15.  <a href="#t84">原子(Atomic)智能指针</a><br>16.  1.  <a href="#t85">例子</a><br>17.  <a href="#t86">自动合流(Joining), 可中断(Cancellable) 的线程</a><br>18.  1.  <a href="#t87">例子</a><br>19.  <a href="#t88">C++20 同步(Synchronization)库</a><br>20.  1.  <a href="#t89">std::atomic_ref</a><br>21.  <a href="#t90">其他更新</a><br>22.  1.  <a href="#t91">指定初始化(Designated Initializers)</a></li>
<li><a href="#t92">航天飞机操作符 &lt;&#x3D;&gt;</a></li>
<li><a href="#t93">范围 for 循环语句支持初始化语句</a></li>
<li><a href="#t94">非类型模板形参支持字符串</a></li>
<li><a href="#t95">[[likely]], [[unlikely]]</a></li>
<li><a href="#t96">日历(Calendar)和时区(Timezone)功能</a></li>
<li><a href="#t97">std::span</a></li>
<li><a href="#t98">特性测试宏</a></li>
<li><a href="#t100">consteval 函数</a></li>
<li><a href="#t101">constinit</a></li>
<li><a href="#t102">用 using 引用 enum 类型</a></li>
<li><a href="#t103">格式化库(std::format)</a></li>
<li><a href="#t104">增加数学常量</a></li>
<li><a href="#t105">std::source_location</a></li>
<li><a href="#t106">[[nodiscard(reason)]]</a></li>
<li><a href="#t107">位运算</a></li>
<li><a href="#t108">一些小更新</a></li>
</ol>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Hexo blog 详细教程</title>
    <url>/2018/12/21/Hexo-blog-detailed-tutorial/</url>
    <content><![CDATA[<h2 id="1-Hexo-搭建-Blog-基础概念"><a href="#1-Hexo-搭建-Blog-基础概念" class="headerlink" title="1. Hexo 搭建 Blog 基础概念"></a>1. Hexo 搭建 Blog 基础概念</h2><h3 id="1-1-发布仓库"><a href="#1-1-发布仓库" class="headerlink" title="1.1 发布仓库"></a>1.1 发布仓库</h3><p><em><strong><code>发布仓库</code></strong></em> 就是日常编写文章以后, 通过命令 <code>hexo deploy</code> 发布出去的仓库地址, 具体配置在 <code>_config.yml</code> 文件中</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="string">git</span></span><br><span class="line">    <span class="attr">repository:</span> <span class="string">git@ip:repo_name.git</span></span><br><span class="line">    <span class="attr">branch:</span> <span class="string">branch_name</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>由于作者本身有云服务器 并且还买了域名 所以我的发布仓库就 建在自己的服务器中 实际上各位客官也可以把仓库建在<a href="https://gitee.com/">gitee</a>的私有仓库 或者 <a href="https://github.com/">Github</a>上</p>
<blockquote>
<p>注意：部署在<strong>gitee pages</strong>上要正确填写<code>_config.yml</code>的<code>url</code>和<code>root</code>参数</p>
</blockquote>
<ul>
<li>url: https:&#x2F;&#x2F;名字.gitee.io&#x2F;blog</li>
<li>root: &#x2F;blog</li>
</ul>
</li>
<li><p><em><strong><code>repo_name</code></strong></em> 就是仓库的名字了 <em><strong><code>branch_name</code></strong></em> 就是仓库的分支名</p>
</li>
<li><p>关于这个建仓库 跟 仓库的管理你可能需要一些 <em><strong>git</strong></em> 的使用知识 具体各位客官自行学习 这里 我可以列举一些可能会使用到的命令</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git init --bare repo_name.git</span><br><span class="line">git checkout --track origin branch_name</span><br><span class="line">git pull</span><br><span class="line">git branch -a</span><br><span class="line">git clone repo_name.git</span><br></pre></td></tr></table></figure>

<ul>
<li>这个仓库是<code>hexo deploy</code> 命令生成的一个静态网页的仓库 所以作者在自己的服务器中 git clone 了这个仓库到一个路径上 然后使用Nginx 配置了该路径的站点 这样就可以访问到这个发布的网站了</li>
<li>如果你想要用自己拥有的域名发布网站一般用这个方法比较方便 当然你也可以使用github 提供 <code>xxx.github.io</code> 这种方式搭建发布的仓库 不过由于作者本身没有用过 这里的详细步骤请客官自行Google学习</li>
<li>这里我贴一下Nginx 的配置吧 这里只是给客官看看配置的例子 由于我配置里面还有很多东西删减 所以 直接拷贝可能无法使用 请客官Google学习以后自行配置 不过应该也差不多的了</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span> nginx;</span><br><span class="line"><span class="attribute">error_log</span> /var/log/nginx/<span class="literal">error</span>.log;</span><br><span class="line"><span class="attribute">pid</span> /run/nginx.pid;</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="comment"># 博客网站</span></span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">server_name</span>  _;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">root</span>         /home/xxx/;</span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">                <span class="attribute">index</span>  index.php index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-写作仓库"><a href="#1-2-写作仓库" class="headerlink" title="1.2 写作仓库"></a>1.2 写作仓库</h3><p>详细各位客官也是看过 <a href="https://hexo.io/">hexo</a>的官网过来的吧 如果不是也先请你们看看官网的一些介绍比如:</p>
<ul>
<li><p>环境配置: npm 下之类的 哎 算了 我还是不忍心 让你们跑来跑去的 所以贴一下出来吧 就是安装一下 <em><strong><a href="http://nodejs.cn/download/">Node.js</a></strong></em> 就好了 至于 node.js 跟 npm 是什么关系这个可以了解一下廖雪峰老师的这篇 <em><strong><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/00143450141843488beddae2a1044cab5acb5125baf0882000">文章</a></strong></em></p>
</li>
<li><p>初始搭建的命令 相信客官都看了 官网的这个命令 这个命令就是 初始化博客 这个作者称之为 <em><strong><code>写作仓库</code></strong></em></p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo init blog</span><br><span class="line">cd blog</span><br><span class="line">npm install</span><br><span class="line">hexo server</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于博客都会有主题 每个主题的布置 都不一样 代码不一样 所以 当客官添加评论功能 站长统计功能 添加的 js 代码的地方也不一样</p>
</li>
<li><p>作者使用的是 <em><strong><a href="https://github.com/YenYuHsuan/hexo-theme-beantech">BeanTech</a></strong></em> 的主题</p>
</li>
<li><p>所以 作者是 fork 了 BeanTech 的主题然后 在这个仓库里进行 写作的 所以这就是作者所说的 写作仓库</p>
</li>
<li><p>在这个仓库中 日常主要执行的命令如下:</p>
  <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo new article_name</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></li>
<li><p>注意这个仓库保存什么文件忽略什么文件 这一点很重要 否则会出现很奇怪的现象:</p>
<ul>
<li><p>a. 现象: 比如说 你有两台 checkout 了这个仓库的 设备 你把 其中一台A 仓库目录 <code>.deploy_git</code> 及其里面的文件都提交了 在另一台设备B 拉取了A 设备提交的 <code>.deploy_git</code>,当在B 设备 执行<code>hexo deploy</code> 时 会改变当前写作仓库的 <code>.git</code> 目录下的 <code>config</code> 文件</p>
</li>
<li><p>b. 所以 那么写作仓库究竟应该追踪什么文件 跟 忽略什么文件呢 作者为你 列举如下:</p>
<ul>
<li><p>跟踪文件:</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scaffolds/</span><br><span class="line">source/</span><br><span class="line">themes/</span><br><span class="line">_config.yml</span><br><span class="line">.gitignore</span><br><span class="line">package.json</span><br><span class="line">LISCEN</span><br></pre></td></tr></table></figure>
</li>
<li><p>忽略文件 <code>.gitignore</code>:</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">node_modules/</span><br><span class="line">package-lock.json</span><br><span class="line">public/</span><br><span class="line">.deploy_git/</span><br><span class="line">LICENSE</span><br><span class="line">db.json</span><br><span class="line">.deploy_git</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-blog-小功能"><a href="#2-blog-小功能" class="headerlink" title="2. blog 小功能"></a>2. blog 小功能</h2><h3 id="2-1-增加来必力评论功能"><a href="#2-1-增加来必力评论功能" class="headerlink" title="2.1 增加来必力评论功能"></a>2.1 增加来必力评论功能</h3><ol>
<li>首先你需要到 <em><strong><a href="https://www.livere.com/login_form">来必力</a></strong></em> 注册账号 得到来必力的 账号id</li>
<li>来必力评论 SNS 可以选择QQ 微博 微信 Github Facebook 注册以后进入设置界面就能看到的了</li>
<li>为BeanTech 添加 来必力 评论 代码<ul>
<li><p>themes&#x2F;beantech&#x2F;layout&#x2F;post.ejs</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;article&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">            <span class="comment">&lt;!-- Post Container --&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                col-lg-8 col-lg-offset-2</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                col-md-10 col-md-offset-1</span></span></span></span><br><span class="line"><span class="string"><span class="tag"><span class="language-xml">                post-container&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                &lt;%- page.content %&gt;</span></span><br><span class="line"><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">                &lt;% if(config[&#x27;livere_uid&#x27;]) &#123; %&gt;</span></span><br><span class="line"><span class="language-xml">                    <span class="comment">&lt;!-- disqus 评论框 start --&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;comment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;lv-container&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;city&quot;</span> <span class="attr">data-uid</span>=<span class="string">&quot;&lt;%= config[&#x27;livere_uid&#x27;] %&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                    <span class="comment">&lt;!-- disqus 评论框 end --&gt;</span></span></span><br><span class="line"><span class="language-xml">                &lt;% &#125; %&gt;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/article&gt;</span><br><span class="line"></span><br><span class="line">&lt;% <span class="keyword">if</span>(config[<span class="string">&#x27;livere_uid&#x27;</span>]) &#123; %&gt;</span><br><span class="line">    &lt;!-- 来必力<span class="title class_">City</span>版公共<span class="variable constant_">JS</span>代码 <span class="title function_">start</span> (一个网页只需插入一次) --&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    (<span class="keyword">function</span>(<span class="params">d, s</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">var</span> j, e = d.<span class="title function_">getElementsByTagName</span>(s)[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">LivereTower</span> === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="keyword">return</span>; &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        j = d.<span class="title function_">createElement</span>(s);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        j.<span class="property">src</span> = <span class="string">&#x27;https://cdn-city.livere.com/js/embed.dist.js&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        j.<span class="property">async</span> = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        e.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(j, e);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    &#125;)(<span class="variable language_">document</span>, <span class="string">&#x27;script&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>为正常使用来必力评论功能请激活JavaScript<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span></span><br><span class="line">    &lt;!-- 来必力<span class="title class_">City</span>版 公共<span class="variable constant_">JS</span>代码 end --&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure>

<p>  就是把livere_uid 后面那几行代码 考到 post.ejs 大概这个位置就可以了 主要参考着BeanTech 主题的 disqus 多说评论 代码 就好了</p>
</li>
<li><p>themes&#x2F;beantech&#x2F;layout&#x2F;page.ejs</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;!-- 如果开启评论功能 --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span>(page.<span class="property">comments</span>) &#123; %&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span>(config[<span class="string">&#x27;livere_uid&#x27;</span>]) &#123; %&gt;</span><br><span class="line">        &lt;!-- disqus 评论框 start --&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;comment&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;lv-container&quot;</span> <span class="attr">data-id</span>=<span class="string">&quot;city&quot;</span> <span class="attr">data-uid</span>=<span class="string">&quot;&lt;%= config[&#x27;livere_uid&#x27;] %&gt;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        &lt;!-- disqus 评论框 end --&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line"></span><br><span class="line">    &lt;% <span class="keyword">if</span>(config[<span class="string">&#x27;livere_uid&#x27;</span>]) &#123; %&gt;</span><br><span class="line">        &lt;!-- 来必力<span class="title class_">City</span>版公共<span class="variable constant_">JS</span>代码 <span class="title function_">start</span> (一个网页只需插入一次) --&gt;</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            (<span class="keyword">function</span>(<span class="params">d, s</span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">var</span> j, e = d.<span class="title function_">getElementsByTagName</span>(s)[<span class="number">0</span>];</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="title class_">LivereTower</span> === <span class="string">&#x27;function&#x27;</span>) &#123; <span class="keyword">return</span>; &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                j = d.<span class="title function_">createElement</span>(s);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                j.<span class="property">src</span> = <span class="string">&#x27;https://cdn-city.livere.com/js/embed.dist.js&#x27;</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                j.<span class="property">async</span> = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">                e.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(j, e);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">            &#125;)(<span class="variable language_">document</span>, <span class="string">&#x27;script&#x27;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>为正常使用来必力评论功能请激活JavaScript<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span></span><br><span class="line">        &lt;!-- 来必力<span class="title class_">City</span>版 公共<span class="variable constant_">JS</span>代码 end --&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h3 id="2-2-增加音乐功能"><a href="#2-2-增加音乐功能" class="headerlink" title="2.2 增加音乐功能"></a>2.2 增加音乐功能</h3><ul>
<li><p>也是修改post.ejs, page.ejs两个文件 感谢 <em><strong><a href="https://github.com/metowolf/MetingJS">MetingJS</a></strong></em></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;!-- <span class="built_in">require</span> <span class="title class_">APlayer</span> --&gt;</span><br><span class="line">&lt;% <span class="keyword">if</span>(config[<span class="string">&#x27;metingjs&#x27;</span>]) &#123; %&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.css&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/aplayer@1.10/dist/APlayer.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/meting@1.2/dist/Meting.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;aplayer&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">data-id</span>=<span class="string">&quot;&lt;%= config[&#x27;data-id&#x27;] %&gt;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">data-server</span>=<span class="string">&quot;&lt;%= config[&#x27;data-server&#x27;] %&gt;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">data-type</span>=<span class="string">&quot;&lt;%= config[&#x27;data-type&#x27;] %&gt;&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">data-fixed</span>=<span class="string">&quot;&lt;%= config[&#x27;data-fixed&#x27;] %&gt;&quot;</span> &gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">&lt;% &#125; %&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="2-3-增加站点统计功能"><a href="#2-3-增加站点统计功能" class="headerlink" title="2.3 增加站点统计功能"></a>2.3 增加站点统计功能</h3><ul>
<li><em><strong><a href="https://web.umeng.com/">cnzz</a></strong></em> 注册账号 注册以后就拿到一串js 代码 把它 拷贝到 footer.ejs 文件中的 <code>&lt;footer&gt; &lt;/footer&gt;</code> 就好了</li>
<li>有些浏览器可能看不到效果 请换个浏览器试试</li>
</ul>
<h2 id="3-关于写作"><a href="#3-关于写作" class="headerlink" title="3. 关于写作"></a>3. 关于写作</h2><p>用markdown写作用于生成目录的子标题必须从”<strong>##</strong>“开始, 不能用”#”, 这样会导致生成的目录不能跳转</p>
]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>blog</tag>
      </tags>
  </entry>
  <entry>
    <title>Obsidian 使用技巧</title>
    <url>/2022/04/10/Obsidian%20%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="Obsidian-使用技巧"><a href="#Obsidian-使用技巧" class="headerlink" title="Obsidian 使用技巧"></a>Obsidian 使用技巧</h1><h2 id="1-quickadd-cmenu-templater-kanban-插件"><a href="#1-quickadd-cmenu-templater-kanban-插件" class="headerlink" title="1. quickadd + cmenu +templater + kanban 插件"></a>1. quickadd + cmenu +templater + kanban 插件</h2><blockquote>
<p>学习资料视频：<a href="https://www.bilibili.com/video/BV1j34y197cw">obsidian 无障碍联动效率插件 | 手把手打造高效双链个人知识库 | 全主观分享与推荐 | template | quickadd | cmenu</a> </p>
</blockquote>
<blockquote>
<p>学习视频内嵌模式</p>
</blockquote>
<iframe src="//player.bilibili.com/player.html?aid=807319927&bvid=BV1j34y197cw&cid=459209679&page=2" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<ol>
<li>templater 用于设置文章模板</li>
<li>quickadd  + cmenu 用于生成 <code>根据模板新建文章</code> 的快捷按钮</li>
<li>kanban 用于根据 任务 <code>- [ ]</code>生成 看板 主要用于日常 todolist</li>
<li>使用 taskList + checklist 追踪 <code>#check</code> 任务</li>
<li>calendar  + daily note 日记</li>
<li>banner 文章顶部背景</li>
<li>Linter + YAML 模板头</li>
<li>admonition 插件 用做 汇总查询 todolist 的背景部件 具体看 <code>diaryTemplate</code> 模板</li>
<li>Tasks插件的查询语法详情请看<a href="https://www.bilibili.com/read/cv14259903">【效率办公】Obsidain插件之Tasks-任务管理利器</a></li>
</ol>
<h2 id="2-Dataview"><a href="#2-Dataview" class="headerlink" title="2. Dataview"></a>2. Dataview</h2><h3 id="1-Dataview-查询语法"><a href="#1-Dataview-查询语法" class="headerlink" title="1. Dataview 查询语法"></a>1. Dataview 查询语法</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">```dataview</span><br><span class="line">TABLE|LIST|TASK（展现形式）   &lt;field&gt; [AS &quot;显示列名&quot;],..., &lt;field&gt; （显示字段）</span><br><span class="line"></span><br><span class="line">FROM &lt;source&gt; (like #tag or &quot;folder&quot;)  （查询地址）</span><br><span class="line"></span><br><span class="line">WHERE &lt;expression&gt; (like &#x27;field = value&#x27;)、contains(tags,&quot;ob/ob插件&quot;)  （查询条件）</span><br><span class="line"></span><br><span class="line">SORT &lt;expression&gt; [ASC/DESC] (like &#x27;field ASC&#x27;)  （排序）</span><br><span class="line"></span><br><span class="line">...other data commands  （其他命令，如limit,group by等）</span><br><span class="line"></span><br><span class="line">```</span><br></pre></td></tr></table></figure>

<p>学习资料:</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/480239685">【效率办公】Obsidain插件之DataView-高效信息动态查询插件</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/393550306">obsidian插件dataview官方文档翻译</a></li>
<li><a href="https://www.jianshu.com/p/d1e19530897a">Step3-知其所以然：一文讲透Obsidian插件DataviewJS</a></li>
</ul>
<ol>
<li><p>List 查询<br> <img src="https://pic3.zhimg.com/80/v2-15696f4b94599e36caeff3853bf4e95a_720w.jpg" alt="List查询"></p>
</li>
<li><p>Table 查询<br> <img src="https://pic1.zhimg.com/80/v2-b832f990bcf903ee780a4e045255643c_720w.jpg"></p>
</li>
<li><p>Task查询<br> <img src="https://pic3.zhimg.com/80/v2-11243c43b5af8f1381cb9d390896238a_720w.jpg"> </p>
</li>
<li><p>Calendar 查询<br> <img src="https://pic3.zhimg.com/80/v2-727b843c979e9259f2b7331795d8d4b2_720w.jpg"></p>
</li>
<li><p>DataView 查询字段及命令<br> <img src="https://pic2.zhimg.com/80/v2-51a5b1ea04461d2a55817fc543d79b5d_720w.jpg"><br> <img src="https://pic4.zhimg.com/80/v2-4f1b5823824ac4dd4175e7fd45811a9b_720w.jpg"></p>
</li>
<li><p>DataView 字段标识<br> <img src="https://pic2.zhimg.com/80/v2-6332b4ff68d06f5b920db268cfe27d91_720w.jpg"></p>
</li>
<li><p>隐含字段</p>
<p> dataview能自动的对每个页面添加大量的元数据。</p>
<ul>
<li><code>file.name</code>: 该文件标题(字符串)。</li>
<li><code>file.folder</code>: 该文件所在的文件夹的路径(字符串)。</li>
<li><code>file.path</code>: 该文件的完整路径(字符串)。</li>
<li><code>file.link</code>: 该文件的一个链接(链接)。</li>
<li><code>file.size</code>: 该文件的大小(bytes)(数字)</li>
<li><code>file.ctime</code>: 该文件的创建日期(日期和时间)。</li>
<li><code>file.cday</code>: 该文件的创建日期(仅日期)。</li>
<li><code>file.mtime</code>: 该文件最后编辑日期(日期和时间)。</li>
<li><code>file.mday</code>: 该文件最后编辑日期(仅日期)。</li>
<li><code>file.tags</code>: 笔记中所有标签组成的数组。子标签按每个级别进行细分，所以<code>#Tag/1/A</code>将会在数组中储存为<code>[#Tag, #Tag/1, #Tag/1/A]</code>。</li>
<li><code>file.etags</code>: 笔记中所有显式标签组成的数组；不同于<code>file.tags</code>，不包含子标签。</li>
<li><code>file.outlinks</code>: 该文件所有外链(outgoing link)组成的数组。</li>
<li><code>file.aliases</code>: 笔记中所有别名组成的数组。<br>如果文件的标题内有一个日期（格式为yyyy-mm-dd或yyyymmdd），或者有一个Date字段&#x2F;inline字段，它也有以下属性:</li>
<li><code>file.day</code>: 一个该文件的隐含日期。</li>
</ul>
</li>
</ol>
<h3 id="2-Dataviewjs-API"><a href="#2-Dataviewjs-API" class="headerlink" title="2. Dataviewjs API"></a>2. Dataviewjs API</h3><ol>
<li>原始API</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/** A function which maps an array element to some value. */</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">ArrayFunc</span>&lt;T, O&gt; = <span class="function">(<span class="params">elem: T, index: number, arr: T[]</span>) =&gt;</span> O;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** A function which compares two types (plus their indices, if relevant). */</span></span><br><span class="line"><span class="keyword">export</span> type <span class="title class_">ArrayComparator</span>&lt;T&gt; = <span class="function">(<span class="params">a: T, b: T</span>) =&gt;</span> number;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Proxied interface which allows manipulating array-based data. All functions on a data array produce a NEW array</span></span><br><span class="line"><span class="comment"> * (i.e., the arrays are immutable).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> interface <span class="title class_">DataArray</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">/** The total number of elements in the array. */</span></span><br><span class="line">    <span class="attr">length</span>: number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Filter the data array down to just elements which match the given predicate. */</span></span><br><span class="line">    <span class="title function_">where</span>(<span class="attr">predicate</span>: <span class="title class_">ArrayFunc</span>&lt;T, boolean&gt;): <span class="title class_">DataArray</span>&lt;T&gt;;</span><br><span class="line">    <span class="comment">/** Alias for &#x27;where&#x27; for people who want array semantics. */</span></span><br><span class="line">    <span class="title function_">filter</span>(<span class="attr">predicate</span>: <span class="title class_">ArrayFunc</span>&lt;T, boolean&gt;): <span class="title class_">DataArray</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map elements in the data array by applying a function to each. */</span></span><br><span class="line">    map&lt;U&gt;(<span class="attr">f</span>: <span class="title class_">ArrayFunc</span>&lt;T, U&gt;): <span class="title class_">DataArray</span>&lt;U&gt;;</span><br><span class="line">    <span class="comment">/** Map elements in the data array by applying a function to each, then flatten the results to produce a new array. */</span></span><br><span class="line">    flatMap&lt;U&gt;(<span class="attr">f</span>: <span class="title class_">ArrayFunc</span>&lt;T, U[]&gt;): <span class="title class_">DataArray</span>&lt;U&gt;;</span><br><span class="line">    <span class="comment">/** Mutably change each value in the array, returning the same array which you can further chain off of. */</span></span><br><span class="line">    <span class="title function_">mutate</span>(<span class="attr">f</span>: <span class="title class_">ArrayFunc</span>&lt;T, any&gt;): <span class="title class_">DataArray</span>&lt;any&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Limit the total number of entries in the array to the given value. */</span></span><br><span class="line">    <span class="title function_">limit</span>(<span class="attr">count</span>: number): <span class="title class_">DataArray</span>&lt;T&gt;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Take a slice of the array. If `start` is undefined, it is assumed to be 0; if `end` is undefined, it is assumbed</span></span><br><span class="line"><span class="comment">     * to be the end of the array.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">slice</span>(start?: number, end?: number): <span class="title class_">DataArray</span>&lt;T&gt;;</span><br><span class="line">    <span class="comment">/** Concatenate the values in this data array with those of another data array. */</span></span><br><span class="line">    <span class="title function_">concat</span>(<span class="attr">other</span>: <span class="title class_">DataArray</span>&lt;T&gt;): <span class="title class_">DataArray</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Return the first index of the given (optionally starting the search) */</span></span><br><span class="line">    <span class="title function_">indexOf</span>(<span class="attr">element</span>: T, fromIndex?: number): number;</span><br><span class="line">    <span class="comment">/** Return the first element that satisfies the given predicate. */</span></span><br><span class="line">    <span class="title function_">find</span>(<span class="attr">pred</span>: <span class="title class_">ArrayFunc</span>&lt;T, boolean&gt;): T | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">/** Find the index of the first element that satisfies the given predicate. Returns -1 if nothing was found. */</span></span><br><span class="line">    <span class="title function_">findIndex</span>(<span class="attr">pred</span>: <span class="title class_">ArrayFunc</span>&lt;T, boolean&gt;): number;</span><br><span class="line">    <span class="comment">/** Returns true if the array contains the given element, and false otherwise. */</span></span><br><span class="line">    <span class="title function_">includes</span>(<span class="attr">element</span>: T): boolean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return a sorted array sorted by the given key; an optional comparator can be provided, which will</span></span><br><span class="line"><span class="comment">     * be used to compare the keys in leiu of the default dataview comparator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sort&lt;U&gt;(<span class="attr">key</span>: <span class="title class_">ArrayFunc</span>&lt;T, U&gt;, direction?: <span class="string">&#x27;asc&#x27;</span> | <span class="string">&#x27;desc&#x27;</span>, comparator?: <span class="title class_">ArrayComparator</span>&lt;U&gt;): <span class="title class_">DataArray</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return an array where elements are grouped by the given key; the resulting array will have objects of the form</span></span><br><span class="line"><span class="comment">     * &#123; key: &lt;key value&gt;, rows: DataArray &#125;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    groupBy&lt;U&gt;(<span class="attr">key</span>: <span class="title class_">ArrayFunc</span>&lt;T, U&gt;, comparator?: <span class="title class_">ArrayComparator</span>&lt;U&gt;): <span class="title class_">DataArray</span>&lt;&#123; <span class="attr">key</span>: U, <span class="attr">rows</span>: <span class="title class_">DataArray</span>&lt;T&gt; &#125;&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Return distinct entries. If a key is provided, then rows with distinct keys are returned.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    distinct&lt;U&gt;(key?: <span class="title class_">ArrayFunc</span>&lt;T, U&gt;, comparator?: <span class="title class_">ArrayComparator</span>&lt;U&gt;): <span class="title class_">DataArray</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Return true if the predicate is true for all values. */</span></span><br><span class="line">    <span class="title function_">every</span>(<span class="attr">f</span>: <span class="title class_">ArrayFunc</span>&lt;T, boolean&gt;): boolean;</span><br><span class="line">    <span class="comment">/** Return true if the predicate is true for at least one value. */</span></span><br><span class="line">    <span class="title function_">some</span>(<span class="attr">f</span>: <span class="title class_">ArrayFunc</span>&lt;T, boolean&gt;): boolean;</span><br><span class="line">    <span class="comment">/** Return true if the predicate is FALSE for all values. */</span></span><br><span class="line">    <span class="title function_">none</span>(<span class="attr">f</span>: <span class="title class_">ArrayFunc</span>&lt;T, boolean&gt;): boolean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Return the first element in the data array. Returns undefined if the array is empty. */</span></span><br><span class="line">    <span class="title function_">first</span>(): T;</span><br><span class="line">    <span class="comment">/** Return the last element in the data array. Returns undefined if the array is empty. */</span></span><br><span class="line">    <span class="title function_">last</span>(): T;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map every element in this data array to the given key, and then flatten it.*/</span></span><br><span class="line">    <span class="title function_">to</span>(<span class="attr">key</span>: string): <span class="title class_">DataArray</span>&lt;any&gt;;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Recursively expand the given key, flattening a tree structure based on the key into a flat array. Useful for handling</span></span><br><span class="line"><span class="comment">     * heirarchical data like tasks with &#x27;subtasks&#x27;.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="title function_">expand</span>(<span class="attr">key</span>: string): <span class="title class_">DataArray</span>&lt;any&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Run a lambda on each element in the array. */</span></span><br><span class="line">    <span class="title function_">forEach</span>(<span class="attr">f</span>: <span class="title class_">ArrayFunc</span>&lt;T, <span class="keyword">void</span>&gt;): <span class="keyword">void</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Convert this to a plain javascript array. */</span></span><br><span class="line">    <span class="title function_">array</span>(): T[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Allow iterating directly over the array. */</span></span><br><span class="line">    [<span class="title class_">Symbol</span>.<span class="property">iterator</span>](): <span class="title class_">Iterator</span>&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Map indexes to values. */</span></span><br><span class="line">    [<span class="attr">index</span>: number]: any;</span><br><span class="line">    <span class="comment">/** Automatic flattening of fields. */</span></span><br><span class="line">    [<span class="attr">field</span>: string]: any;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>代码块参考</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```dataviewjs</span><br><span class="line">dv.table([], ...)</span><br><span class="line"></span><br><span class="line">dv.current()</span><br><span class="line"></span><br><span class="line">dv.pages(&quot;#books&quot;) =&gt; all pages with tag &#x27;books&#x27;</span><br><span class="line">dv.pages(&#x27;&quot;folder&quot;&#x27;) =&gt; all pages from folder &quot;folder&quot;</span><br><span class="line">dv.pages(&quot;#yes or -#no&quot;) =&gt; all pages with tag #yes, or which DON&#x27;T have tag #no</span><br><span class="line"></span><br><span class="line">dv.pagePaths(&quot;#books&quot;) =&gt; the paths of pages with tag &#x27;books&#x27;</span><br><span class="line"></span><br><span class="line">dv.page(&quot;Index&quot;) =&gt; The page object for /Index</span><br><span class="line">dv.page(&quot;books/The Raisin.md&quot;) =&gt; The page object for /books/The Raisin.md</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dv.list([1, 2, 3]) =&gt; list of 1, 2, 3</span><br><span class="line">dv.list(dv.pages().file.name) =&gt; list of all file names</span><br><span class="line">dv.list(dv.pages().file.link) =&gt; list of all file links</span><br><span class="line">dv.list(dv.pages(&quot;#book&quot;).where(p =&gt; p.rating &gt; 7)) =&gt; list of all books with rating greater than </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// List all tasks from pages marked &#x27;#project&#x27;</span><br><span class="line">dv.taskList(dv.pages(&quot;#project&quot;).file.tasks)</span><br><span class="line"></span><br><span class="line">// List all *uncompleted* tasks from pages marked #project</span><br><span class="line">dv.taskList(dv.pages(&quot;#project&quot;).file.tasks</span><br><span class="line">    .where(t =&gt; !t.completed))</span><br><span class="line"></span><br><span class="line">// List all tasks tagged with &#x27;#tag&#x27; from pages marked #project</span><br><span class="line">dv.taskList(dv.pages(&quot;#project&quot;).file.tasks</span><br><span class="line">	.where(t =&gt; t.text.includes(&quot;#tag&quot;)))</span><br><span class="line"></span><br><span class="line">// Render a simple table of book info sorted by rating.</span><br><span class="line">dv.table([&quot;File&quot;, &quot;Genre&quot;, &quot;Time Read&quot;, &quot;Rating&quot;], dv.pages(&quot;#book&quot;)</span><br><span class="line">    .sort(b =&gt; b.rating)</span><br><span class="line">    .map(b =&gt; [b.file.link, b.genre, b[&quot;time-read&quot;], b.rating]))</span><br><span class="line">    </span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>查询例子：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">```dataviewjs</span><br><span class="line">for (let group of dv.pages(&quot;#book&quot;).where(p =&gt; p[&quot;time-read&quot;].year == 2021).groupBy(p =&gt; p.genre)) &#123;</span><br><span class="line"> 	dv.header(3, group.key);</span><br><span class="line"> 	dv.table([&quot;Name&quot;, &quot;Time Read&quot;, &quot;Rating&quot;],</span><br><span class="line">	 group.rows</span><br><span class="line">		 .sort(k =&gt; k.rating, &#x27;desc&#x27;)</span><br><span class="line">		 .map(k =&gt; [k.file.link, k[&quot;time-read&quot;], k.rating]))</span><br><span class="line">&#125;</span><br><span class="line">```</span><br></pre></td></tr></table></figure>
<h2 id="3-配置文件-PicGo-Core"><a href="#3-配置文件-PicGo-Core" class="headerlink" title="3. 配置文件 | PicGo-Core"></a>3. <a href="https://picgo.github.io/PicGo-Core-Doc/zh/guide/config.html#%E6%89%8B%E5%8A%A8%E7%94%9F%E6%88%90">配置文件 | PicGo-Core</a></h2>]]></content>
      <tags>
        <tag>diary/year2022</tag>
        <tag>diary/month04</tag>
        <tag>quickadd</tag>
        <tag>cmenu</tag>
        <tag>templater</tag>
        <tag>kanban</tag>
        <tag>calendar</tag>
        <tag>obsidian</tag>
        <tag>dataview</tag>
        <tag>banner</tag>
        <tag>dataviewjs</tag>
        <tag>Linter</tag>
        <tag>admonition</tag>
      </tags>
  </entry>
  <entry>
    <title>bash 脚本</title>
    <url>/2024/07/07/bash-%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="bash-脚本"><a href="#bash-脚本" class="headerlink" title="bash 脚本"></a>bash 脚本</h1><h2 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">history  5</span><br><span class="line">grep -10 &#x27;qsm&#x27; test.log//打印匹配行的前后10行</span><br></pre></td></tr></table></figure>

<h2 id="分割大文本文件"><a href="#分割大文本文件" class="headerlink" title="分割大文本文件"></a>分割大文本文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">wc</span> -l all.log</span><br><span class="line"><span class="built_in">split</span> -l 35000 -d --verbose all.log all-log-split-</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `<span class="built_in">ls</span> | grep all-log-split-`;<span class="keyword">do</span> a=`<span class="built_in">echo</span> <span class="variable">$i</span>.txt`; <span class="built_in">mv</span> <span class="variable">$i</span> <span class="variable">$a</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<p>Here is a footnote reference,[^1] and another.[^longnote]</p>
<h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>[^1]: Here is the footnote.<br>[^longnote]: Here’s one with multiple blocks.</p>
]]></content>
      <tags>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title>Build Blog</title>
    <url>/2018/11/18/build-blog/</url>
    <content><![CDATA[<p>今天花了一天的时间建博客 心很累 昨天就开始研究的了 但是昨天一直卡在一个有 js bug的 hexo 主题上面 <a href="https://github.com/Huxpro/huxpro.github.io">Hux</a> 各种留 issue求教 没反应 研究不下来 溜了溜了</p>
<p>今天早上稍微看了一下昨天的问题 还是不行 决定放弃 转投其他比如 <a href="ttps://github.com/YenYuHsuan/hexo-theme-beantech.git">BeanTech</a> 直接可用 但还是心累</p>
<p>后来我就开始改东西啦 各种网站名 作者乱七八糟的配置 遇到改主题 这个卡了好久 最后还是放弃 是什么故事呢 且听我娓娓道来 哎 但是我现在好饿 一天只吃了早餐 到现在 差不多晚上八点了… 我的天折腾了一天</p>
<p>好了 是什么呢 就是用 nginx 建个文件服务器 用来给 markdown存放 resource 图片之类的引用 然后给他建了个目录 作为跳转下载 然后 就是 php 变量名 . 跟 _ 的转换 正则表达式 一切准备就绪 然而 填上主题背景的获取 ip 后 发现并不能获取展现出来 不懂 js 所以不知道为什么 哎 倒不如说不想去看 js 代码吧 然后直接放弃 文件服务器 直接把自己的资源放在工程里面了 这样 别人都拿到我的照片了啊啊啊啊 心累 不过先暂时这样吧 没心情捣鼓了</p>
<p>心累二 接着 发现 图片显示不美观 然后又各种截图 直到美观为止…<br>心累三 找 js 代码里面 Beantech 写死的网址 配置什么的 然后 改 也累 我是对前端代码非常抗拒 真的 太~~~~~臃肿了<br>心累四 _config.yml里面关于作者介绍的字符串变量<code>sidebar-about-description</code> 中间加了<code>&lt;br&gt;</code> 并没有换行 然后对比 BeanTech 的参考源 Hux 的代码 发现并不一样啊 然后 <a href="https://github.com/Huxpro/huxpro.github.io">Hux</a> 的能换行 BeanTech 的不行</p>
<p>Hux 的源文件short-about.ejs</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;&lt;%= config[<span class="string">&#x27;sidebar-about-description&#x27;</span>] %&gt;&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>Hux 的源文件short-about.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;site.sidebar-about-description&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>是的 我有试过把 Hux 的拷过来 明显不行 声明类的方式 读取配置的方式 不一样吧 感觉 哎 反正不懂 反正很烦 好吧 但我还是稍微查了一下 js 的语法 想看看 有没有什么方法能够让<code>&lt;%= %&gt;</code> 它读到的字符串 能够识别这个换行符 然而找不到啊  炸了 放弃了<br>我不行了 我太饿了 再见</p>
]]></content>
      <tags>
        <tag>build blog</tag>
      </tags>
  </entry>
  <entry>
    <title>GDB note</title>
    <url>/2018/12/20/gdb-note/</url>
    <content><![CDATA[<h2 id="start"><a href="#start" class="headerlink" title="start"></a>start</h2><blockquote>
<p>gdb programname &#x2F; gdb programname corefile<br>gdb programname -symbol 符号表 -core corefile -directory srccodePath</p>
</blockquote>
<h2 id="cmd"><a href="#cmd" class="headerlink" title="cmd"></a>cmd</h2><blockquote>
<p>list : source code<br>break n<br>break func<br>break … if i &#x3D; 100<br>info break</p>
</blockquote>
<hr>
<blockquote>
<p>run &#x2F; r<br>next &#x2F; n<br>continue &#x2F; c<br>print &#x2F; p<br>bt<br>finish 运行到当前函数结束<br>编译时 -g 将看不见 函数名 变量名, 只看到内存地址<br>gdb中 执行 shell cmd: make<br>set args …<br>show args …<br>path 指定运行路径<br>show path<br>info terminal<br>run &gt; outfile<br>info programname</p>
</blockquote>
<hr>
<blockquote>
<p>breakpoint, watchpoint, catchpoint, signals,thread stop<br>watch expr<br>rwatch expr 被读时暂停<br>awatch expr 被读写时暂停<br>info watchpoint</p>
</blockquote>
<hr>
<blockquote>
<p>catch throw<br>catch catch<br>catcg exec<br>catch fork&#x2F;vfork<br>catch load&#x2F;unload</p>
</blockquote>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>Debug</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2018/12/21/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>javascript 笔记</title>
    <url>/2024/07/06/javascript-%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="javascript-笔记"><a href="#javascript-笔记" class="headerlink" title="javascript 笔记"></a>javascript 笔记</h1><h2 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h2><p><a href="https://cloud.tencent.com/developer/article/1797513">JavaScript 中的一次性定时器和周期性定时器</a><br><a href="https://iknow.fun/2020/06/02/javascript-es6-10/#1-1-%E8%AF%BE%E7%A8%8B%E5%AF%BC%E5%AD%A6-%E8%AF%95%E7%9C%8B">JavaScript ES6-10 语法</a><br><a href="https://www.cnblogs.com/it-Ren/p/13062999.html">HTML&#x2F;CSS switch 开关 （包括 JS 控制 checked 选择）</a><br><a href="https://geek-docs.com/javascript/javascript-ask-answer/102_tk_1703987553.html">JavaScript 字典遍历用法介绍</a><br><a href="https://geek-docs.com/javascript/javascript-ask-answer/55_hk_1709422196.html">JS 字典遍历</a><br><a href="https://sweetalert.js.org/guides/">非阻塞弹窗</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> [key, value] <span class="keyword">of</span> <span class="title class_">Object</span>.<span class="title function_">entries</span>(object)) &#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> points = [<span class="number">40</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">25</span>, <span class="number">10</span>];</span><br><span class="line">points.<span class="title function_">sort</span>(<span class="keyword">function</span> (<span class="params">a, b</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//	var a=&#x27;xixi&#x27;;  function  object number string boolean undefined</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a == <span class="string">&quot;undefined&quot;</span> || a == <span class="literal">null</span>) <span class="title function_">alert</span>(<span class="string">&quot;a is undefined&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="title function_">alert</span>(<span class="string">&quot;a is defined&quot;</span>);</span><br><span class="line"></span><br><span class="line">myString = <span class="string">&quot;129&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="built_in">parseInt</span>(myString)); <span class="comment">// expected result: 129</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Number</span>(<span class="string">&quot;10.33&quot;</span>); <span class="comment">// returns 10.33</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(+<span class="string">&quot;&quot;</span>); <span class="comment">// expected output: 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;10 20 30&quot;</span>); <span class="comment">// returns 10</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;10 years&quot;</span>); <span class="comment">// returns 10</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;years 10&quot;</span>); <span class="comment">// returns NaN</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">&quot;1222&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Math</span>.<span class="title function_">floor</span>(str)); <span class="comment">// returns 1222</span></span><br><span class="line"></span><br><span class="line">str = <span class="string">&quot;2344&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(str * <span class="number">1</span>); <span class="comment">// expected result: 2344</span></span><br><span class="line"></span><br><span class="line">negStr = <span class="string">&quot;-234&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(~~negStr); <span class="comment">// expected result: -234</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">10</span>&#125;, <span class="function">(<span class="params">val, i</span>) =&gt;</span> i) <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">keys</span>()) <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">10</span>&#125;)).<span class="title function_">map</span>(<span class="function">(<span class="params">val, i </span>) =&gt;</span> +i) <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">[...<span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">10</span>).<span class="title function_">keys</span>()]; <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line">[...<span class="title class_">Array</span>.<span class="title function_">from</span>(&#123;<span class="attr">length</span>: <span class="number">10</span>&#125;).<span class="title function_">keys</span>()] <span class="comment">// [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

<h3 id="js中-function-function-function-之间的区别"><a href="#js中-function-function-function-之间的区别" class="headerlink" title="js中(function(){}()) (function(){})() $(function(){});之间的区别"></a><a href="https://blog.csdn.net/stpice/article/details/80586444">js中(function(){}()) (function(){})() $(function(){});之间的区别</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这两种写法，都是一种立即执行函数的写法，即IIFE (Immediately Invoked Function Expression)。这种函数在函数定义的地方就直接执行了。</span></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;())</span><br><span class="line"></span><br><span class="line">(<span class="keyword">function</span>(<span class="params"></span>)&#123;&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="comment">//是$(document).ready(function()&#123;/*...*/&#125;)的简写形式，是在DOM加载完成后执行的回调函数，并且只会执行一次。</span></span><br><span class="line">$(<span class="keyword">function</span>(<span class="params"></span>)&#123;<span class="comment">/*...*/</span>&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo\bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo:bar&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;#foo\bar&quot;</span>); <span class="comment">// &quot;#fooar&quot;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#foo\bar&quot;</span>); <span class="comment">// 不匹配任何元素</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;#foo\\bar&quot;</span>); <span class="comment">// &quot;#foo\bar&quot;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;#foo\\\\bar&quot;</span>); <span class="comment">// &quot;#foo\\bar&quot;</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#foo\\\\bar&quot;</span>); <span class="comment">// 匹配第一个 div</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#foo:bar&quot;</span>); <span class="comment">// 不匹配任何元素</span></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;#foo\\:bar&quot;</span>); <span class="comment">// 匹配第二个 div</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;.myclass&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> el = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&quot;div.user-panel.main input[name=&#x27;login&#x27;]&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="bun"><a href="#bun" class="headerlink" title="bun"></a><a href="https://bun.sh/docs/installation">bun</a></h2><ul>
<li>windows install</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bun --revision</span><br><span class="line">powershell -c <span class="string">&quot;irm bun.sh/install.ps1|iex&quot;</span></span><br><span class="line">bun add -d @types/bun</span><br><span class="line">bun add -d @types/react@latest @types/react-dom@latest</span><br><span class="line">bun add -d @babel/core @babel/preset-react</span><br><span class="line">bun add -d @types/figlet</span><br><span class="line"></span><br><span class="line">bun --watch run dev</span><br><span class="line"></span><br><span class="line"><span class="comment">#`foo, bar and baz`</span></span><br><span class="line">bun run --filter <span class="string">&#x27;ba*&#x27;</span> &lt;script&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;console.log(&#x27;Hello&#x27;)&quot;</span> | bun run -</span><br><span class="line"></span><br><span class="line">bun --smol run index.tsx</span><br><span class="line"></span><br><span class="line">bun --<span class="built_in">print</span> process.env</span><br><span class="line">bun --<span class="built_in">print</span> process.env.production</span><br><span class="line">bun --<span class="built_in">print</span> process.env.development</span><br><span class="line">bun --<span class="built_in">print</span> process.env.local</span><br><span class="line"></span><br><span class="line">bun build ./cli.ts --compile --outfile mycli</span><br><span class="line"><span class="comment"># cli.ts</span></span><br><span class="line">console.log(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line"></span><br><span class="line">bun build --compile --target=bun-windows-x64 ./path/to/my/app.ts --outfile myapp</span><br><span class="line"></span><br><span class="line">bun build --compile --target=bun-linux-x64 ./index.ts --outfile myapp</span><br><span class="line"></span><br><span class="line">bun build --compile --target=bun-darwin-x64 ./path/to/my/app.ts --outfile myapp</span><br><span class="line"></span><br><span class="line">bun build --compile --minify --sourcemap ./path/to/my/app.ts --outfile myapp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="弹窗插件"><a href="#弹窗插件" class="headerlink" title="弹窗插件"></a>弹窗插件</h3><ul>
<li><a href="https://sweetalert2.github.io/#examples">sweetalert2</a></li>
<li><a href="https://sweetalert2.github.io/recipe-gallery/queue-with-progress-steps.html">弹窗队列案列</a></li>
</ul>
<h4 id="弹窗队列"><a href="#弹窗队列" class="headerlink" title="弹窗队列"></a>弹窗队列</h4><ul>
<li>自己实现的 开箱即用的弹窗队列 源码 <a href="https://raw.githubusercontent.com/Zirpon/zirpon.github.io/master/source/src/AlertQueue.js">AlertQueue</a></li>
</ul>
<h3 id="jsx"><a href="#jsx" class="headerlink" title="jsx"></a>jsx</h3><ul>
<li>bun add -d @types&#x2F;react@latest</li>
</ul>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Component</span>(<span class="params">props: &#123; message: string &#125;</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> (</span><br><span class="line">		<span class="language-xml"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">			<span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&#123;&#123;</span> <span class="attr">color:</span> &quot;<span class="attr">red</span>&quot; &#125;&#125;&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">		<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></span><br><span class="line">	);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">Component</span> <span class="attr">message</span>=<span class="string">&quot;Hello world!&quot;</span> /&gt;</span></span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> db <span class="keyword">from</span> <span class="string">&quot;./my.db&quot;</span> <span class="keyword">with</span> &#123; <span class="attr">tags</span>: <span class="string">&quot;sqlite&quot;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(db.<span class="title function_">query</span>(<span class="string">&quot;select * from users LIMIT 1&quot;</span>).<span class="title function_">get</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> myEmbeddedDb <span class="keyword">from</span> <span class="string">&quot;./my.db&quot;</span> <span class="keyword">with</span> &#123; <span class="attr">tags</span>: <span class="string">&quot;sqlite&quot;</span>, <span class="attr">embed</span>: <span class="string">&quot;true&quot;</span> &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(myEmbeddedDb.<span class="title function_">query</span>(<span class="string">&quot;select * from users LIMIT 1&quot;</span>).<span class="title function_">get</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// this becomes an internal file path</span></span><br><span class="line"><span class="keyword">import</span> icon <span class="keyword">from</span> <span class="string">&quot;./icon.png&quot;</span> <span class="keyword">with</span> &#123; <span class="attr">tags</span>: <span class="string">&quot;file&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">import</span> &#123; file &#125; <span class="keyword">from</span> <span class="string">&quot;bun&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title function_">fetch</span>(<span class="params">req</span>) &#123;</span><br><span class="line">    <span class="comment">// Embedded files can be streamed from Response objects</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Response</span>(<span class="title function_">file</span>(icon));</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> icon <span class="keyword">from</span> <span class="string">&quot;./icon.png&quot;</span> <span class="keyword">with</span> &#123; <span class="attr">tags</span>: <span class="string">&quot;file&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">import</span> &#123; file &#125; <span class="keyword">from</span> <span class="string">&quot;bun&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> bytes = <span class="keyword">await</span> <span class="title function_">file</span>(icon).<span class="title function_">arrayBuffer</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; stuff &#125; <span class="keyword">from</span> <span class="string">&quot;./my-commonjs.cjs&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Stuff</span> <span class="keyword">from</span> <span class="string">&quot;./my-commonjs.cjs&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> myStuff = <span class="built_in">require</span>(<span class="string">&quot;./my-commonjs.cjs&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="plugin-没看太懂"><a href="#plugin-没看太懂" class="headerlink" title="plugin 没看太懂"></a><a href="https://bun.sh/docs/runtime/plugins">plugin</a> 没看太懂</h3><h2 id="Javascrip-变声-文字转语音"><a href="#Javascrip-变声-文字转语音" class="headerlink" title="Javascrip 变声 文字转语音"></a>Javascrip 变声 文字转语音</h2><p><a href="https://github.com/w-okada/voice-changer">https://github.com/w-okada/voice-changer</a><br>AI 语音开源模型下载地址：<a href="https://discord.gg/aihub">https://discord.gg/aihub</a></p>
<p><a href="https://blog.csdn.net/cnds123/article/details/137920674">HTML5+JavaScript 实现语音合成（文字转语音）</a><br><a href="https://segmentfault.com/a/1190000041989692">JS 实现将文字转换为语音并自动播放</a><br><a href="https://www.bilibili.com/video/BV11F41197AP/?spm_id_from=333.880.my_history.page.click&vd_source=b48342a630f5cc1a5c86649a37c0db89">最新 rvc 实时变声（附模型、安装、教程地址）voice-changer，AI 唱歌</a><br><a href="https://github.com/Venryx/w-okada-voice-changer-scripts/tree/master">js 版本变声器</a></p>
<h2 id="javascript-3D-渲染"><a href="#javascript-3D-渲染" class="headerlink" title="javascript 3D 渲染"></a>javascript 3D 渲染</h2><ul>
<li><a href="https://sketchfab.com/developers/data-api/v3" title="website title">sketchfab_doc</a></li>
<li><a href="https://support.fab.com/s/article/Embedding-your-3D-models">epic_sketchfab</a></li>
<li><a href="https://sketchfab.com/3d-models/old-god-elder-dragon-be305f220c404e28afa073ddbc62873d" title="Old God Elder Dragon">dragon</a></li>
<li>sketchfab</li>
<li><a href="http://webgl3d.cn/pages/aac9ab/">threejs_doc</a></li>
</ul>
<p>Here is a footnote reference,[^1] and another.[^longnote]</p>
<h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>[^1]: Here is the footnote.<br>[^longnote]: Here’s one with multiple blocks.</p>
]]></content>
      <tags>
        <tag>javascript</tag>
        <tag>文字转语音</tag>
        <tag>threejs</tag>
        <tag>3D</tag>
        <tag>sketchfab</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux iptables note</title>
    <url>/2018/12/20/iptables-note/</url>
    <content><![CDATA[<h2 id="iptables-note"><a href="#iptables-note" class="headerlink" title="iptables note"></a>iptables note</h2><ul>
<li><p>在tcp协议中，禁止所有的ip访问本机的<code>9902</code>端口。</p>
<blockquote>
<p>iptables -I INPUT -p tcp –dport 9902 -j DROP</p>
</blockquote>
</li>
<li><p>允许 <code>223.104.63.111</code> 访问本机的 <code>9902</code> 端口</p>
<blockquote>
<p>iptables -I INPUT -s 223.104.63.111 -p tcp –dport 9902 -j ACCEPT</p>
</blockquote>
</li>
<li><p>修改 规则 时间有效期</p>
<blockquote>
<p>iptables -R INPUT 2 -s 223.104.63.111 -m time –datestart 2018-12-19T09:00:08 –datestop 2018-12-19T09:30:00 -p tcp –dport 9902 -j ACCEPT</p>
</blockquote>
<p>  iptables 时间基于UTC时间 所以 先用 命令 <code>date --utc</code> 跟 <code>date</code> 查看 本地时间与UTC时间的时差</p>
</li>
<li><p>允许 <code>113.111.245.62</code> 访问本机的 <code>9902</code> 端口</p>
<blockquote>
<p>iptables -I INPUT -s 113.111.245.62 -p tcp –dport 9902 -j ACCEPT</p>
</blockquote>
</li>
<li><p>MAC地址的设备和这个iptables不在一个子网里，就没用</p>
<blockquote>
<p>iptables -I INPUT -m mac –mac-source a0:4e:a7:43:80:c4 -p tcp –dport 9902 -j ACCEPT</p>
</blockquote>
</li>
<li><p>清除预设表filter中的所有规则链的规则  </p>
<blockquote>
<p>iptables -F</p>
</blockquote>
</li>
<li><p>允许 <code>113.111.0.0/16</code> 访问本机的 <code>9902</code> 端口</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">iptables -I INPUT -s 113.111.0.0/16 -p tcp --dport 9902 -j ACCEPT</span><br><span class="line">iptables -I INPUT -s 116.22.128.0/20 -p tcp --dport 9902 -j ACCEPT</span><br><span class="line">iptables -I INPUT -s 223.64.0.0/10 -p tcp --dport 9902 -j ACCEPT</span><br><span class="line">iptables -I INPUT -s 223.96.0.0/12 -p tcp --dport 9902 -j ACCEPT</span><br><span class="line">iptables -I INPUT -s 223.104.60.0/22 -p tcp --dport 9902 -j ACCEPT</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>device</th>
<th>ip</th>
</tr>
</thead>
<tbody><tr>
<td>宿舍</td>
<td>116.22.132.155</td>
</tr>
<tr>
<td>公司</td>
<td>113.111.185.3,113.111.245.62</td>
</tr>
<tr>
<td>手机</td>
<td>223.104.63.111</td>
</tr>
</tbody></table>
<ul>
<li>yum install -y iptables-services</li>
<li>&#x2F;etc&#x2F;sysconfig&#x2F;iptables</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sample configuration for iptables service</span><br><span class="line"># you can edit this manually or use system-config-firewall</span><br><span class="line"># please do not ask us to add additional ports/services to this default configuration</span><br><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [0:0]</span><br><span class="line">:FORWARD ACCEPT [0:0]</span><br><span class="line">:OUTPUT ACCEPT [0:0]</span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT</span><br><span class="line">#-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">#-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-A INPUT -s 113.111.0.0/16 -p tcp --dport 9902 -j ACCEPT</span><br><span class="line">-A INPUT -s 116.22.128.0/20 -p tcp --dport 9902 -j ACCEPT</span><br><span class="line">-A INPUT -s 223.104.60.0/22 -p tcp --dport 9902 -j ACCEPT</span><br><span class="line">#-A INPUT -s 223.104.63.111 -p tcp --dport 9902 -j ACCEPT</span><br><span class="line">#-A INPUT -s 116.22.132.155 -p tcp --dport 9902 -j ACCEPT</span><br><span class="line">#-A INPUT -s 116.22.134.122 -p tcp --dport 9902 -j ACCEPT</span><br><span class="line">-A INPUT -p tcp --dport 9905 -j DROP</span><br><span class="line">-A INPUT -p tcp --dport 9902 -j DROP</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure>

<ul>
<li>iptables-service</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chkconfig iptables on</span><br><span class="line">service iptables reload/status/start</span><br></pre></td></tr></table></figure>

<ul>
<li>iptables -F 清除预设表filter中的所有规则链的规则</li>
<li>iptables -X 清除预设表filter中使用者自定链中的规则</li>
<li>iptables -L -n 查看本机关于IPTABLES的设置情况 <strong>远程连接规则将不能使用</strong></li>
</ul>
<hr>
]]></content>
      <tags>
        <tag>Linux</tag>
        <tag>unix</tag>
        <tag>iptables</tag>
        <tag>network</tag>
        <tag>firewall</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL 8.0 note</title>
    <url>/2018/11/28/mysql-8.0-note/</url>
    <content><![CDATA[<h2 id="mysql-8-0-安装-note"><a href="#mysql-8-0-安装-note" class="headerlink" title="mysql 8.0 安装 note"></a>mysql 8.0 安装 note</h2><p>我真的佛了 今天装个mysql 8.0 各种坑 好像不支持 设置set password&#x3D; password(“123456”) 这样的写法 各种报错<br>要</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;MyNewPass&#x27;;</span><br><span class="line"></span><br><span class="line">ERROR 1819 (HY000): Your password does notsatisfy the current policy requirements</span><br><span class="line"></span><br><span class="line">mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27;IDENTIFIED BY &#x27;MyNewPass@123&#x27;;</span><br><span class="line"></span><br><span class="line">ERROR 1396 (HY000): Operation ALTER USERfailed for &#x27;root&#x27;@&#x27;localhost&#x27;</span><br><span class="line"></span><br><span class="line">mysql&gt; alter user&#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED BY &#x27;MyNewPass@123&#x27;;</span><br></pre></td></tr></table></figure>

<p>还有他的密码<a href="https://blog.csdn.net/hellosunqi/article/details/70941754">安全策略</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT REPLICATION CLIENT ON *.*TO &#x27;zabbix&#x27;@&#x27;%&#x27; IDENTIFIED BY ‘xxxxxxxx’;</span><br><span class="line"></span><br><span class="line">ERROR 1819 (HY000): Your password does notsatisfy the current policy requirements</span><br></pre></td></tr></table></figure>

<p>这个与validate_password_policy的值有关。</p>
<p>validate_password_policy有以下取值：<br>0 or LOW<br>Length<br>1 or MEDIUM<br>Length; numeric, lowercase&#x2F;uppercase, and special characters<br>2 or STRONG<br>Length; numeric, lowercase&#x2F;uppercase, and special characters; dictionary file</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; set global validate_password_length=0；</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; SHOW VARIABLES LIKE &#x27;validate_password%&#x27;;</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| Variable_name                       | Value |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">| validate_password_dictionary_file    |       |</span><br><span class="line">| validate_password_length             | 4    |</span><br><span class="line">| validate_password_mixed_case_count   | 1     |</span><br><span class="line">| validate_password_number_count       | 1     |</span><br><span class="line">| validate_password_policy             | LOW  |</span><br><span class="line">| validate_password_special_char_count | 1     |</span><br><span class="line">+--------------------------------------+-------+</span><br><span class="line">6 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>还有一个修改存储过程 权限什么的</p>
<p>总之 我佛了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先创建用户tom，密码为tom</span><br><span class="line">mysql&gt; create user &#x27;tom&#x27;@&#x27;loaclhost&#x27; identified by &#x27;tom&#x27;;</span><br><span class="line"># 再赋予具体表glodon_test权限</span><br><span class="line">mysql&gt; GRANT ALL privileges ON glodon_test TO &#x27;tom&#x27;@&#x27;localhost&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.08 sec)</span><br><span class="line"># 刷新权限即可生效</span><br><span class="line">mysql&gt; flush privileges;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>健身笔记</title>
    <url>/2021/01/06/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%B8%85soserious_1.png" alt="帅soserious_1"></p>
<p>胸： 飞鸟 推举 俯卧撑<br>背： 哑铃单臂划船 引体向上 悬挂带反向划船 俯卧撑 让背部两块肌肉夹紧的动作<br>肩： 肩推 侧平举 面拉 耸肩<br>腿： 只能深蹲 高位臀桥<br>臂：臂屈伸 二头弯举 三头拉伸(扶墙拿水瓶向后拉伸)</p>
<p>单个水瓶1.1kg 不力竭换 大水瓶或者哑铃</p>
<table>
<thead>
<tr>
<th>胸</th>
<th>背</th>
<th>肩</th>
<th>腿</th>
<th>手臂</th>
</tr>
</thead>
<tbody><tr>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E4%B8%8A%E6%96%9C%E5%93%91%E9%93%83%E6%8E%A8%E4%B8%BE.gif"> <img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%93%91%E9%93%83%E4%B8%8A%E6%96%9C%E6%8F%A1%E6%8E%A8.jpg"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%9D%90%E5%A7%BF%E4%B8%8B%E6%8B%89.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%93%91%E9%93%83%E8%82%A9%E6%8E%A8.jpg"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E8%85%BF%E4%B8%BE.jpeg"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E7%BB%B3%E7%B4%A2%E8%87%82%E5%B1%88%E4%BC%B8.gif"></td>
</tr>
<tr>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%B9%B3%E6%9D%BF%E6%9D%A0%E9%93%83%E5%8D%A7%E6%8E%A8.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%99%A8%E6%A2%B0%E5%88%92%E8%88%B9.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%93%91%E9%93%83%E4%BE%A7%E5%B9%B3%E4%B8%BE.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E6%B7%B1%E8%B9%B2.jpg"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E7%BB%B3%E7%B4%A2%E4%BA%8C%E5%A4%B4%E5%BC%AF%E4%B8%BE.gif"></td>
</tr>
<tr>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%93%91%E9%93%83%E9%A3%9E%E9%B8%9F.png"> <img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E7%BB%B3%E7%B4%A2%E9%A3%9E%E9%B8%9F.png"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E7%BB%B3%E7%B4%A2%E5%88%92%E8%88%B9.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E7%BB%B3%E7%B4%A2%E4%BE%A7%E5%B9%B3%E4%B8%BE.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E8%85%BF%E5%B1%88%E4%BC%B8.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E7%BB%B3%E7%B4%A2%E4%B8%8B%E5%8E%8B.png"> <img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E7%BB%B3%E7%B4%A2%E4%B8%8B%E5%8E%8B.gif"></td>
</tr>
<tr>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E4%BF%AF%E5%8D%A7%E6%92%91.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E7%BB%B3%E7%B4%A2%E7%9B%B4%E6%9D%86%E4%B8%8B%E5%8E%8B.png"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E7%BB%B3%E7%B4%A2%E9%9D%A2%E6%8B%89.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E8%85%BF%E5%BC%AF%E4%B8%BE.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%9E%82%E5%BC%8F%E5%BC%AF%E4%B8%BE.jpg"> <img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E9%94%A4%E5%BC%8F%E5%BC%AF%E4%B8%BE.gif"></td>
</tr>
<tr>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E7%BB%B3%E7%B4%A2%E4%B8%8B%E5%8E%8B.png"> <img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E7%BB%B3%E7%B4%A2%E4%B8%8B%E5%8E%8B.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%93%91%E9%93%83%E6%AD%A3%E6%8F%A1%E5%BC%AF%E4%B8%BE.jpg"> <img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%93%91%E9%93%83%E9%94%A4%E5%BC%8F%E5%BC%AF%E4%B8%BE.gif"></td>
<td><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%93%91%E9%93%83%E8%80%B8%E8%82%A9.gif"></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<hr>
<!-- 
{ flink }
- class_name: 胸
  class_desc:
  link_list:
    - name: 上斜哑铃推举
      link: https://zirpon.github.io/2021/01/06/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/
      avatar: https://zirpon.github.io/img/健身笔记/上斜哑铃推举.gif
      descr:   胸
    - name: 哑铃上斜握推
      link: https://zirpon.github.io/2021/01/06/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/
      avatar: https://zirpon.github.io/img/健身笔记/哑铃上斜握推.jpg
      descr:   胸
    - name: 平板杠铃卧推
      link: https://zirpon.github.io/2021/01/06/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/
      avatar: https://zirpon.github.io/img/健身笔记/平板杠铃卧推.gif
      descr: 胸
    - name: 绳索飞鸟
      link: https://zirpon.github.io/2021/01/06/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/
      avatar: https://zirpon.github.io/img/健身笔记/绳索飞鸟.png
      descr: 胸
    - name: 绳索直杆下压
      link: https://zirpon.github.io/2021/01/06/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/
      avatar: https://zirpon.github.io/img/健身笔记/绳索直杆下压.png
      descr: 胸
    - name: 俯卧撑
      link: https://zirpon.github.io/2021/01/06/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/
      avatar: https://zirpon.github.io/img/健身笔记/俯卧撑.gif
      descr:    胸   
{ endflink %}
-->

<hr>
<div class="gallery-container" data-type="data" data-button="" data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"https://zirpon.github.io/img/健身笔记/上斜哑铃推举.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/哑铃上斜握推.jpg","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/坐姿下拉.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/哑铃肩推.jpg","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/平板杠铃卧推.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/器械划船.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/哑铃侧平举.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/哑铃飞鸟.png","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/绳索飞鸟.png","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/绳索划船.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/绳索侧平举.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/俯卧撑.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/绳索直杆下压.png","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/绳索面拉.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/绳索下压.png","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/绳索下压.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/哑铃正握弯举.jpg","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/哑铃锤式弯举.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/哑铃耸肩.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/腿举.jpeg","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/绳索臂屈伸.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/深蹲.jpg","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/绳索二头弯举.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/腿屈伸.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/绳索下压.png","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/绳索下压.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/腿弯举.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/垂式弯举.jpg","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/锤式弯举.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/单笔划船.gif","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/悬挂反向划船.png","alt":"","title":""},{"url":"https://zirpon.github.io/img/健身笔记/人体肌群分布.jpg","alt":"","title":""}]</div>
  </div>

<hr>
<p><a href="https://www.sohu.com/a/26775982_115763" title="上斜哑铃推举">上斜哑铃推举</a><br><a href="https://www.jianshen8.com/xiangmu/gangling/3797.html" title="平板杠铃卧推">平板杠铃卧推</a><br><a href="https://zhuanlan.zhihu.com/p/47741743" title="哑铃上斜握推">哑铃上斜握推</a><br>[哑铃飞鸟]<br>[绳索飞鸟]<br><a href="https://dxy.com/article/28105" title="俯卧撑">俯卧撑</a><br><a href="https://baijiahao.baidu.com/s?id=1801172181200687791" title="绳索下压">绳索下压</a><br><a href="https://www.jianshen8.com/jirou/beibu/3877.html" title="坐姿下拉">坐姿下拉</a><br><a href="https://zhuanlan.zhihu.com/p/166001324" title="器械划船">器械划船</a><br><a href="https://www.jianshen8.com/jirou/beibu/3880.html" title="绳索划船">绳索划船</a><br>[哑铃正握弯举]<br><a href="https://zhuanlan.zhihu.com/p/405219168" title="哑铃锤式弯举">哑铃锤式弯举</a><br><a href="https://www.jianshen8.com/xiangmu/yaling/3817.html" title="哑铃肩推">哑铃肩推</a><br><a href="https://baijiahao.baidu.com/s?id=1804979026950277400" title="哑铃侧平举">哑铃侧平举</a><br><a href="https://www.jianshen8.com/jirou/jianbu/13094.html" title="绳索侧平举">绳索侧平举</a><br><a href="https://www.zhihu.com/tardis/zm/art/53242447?source_id=1005" title="绳索面拉">绳索面拉</a><br>[哑铃耸肩]<br><a href="https://www.sohu.com/a/194508544_99954444" title="腿举">腿举</a><br><a href="https://zhuanlan.zhihu.com/p/65685567" title="深蹲">深蹲</a><br><a href="https://www.jianshen8.com/jirou/tuibu/3902.html" title="腿屈伸">腿屈伸</a><br><a href="https://www.jianshen8.com/jirou/tuibu/3904.html" title="腿弯举">腿弯举</a><br>[绳索臂屈伸]<br>[绳索二头弯举]<br>[垂式弯举]<br><a href="https://www.sohu.com/a/821921754_121124676" title="锤式弯举">锤式弯举</a></p>
<p><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%B8%85soserious_2.png" alt="帅soserious_2"><br><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%B8%85soserious_3.png" alt="帅soserious_3"><br><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%B8%85soserious_4.gif" alt="帅soserious_4"></p>
<h1 id="1-某个博主的分享"><a href="#1-某个博主的分享" class="headerlink" title="1. 某个博主的分享"></a>1. 某个博主的分享</h1><h2 id="1-1-一开始"><a href="#1-1-一开始" class="headerlink" title="1.1 一开始"></a>1.1 一开始</h2><ul>
<li>6:30 (全麦面包 + 2 egg + 脱脂牛奶)<ul>
<li>跑步 3公里</li>
<li>4组开合跳</li>
<li>4组 高抬腿</li>
</ul>
</li>
<li>中午 白水煮鸡胸 + 蔬菜沙拉 + 全麦面包</li>
<li>晚上 (1 egg +  1 piece 面包 + 牛奶)<ul>
<li>5 公里</li>
<li>4 组开合跳</li>
</ul>
</li>
</ul>
<h2 id="1-2-两周后完全停止跑步-开始力量训练-3周"><a href="#1-2-两周后完全停止跑步-开始力量训练-3周" class="headerlink" title="1.2 两周后完全停止跑步 开始力量训练 3周"></a>1.2 两周后完全停止跑步 开始力量训练 3周</h2><ul>
<li>负重深蹲<br><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%81%A5%E8%BA%AB%E5%8A%9B%E9%87%8F%E8%AE%AD%E7%BB%831.gif" alt="健身力量训练1"><br><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%81%A5%E8%BA%AB%E5%8A%9B%E9%87%8F%E8%AE%AD%E7%BB%832.gif" alt="健身力量训练2"><br><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%81%A5%E8%BA%AB%E5%8A%9B%E9%87%8F%E8%AE%AD%E7%BB%83%E6%B7%B1%E8%B9%B23.gif" alt="健身力量训练深蹲3"></li>
<li>仰卧起坐<br><img src="/../img/%E5%81%A5%E8%BA%AB%E7%AC%94%E8%AE%B0/%E5%81%A5%E8%BA%AB%E5%8A%9B%E9%87%8F%E8%AE%AD%E7%BB%83%E4%BB%B0%E5%8D%A7%E8%B5%B7%E5%9D%90.png" alt="健身力量训练仰卧起坐"></li>
</ul>
<h1 id="2-另一个博主的分享"><a href="#2-另一个博主的分享" class="headerlink" title="2. 另一个博主的分享"></a>2. 另一个博主的分享</h1><ul>
<li>有氧 (持续慢跑 or 走跑间歇)</li>
<li>HIT (每周进行1~2次 高强度hit)<ul>
<li>快跑45秒(12.5公里&#x2F;秒)</li>
<li>放松慢跑30秒</li>
<li>重复8-12组</li>
</ul>
</li>
<li>腹肌训练<ul>
<li>卷腹          15次</li>
<li>俄罗斯转体    40次</li>
<li>卷腹15次</li>
<li>刺拳仰卧起坐  20次</li>
<li>动态平板支撑  10次</li>
<li>卷腹举腿      15次</li>
<li>90度卷腹      15次</li>
</ul>
</li>
</ul>
<h1 id="3-评论区普通人的建议"><a href="#3-评论区普通人的建议" class="headerlink" title="3. 评论区普通人的建议"></a>3. 评论区普通人的建议</h1><ul>
<li>热身</li>
<li>深蹲10分钟</li>
<li>力量训练10分钟</li>
<li>平板支撑1分钟两次</li>
<li>跳绳40分钟(3000个左右)</li>
</ul>
<p>深蹲跟力量训练每天必做 ，其他可以换   可以跑两天步跳三天绳<br>控制饮食，每天6点后除了水跟一点水果不再进食，多喝水，多补充蛋白质，</p>
<p>亲身经历四个月瘦50斤。<br>贵在坚持难在保持，你跑步可以跑的很慢，但你必须跑下去，你跳绳可以跳一个绊一次但请坚持下去</p>
<h1 id="4-哑铃负重深蹲的标准动作讲解"><a href="#4-哑铃负重深蹲的标准动作讲解" class="headerlink" title="4. 哑铃负重深蹲的标准动作讲解"></a>4. 哑铃负重深蹲的标准动作讲解</h1><ul>
<li>自重深蹲</li>
<li>负重深蹲</li>
</ul>
<blockquote>
<p>3-4组*10-20次</p>
</blockquote>
<p>深蹲被誉为“力量训练之王”，很多的健身动作都会结合深蹲的动作。<br>深蹲看似锻炼下半身，实则能够锻炼全身的力量。<br>深蹲时，能够有效刺激<strong>大臀肌</strong>，同时刺激了<strong>骨骼肌</strong>发力。<br>深蹲的标准动作为：<br>    1. 背部呈弓形。<br>    2. 臀部向后坐，重量落在脚后跟。<br>    3. 把握蹲的深度，一般要超过水平面以下。<br>    4. 两腿打开与肩膀同宽。<br>    5. 蹲起的速度不宜过快。</p>
<h2 id="4-1-拿中间"><a href="#4-1-拿中间" class="headerlink" title="4.1 拿中间"></a>4.1 拿中间</h2><p><img src="https://www.fitnes.cn/d/file/dongzuo/2020-04-17/269fc16d8b92d68510451fa918b46db6.jpg" alt="dd"></p>
<p>标准动作:</p>
<ol>
<li><p>双手捧着哑铃，将哑铃摆在胸前，两手内收，肩胛下压放松。双脚与髋关节同宽，脚尖朝前（或微微外八），重点应是下蹲时，<code>膝盖与脚尖同方向</code>。</p>
</li>
<li><p>收臀，保持大腿部位与地面平行或根据自己的灵活程度和柔韧性尽量保持与地面平行。身体重心居中。挺胸、抬头、收腹，深吸一口气。</p>
</li>
<li><p>感受髋关节向后移动（往后、往下坐），过程中胸、被都是维持挺直。身体<code>下蹲并稍向前倾</code>。</p>
</li>
<li><p>最后，保持躯干稳定，脚部向下用力<strong>蹬地</strong>。中心落在脚掌中部，伸膝伸髋向上直直蹲起。回到起始动作。</p>
</li>
</ol>
<p> 4.2 拿两边</p>
<p><img src="https://www.jirou.com/uploads/allimg/190724/153-1ZH4151940F8.jpg" alt="dd"></p>
<ul>
<li>热身</li>
<li>接下来站立之后把哑铃握起来，并且放在身体两侧，在跟随着大家做深蹲的时候，我们的<code>手臂始终要保持不动</code>的姿势</li>
</ul>
<h1 id="5-力量训练"><a href="#5-力量训练" class="headerlink" title="5. 力量训练"></a>5. 力量训练</h1><ul>
<li>肌肉训练：健美运动员增加肌肉的一种训练，目的是最大限度地增长肌肉</li>
<li>力量训练：能刺激身体分泌激素，增加你的基础代谢</li>
</ul>
<blockquote>
<p>力量训练可分为器械训练、自由重量训练、自身徒手重量训练。</p>
</blockquote>
<h2 id="5-1-器械训练"><a href="#5-1-器械训练" class="headerlink" title="5.1 器械训练"></a>5.1 器械训练</h2><p>就是健身中心里最常见的重训机械，最好在使用时咨询现场教练，器械使用前可能需要微调。</p>
<h2 id="5-2-自由重量训练"><a href="#5-2-自由重量训练" class="headerlink" title="5.2 自由重量训练"></a>5.2 自由重量训练</h2><p>是指没有机械的辅助，靠<strong>哑铃</strong>、<strong>杠铃</strong>、<strong>壶铃</strong>或者其他能够负重的器械，如<strong>大轮胎</strong>，<strong>长柄锤</strong>等就可以独立完成的训练。建议有人在旁辅助，重量的选择注意循序渐进。</p>
<h2 id="5-3-自身徒手重量训练"><a href="#5-3-自身徒手重量训练" class="headerlink" title="5.3 自身徒手重量训练"></a>5.3 自身徒手重量训练</h2><p>顾名思义，不用器械，利用自己身体的重量来训练<br>    - 深蹲<br>    - 仰卧起坐等<br>    - 优点大家都知道，简单、省钱<br>    - 缺点是缺乏渐进的阻力，但对于新手足够了，可有效减脂、锻炼心肺和塑形</p>
<ul>
<li><p>四点跪撑：</p>
<p>  <img src="http://img.mp.itc.cn/upload/20160513/b03606e47d8341a8968eff67a8fdf99b.jpg" alt="四点跪撑"></p>
<ul>
<li><p>☆注意膝盖不能接触地面</p>
</li>
<li><p>四点是指两只手和两个脚尖</p>
</li>
<li><p>身体要成“N型”</p>
</li>
<li><p>头、身处于一条直线</p>
</li>
<li><p>臂、身垂直，髋、膝垂直。</p>
</li>
<li><p>腹部收紧，下巴内收</p>
</li>
<li><p>保持<strong>30</strong>秒</p>
</li>
</ul>
</li>
<li><p>猎鸟狗式：<br>  <img src="http://img.mp.itc.cn/upload/20160513/e13672faf89f48d59094eb815cf6ee72.jpg" alt="猎鸟狗式"></p>
<ul>
<li><p>伸直右手、左腿然后手、膝相碰</p>
</li>
<li><p>以此往复</p>
</li>
<li><p>头、身处于一条直线</p>
</li>
<li><p>保持腹部、臀部收紧</p>
</li>
<li><p>左右各10组</p>
<ul>
<li>初级：每组6个，3组；</li>
<li>中级：每组10个，3组；</li>
<li>高级：每组15个，4组。</li>
</ul>
</li>
</ul>
</li>
<li><p>俄罗斯转体</p>
</li>
<li><p>旋腿臀桥</p>
</li>
</ul>
<h1 id="6-平板支撑"><a href="#6-平板支撑" class="headerlink" title="6. 平板支撑"></a>6. 平板支撑</h1><p><img src="https://pic.rmb.bdstatic.com/bjh/news/265556556e20b5db874a4ca532da58ae.gif" alt="平板支撑"></p>
<blockquote>
<p>3-6组*60s-90s</p>
</blockquote>
<p><strong>每组保持60秒，每次训练4组，组与组之间间歇不超过20秒。</strong></p>
<h1 id="7-站姿哑铃平举"><a href="#7-站姿哑铃平举" class="headerlink" title="7. 站姿哑铃平举"></a>7. 站姿哑铃平举</h1><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190829/36bdf8fd40554ba89ebb4e6d9c916cd2.gif" alt="站姿哑铃平举"></p>
<ul>
<li>前平举</li>
<li>侧平举</li>
</ul>
<p>一开始我们站好在地面上，双手握住哑铃自然放松在我们的身体两侧。<br>调整好后，让双手发力，让双手能够向上平举，直到手臂与地面平行，并且双手伸直。然后再放下手臂，重新开始动作。</p>
<blockquote>
<p>3-4组*10-20次</p>
</blockquote>
<h1 id="8-俯卧撑"><a href="#8-俯卧撑" class="headerlink" title="8. 俯卧撑"></a>8. 俯卧撑</h1><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190829/15fdeb0d318e43bea8f3a14ef7f5aa8f.gif" alt="俯卧撑"></p>
<p><strong>初练者</strong>来说，<strong>每天20-30个</strong></p>
<blockquote>
<p>3-4组*10-20次</p>
</blockquote>
<h1 id="9-10-At-Home-Exercises-to-Get-Rid-of-Belly-Fat-In-a-Month"><a href="#9-10-At-Home-Exercises-to-Get-Rid-of-Belly-Fat-In-a-Month" class="headerlink" title="9. 10 At-Home Exercises to Get Rid of Belly Fat In a Month"></a>9. 10 At-Home Exercises to Get Rid of Belly Fat In a Month</h1><ul>
<li><input disabled="" type="checkbox"> five jumping jacks 1 burpee<br><img src="/../img/attachments/Pasted%20image%2020221110070535.png"><br><img src="/../img/attachments/Pasted%20image%2020221110070610.png"></li>
<li><input disabled="" type="checkbox"> 4 mountain climbers 2 sit-throughs<br><img src="/../img/attachments/Pasted%20image%2020221110070645.png"><br><img src="/../img/attachments/Pasted%20image%2020221110070658.png"></li>
<li><input disabled="" type="checkbox"> plyo step-ups<br><img src="/../img/attachments/Pasted%20image%2020221110070723.png"></li>
<li><input disabled="" type="checkbox"> push-ups<br><img src="/../img/attachments/Pasted%20image%2020221110070740.png"></li>
<li><input disabled="" type="checkbox"> 2 split squat jumps 1 burpee<br><img src="/../img/attachments/Pasted%20image%2020221110070818.png"></li>
<li><input disabled="" type="checkbox"> toe taps<br><img src="/../img/attachments/Pasted%20image%2020221110070840.png"></li>
<li><input disabled="" type="checkbox"> plank walks<br><img src="/../img/attachments/Pasted%20image%2020221110070852.png"></li>
<li><input disabled="" type="checkbox"> sprinter sit-ups<br><img src="/../img/attachments/Pasted%20image%2020221110070910.png"></li>
<li><input disabled="" type="checkbox"> squat thrusts<br><img src="/../img/attachments/Pasted%20image%2020221110070922.png"></li>
<li><input disabled="" type="checkbox"> sumo goblet &amp;&amp; squat pulse<br><img src="/../img/attachments/Pasted%20image%2020221110071009.png"></li>
<li><input disabled="" type="checkbox"> 每周慢跑3–4次 每次40分钟</li>
</ul>
<h1 id="10-健身劳累伤痛问题"><a href="#10-健身劳累伤痛问题" class="headerlink" title="10. 健身劳累伤痛问题"></a>10. 健身劳累伤痛问题</h1><h2 id="1-脚底板外侧肌肉疼痛可能由多种原因引起"><a href="#1-脚底板外侧肌肉疼痛可能由多种原因引起" class="headerlink" title="1. 脚底板外侧肌肉疼痛可能由多种原因引起"></a>1. 脚底板外侧肌肉疼痛可能由多种原因引起</h2><p>常见原因和应对建议如下：</p>
<p>可能原因<br>过度使用或劳损</p>
<p>长时间行走、跑步、站立或突然增加运动量可能导致外侧肌肉疲劳。</p>
<p>鞋子不合适（如鞋底太硬、支撑不足）也可能加重负担。</p>
<p>足底筋膜炎</p>
<p>虽然典型疼痛在足跟或足弓，但炎症可能扩散至外侧。</p>
<p>晨起第一步疼痛明显，活动后减轻。</p>
<p>腓骨肌肌腱炎</p>
<p>外侧脚踝至足底的腓骨肌腱过度使用或扭伤可能引发炎症，疼痛可放射至足底外侧。</p>
<p>跖骨应力性损伤</p>
<p>第五跖骨（小趾根部）的应力性骨折或骨膜炎可能导致外侧疼痛，常见于跑步或跳跃后。</p>
<p>足部结构问题</p>
<p>高足弓或扁平足可能导致外侧压力异常。</p>
<p>步态异常（如内翻不足）也可能引发外侧肌肉代偿性疼痛。</p>
<p>神经压迫</p>
<p>外侧足底神经受压（如穿紧鞋、局部肿胀）可能导致刺痛或麻木。</p>
<p>自我缓解方法<br>休息与冰敷</p>
<p>减少活动，避免加重疼痛的动作。</p>
<p>每天冰敷疼痛部位（每次15分钟，2-3次&#x2F;日）。</p>
<p>拉伸与放松</p>
<p>足底筋膜拉伸：坐位，用手将脚趾向后扳，感受足底拉伸，保持20秒，重复3次。</p>
<p>腓骨肌拉伸：坐位，腿伸直，用毛巾绕住前脚掌，将脚向内翻（如图），保持20秒。</p>
<p>用网球或筋膜球滚压足底放松肌肉。</p>
<p>更换鞋子</p>
<p>选择有足弓支撑、缓冲良好的鞋子，避免平底鞋或磨损严重的旧鞋。</p>
<p>抗炎止痛</p>
<p>可短期使用布洛芬等非甾体抗炎药（遵医嘱或说明书）。</p>
<p>何时就医？<br>疼痛持续超过1-2周，休息后无缓解。</p>
<p>出现明显肿胀、发红或发热。</p>
<p>无法正常行走，或疼痛夜间加重。</p>
<p>怀疑骨折（如外伤后剧痛、局部压痛明显）。</p>
<p>医生可能通过X光、超声或MRI检查，并根据结果建议物理治疗、定制鞋垫或药物治疗。</p>
<p>预防建议<br>运动前充分热身，逐步增加运动强度。</p>
<p>选择适合足型的鞋子，必要时使用矫形鞋垫。</p>
<p>避免长时间穿高跟鞋或硬底鞋。</p>
<p>定期进行足部肌肉强化训练（如用脚趾抓毛巾）。</p>
<p>如果疼痛持续或加重，及时就医明确诊断，避免延误治疗！</p>
<h2 id="2-免疫力下降-发炎"><a href="#2-免疫力下降-发炎" class="headerlink" title="2. 免疫力下降 发炎"></a>2. 免疫力下降 发炎</h2><p>免疫力下降与炎症反复发作之间存在密切关联。当免疫力降低时，身体对抗感染和修复损伤的能力减弱，可能导致炎症难以控制或反复出现。以下是可能的原因、应对建议和改善方向：</p>
<p>免疫力下降与炎症关联的常见原因<br>慢性压力</p>
<p>长期压力会导致皮质醇升高，抑制免疫细胞活性，增加炎症因子（如IL-6）释放。</p>
<p>营养不良</p>
<p>缺乏蛋白质、维生素C、D、锌、硒等关键营养素，影响免疫细胞生成和抗炎能力。</p>
<p>睡眠不足</p>
<p>睡眠是免疫系统修复的关键期，长期熬夜会减少抗病毒蛋白（如干扰素）的分泌。</p>
<p>肠道菌群失衡</p>
<p>70%免疫细胞在肠道，菌群失调（如益生菌减少）会削弱免疫屏障，促发慢性炎症。</p>
<p>慢性疾病</p>
<p>糖尿病、自身免疫病（如类风湿关节炎）等会持续消耗免疫资源，导致炎症失控。</p>
<p>药物或治疗影响</p>
<p>长期使用抗生素、激素或化疗可能抑制免疫功能。</p>
<p>应对炎症与提升免疫力的关键措施</p>
<ol>
<li>调整饮食<br>抗炎食物：深海鱼（Omega-3）、姜黄、绿茶、深色蔬菜（富含抗氧化剂）、坚果。</li>
</ol>
<p>增强免疫：优质蛋白（鸡蛋、豆类）、维生素C（柑橘、西兰花）、锌（牡蛎、南瓜子）。</p>
<p>避免促炎食物：精制糖、反式脂肪（油炸食品）、加工肉类。</p>
<ol start="2">
<li>生活方式干预<br>规律睡眠：保证每天7-9小时，尽量在23点前入睡。</li>
</ol>
<p>适度运动：每周150分钟中等强度运动（如快走、游泳），过度运动反而抑制免疫。</p>
<p>减压管理：冥想、深呼吸、瑜伽或心理咨询，降低皮质醇水平。</p>
<ol start="3">
<li>针对性营养补充<br>维生素D：血液浓度建议维持在40-60 ng&#x2F;mL，缺乏者需补充（每日1000-2000 IU）。</li>
</ol>
<p>益生菌：选择含乳酸杆菌、双歧杆菌的补充剂，调节肠道免疫。</p>
<p>抗氧化剂：如NAC（N-乙酰半胱氨酸）、谷胱甘肽，帮助清除炎症自由基。</p>
<ol start="4">
<li>控制感染与炎症<br>急性感染：细菌感染需遵医嘱用抗生素，病毒感染以对症治疗为主。</li>
</ol>
<p>慢性炎症：在医生指导下使用抗炎药物（如低剂量激素、NSAIDs），或尝试天然抗炎剂（姜黄素、乳香提取物）。</p>
<p>何时需要就医？<br>炎症反复发作（如口腔溃疡、皮肤感染、尿路感染等超过每月1次）。</p>
<p>伴随不明原因发热、体重下降、持续疲劳。</p>
<p>出现自身免疫症状：关节肿痛、皮疹、脱发等。</p>
<p>常规措施无效，需排查潜在疾病（如HIV、肿瘤、免疫缺陷病）。</p>
<p>重点排查的医学检查<br>血液检查</p>
<p>血常规（看白细胞、淋巴细胞计数）</p>
<p>C反应蛋白（CRP）、血沉（ESR）评估炎症水平</p>
<p>免疫球蛋白（IgG&#x2F;IgA&#x2F;IgM）、补体水平</p>
<p>维生素D、锌等微量元素检测</p>
<p>其他检查</p>
<p>肠道菌群分析（针对慢性腹泻&#x2F;便秘者）</p>
<p>自身抗体筛查（如ANA、RF）</p>
<p>预防与长期管理<br>戒烟限酒：吸烟直接损伤呼吸道免疫屏障，酒精抑制骨髓造血功能。</p>
<p>接种疫苗：流感疫苗、肺炎疫苗等可减少感染风险。</p>
<p>环境控制：避免长期接触污染空气或化学毒素（如甲醛）。</p>
<p>免疫力下降和炎症反应是身体发出的警示信号，需从生活方式、营养、医学干预多维度调整。若调整后仍无改善，建议尽早到风湿免疫科或内科就诊，避免延误潜在疾病的治疗。</p>
<h2 id="3-ejaculation-免疫力-与健身"><a href="#3-ejaculation-免疫力-与健身" class="headerlink" title="3. ejaculation 免疫力 与健身"></a>3. ejaculation 免疫力 与健身</h2><p>ejaculation后是否会导致免疫力下降，目前医学研究尚无明确一致的结论，但可以从生理机制和现有研究角度分析可能的影响及应对建议：</p>
<p>一、ejaculation后可能的生理变化<br>短暂免疫波动</p>
<p>部分研究表明，性高潮后体内 催乳素（Prolactin） 水平升高，可能短暂抑制免疫细胞（如自然杀伤细胞NK细胞）活性，但这种影响通常是暂时性的（数小时内恢复），不会显著削弱长期免疫力。</p>
<p>营养物质流失</p>
<p>精液中含有锌、蛋白质、维生素C等成分，频繁ejaculation可能导致这些营养素的流失。例如：</p>
<p>锌：每次ejaculation约损失3-5mg锌（成年男性每日推荐摄入量11mg），缺锌可能影响免疫细胞功能。</p>
<p>硒、维生素C：参与抗氧化和免疫调节，过度流失可能增加感染风险。</p>
<p>激素变化与应激反应</p>
<p>性活动后，皮质醇（压力激素）短暂升高可能抑制免疫功能，但适度性行为反而通过释放内啡肽减轻压力，长期看可能对免疫有益。</p>
<p>二、现有研究结论<br>短期影响：</p>
<p>有研究观察到男性在性高潮后2小时内，唾液中的IgA（免疫球蛋白A，黏膜免疫关键成分）水平下降，但24小时内恢复。</p>
<p>另一项研究发现，适度性行为（每周1-2次）可提升IgA水平，降低感冒风险；但过度频繁（如每天）可能适得其反。</p>
<p>长期影响：</p>
<p>目前无证据表明规律ejaculation会直接导致免疫力持续下降。相反，适度性生活可能通过减轻压力、改善睡眠间接增强免疫力。</p>
<p>三、如何减少潜在负面影响<br>控制频率</p>
<p>根据自身状态调整，避免过度频繁ejaculation（如每天多次），尤其是已感到疲劳或营养摄入不足时。</p>
<p>补充关键营养素</p>
<p>锌：牡蛎、红肉、南瓜子、坚果（如每日补充不超过40mg）。</p>
<p>硒：巴西坚果、鱼类、鸡蛋。</p>
<p>维生素C：柑橘类水果、西兰花、彩椒。</p>
<p>蛋白质：鸡蛋、豆类、瘦肉，维持免疫细胞合成。</p>
<p>注重恢复</p>
<p>ejaculation后保证充足睡眠（7-9小时），避免熬夜或剧烈运动后立即进行性活动。</p>
<p>避免极端行为</p>
<p>禁欲或过度纵欲均可能影响免疫平衡，找到适合自身的节奏（如每周1-3次）。</p>
<p>四、需要警惕的情况<br>若ejaculation后出现以下症状，可能与免疫力下降或其他健康问题相关，建议就医排查：</p>
<p>反复感冒、口腔溃疡、伤口愈合缓慢。</p>
<p>持续疲劳、体重下降、夜间盗汗。</p>
<p>伴随睾丸疼痛、排尿异常（需排除前列腺炎或性传播感染）。</p>
<p>总结<br>适度ejaculation本身不会显著降低免疫力，但过度频繁可能导致营养消耗或短期免疫波动。</p>
<p>关键是通过均衡饮食、规律作息和适度运动维持整体免疫健康。</p>
<p>若怀疑免疫力异常，可检测血常规、免疫球蛋白、微量元素（如锌）等指标，针对性调整。</p>
<p>如有其他症状或担忧，建议咨询泌尿外科或免疫科医生进一步评估！</p>
<h2 id="4-补镁锌硒"><a href="#4-补镁锌硒" class="headerlink" title="4. 补镁锌硒"></a>4. 补镁锌硒</h2><p>补锌是维持免疫、生殖、代谢功能的重要措施，尤其对男性健康、伤口愈合和抗感染能力至关重要。以下是科学补锌的详细建议：</p>
<p>一、为什么需要补锌？<br>生理功能</p>
<p>免疫支持：锌参与T淋巴细胞分化，缺锌易导致反复感染（如感冒、腹泻）。</p>
<p>生殖健康：精子生成需要锌，缺锌可能降低精子质量和睾酮水平。</p>
<p>代谢与修复：参与300多种酶活性，促进伤口愈合、皮肤健康及DNA合成。</p>
<p>缺锌的高风险人群</p>
<p>素食者（植物性食物锌吸收率低）</p>
<p>孕妇&#x2F;哺乳期女性（需求量增加）</p>
<p>慢性腹泻或肠道疾病患者（吸收障碍）</p>
<p>频繁ejaculation或高强度运动者（锌流失增加）</p>
<p>二、补锌的科学方法</p>
<ol>
<li>优先食补：高锌食物清单<br>食物类别	推荐食物（每100g含锌量）	每日建议摄入量<br>贝类	牡蛎（16-40mg）	每周1-2次<br>红肉	牛肉（4.8mg）、羊肉（3.9mg）	每日50-100g<br>坚果种子	南瓜子（7.6mg）、腰果（5.6mg）	每日一小把（20-30g）<br>豆类	鹰嘴豆（3.4mg）、黑豆（2.5mg）	每周3-4次<br>乳制品	奶酪（3.1mg）、酸奶（0.5mg）	每日1-2份</li>
</ol>
<p>谷物	全麦面包（1.8mg）、燕麦（2.3mg）	选择未精加工产品<br>注意：动物性食物中的锌（如红肉、贝类）吸收率（约30-40%）高于植物性食物（约10-20%）。</p>
<ol start="2">
<li>锌补充剂选择<br>适用情况：</li>
</ol>
<p>血锌检测显示缺乏（血清锌＜70μg&#x2F;dL）</p>
<p>饮食无法满足需求（如素食者、孕妇）</p>
<p>存在缺锌症状（脱发、味觉减退、反复感染）。</p>
<p>常见类型：</p>
<p>类型	特点	适合人群<br>葡萄糖酸锌	吸收率较高，胃肠道刺激小	儿童、普通成人<br>柠檬酸锌	吸收率最佳，适合空腹服用	胃肠功能正常者<br>锌镁合剂	含镁，协同缓解疲劳	运动人群、压力大者<br>螯合锌（如吡啶甲酸锌）	生物利用率高，价格较贵	严重缺锌或吸收障碍者<br>剂量建议：</p>
<p>普通成人：每日额外补充不超过 15-25mg（中国营养学会推荐成人每日摄入量：男12.5mg，女7.5mg）。</p>
<p>治疗缺锌：遵医嘱短期服用（可高达30-50mg&#x2F;天），疗程通常1-3个月。</p>
<p>服用时间：</p>
<p>餐后1小时服用，减少胃部不适。</p>
<p>避免与钙、铁补充剂同服（间隔至少2小时）。</p>
<p>三、补锌注意事项<br>避免过量</p>
<p>长期超量（＞40mg&#x2F;天）可能抑制铜吸收，引发贫血、神经系统问题。</p>
<p>典型过量症状：恶心、呕吐、头痛。</p>
<p>特殊人群</p>
<p>孕妇：每日需锌9.5-12mg，优先通过食物补充，如需用补充剂需医生指导。</p>
<p>老年人：胃酸分泌减少可能影响吸收，可选择螯合锌或与维生素C同服促进吸收。</p>
<p>药物相互作用</p>
<p>抗生素（如四环素、喹诺酮类）与锌结合降低药效，需间隔2小时服用。</p>
<p>利尿剂（如氢氯噻嗪）可能增加锌排泄，需监测锌水平。</p>
<p>四、缺锌自测与就医建议<br>自测信号：</p>
<p>频繁感冒、口腔溃疡</p>
<p>脱发、指甲白斑</p>
<p>味觉&#x2F;嗅觉减退</p>
<p>儿童发育迟缓、注意力下降。</p>
<p>何时就医：</p>
<p>疑似缺锌且调整饮食后无改善。</p>
<p>伴随慢性腹泻、消瘦或皮肤病变。</p>
<p>需通过 血清锌检测 或 发锌检测 确诊。</p>
<p>五、补锌的协同营养素<br>维生素C：增强锌吸收（如餐后吃橙子）。</p>
<p>维生素A：与锌协同维持黏膜免疫（如胡萝卜、动物肝脏）。</p>
<p>硒：联合补充可提升抗氧化能力（巴西坚果、鱼类）。</p>
<p>总结：补锌应优先通过饮食调整，必要时选择合适补充剂并控制剂量。长期或大剂量补锌需在医生指导下进行，避免盲目补充导致失衡。</p>
<h2 id="5-L-精氨酸片"><a href="#5-L-精氨酸片" class="headerlink" title="5. L-精氨酸片"></a>5. L-精氨酸片</h2><p>L-精氨酸（L-Arginine）是一种条件必需氨基酸，在人体中具有多种生理功能。它通过转化为一氧化氮（NO），参与血管舒张、免疫调节和激素分泌等过程。以下是关于L-精氨酸片的详细解析，包括作用、适用人群、服用建议及注意事项：</p>
<p>一、L-精氨酸的主要作用<br>改善心血管健康</p>
<p>促进一氧化氮生成，扩张血管，改善血液循环。</p>
<p>可能有助于降低血压，缓解心绞痛症状。</p>
<p>增强运动表现</p>
<p>增加肌肉血流量，延缓疲劳，促进运动后恢复。</p>
<p>部分研究显示对耐力运动有益，但效果因人而异。</p>
<p>支持男性生殖健康</p>
<p>改善勃起功能（通过增加阴茎血流）。</p>
<p>可能提高精子质量（需结合其他营养素如锌）。</p>
<p>免疫调节</p>
<p>促进免疫细胞（如T细胞）功能，增强抗感染能力。</p>
<p>其他潜在益处</p>
<p>促进伤口愈合（精氨酸是胶原蛋白合成的原料）。</p>
<p>可能改善胰岛素敏感性（对糖尿病患者有一定帮助）。</p>
<p>二、适用人群<br>心血管疾病患者</p>
<p>高血压、动脉硬化、心绞痛患者（需医生指导下使用）。</p>
<p>运动爱好者</p>
<p>希望提升耐力、加速恢复的健身或跑步爱好者。</p>
<p>男性健康需求者</p>
<p>轻度勃起功能障碍（ED）或精子质量不佳者。</p>
<p>免疫力低下者</p>
<p>反复感染、术后恢复期人群。</p>
<p>其他</p>
<p>皮肤伤口愈合缓慢者。</p>
<p>老年人（改善血管功能，延缓衰老）。</p>
<p>三、服用建议<br>剂量</p>
<p>一般保健：每日500-2000mg，分次服用。</p>
<p>运动表现：运动前30-60分钟服用3000-6000mg。</p>
<p>男性健康：每日3000-5000mg，持续4-12周。</p>
<p>疾病辅助治疗：遵医嘱，可能需要更高剂量（如5000-9000mg&#x2F;天）。</p>
<p>服用时间</p>
<p>空腹服用吸收最佳（餐前1小时或餐后2小时）。</p>
<p>避免与高脂肪食物同服，可能影响吸收。</p>
<p>搭配建议</p>
<p>与瓜氨酸（Citrulline）合用：瓜氨酸可转化为精氨酸，延长作用时间。</p>
<p>与抗氧化剂（如维生素C、E）合用：保护一氧化氮不被氧化。</p>
<p>四、注意事项<br>副作用</p>
<p>常见：胃肠道不适（腹胀、腹泻），多见于高剂量（＞10g&#x2F;天）。</p>
<p>罕见：低血压、电解质失衡（长期高剂量使用）。</p>
<p>禁忌人群</p>
<p>疱疹病毒感染者：精氨酸可能促进病毒复制。</p>
<p>严重肝肾功能不全者：需医生评估。</p>
<p>低血压患者：可能进一步降低血压。</p>
<p>药物相互作用</p>
<p>降压药：可能增强降压效果，需监测血压。</p>
<p>硝酸酯类药物（如硝酸甘油）：合用可能导致血压过低。</p>
<p>抗凝血药：可能增加出血风险。</p>
<p>长期使用</p>
<p>长期高剂量补充可能干扰其他氨基酸代谢，建议周期性使用（如用2-3个月，停1个月）。</p>
<p>五、L-精氨酸的食物来源<br>肉类：牛肉、鸡肉、猪肉。</p>
<p>海鲜：三文鱼、虾、金枪鱼。</p>
<p>坚果种子：核桃、杏仁、南瓜子。</p>
<p>豆类：大豆、鹰嘴豆、扁豆。</p>
<p>乳制品：牛奶、奶酪。</p>
<p>六、常见问题<br>L-精氨酸与精氨酸的区别？</p>
<p>L-精氨酸是精氨酸的天然活性形式，补充剂通常使用L-精氨酸。</p>
<p>L-精氨酸对所有人都有效吗？</p>
<p>效果因人而异，尤其是运动表现和勃起功能改善，部分人可能无明显感受。</p>
<p>可以长期服用吗？</p>
<p>一般保健剂量（＜3g&#x2F;天）可长期使用，但建议定期停用以避免耐受性。</p>
<p>总结<br>L-精氨酸片是一种多功能补充剂，适合心血管健康、运动表现、男性健康及免疫力提升等需求。但需根据个人情况选择合适剂量，并注意禁忌和副作用。如有基础疾病或正在服药，建议咨询医生后再使用。</p>
<hr>
<h1 id="99-总结的TIPS"><a href="#99-总结的TIPS" class="headerlink" title="99. 总结的TIPS"></a>99. 总结的TIPS</h1><h2 id="99-1-小白刚开始进健身房练30-40分钟器械再练有氧（力量训练耗尽糖原后有氧燃脂效率高）"><a href="#99-1-小白刚开始进健身房练30-40分钟器械再练有氧（力量训练耗尽糖原后有氧燃脂效率高）" class="headerlink" title="99.1 小白刚开始进健身房练30-40分钟器械再练有氧（力量训练耗尽糖原后有氧燃脂效率高）"></a>99.1 小白刚开始进健身房练30-40分钟器械再练有氧（<strong>力量训练</strong>耗尽<code>糖原</code>后<strong>有氧</strong>燃脂效率高）</h2><p><strong>高强度间歇训练（high-intensity interval training，HIIT）</strong>：指练习者在极量的运动强度下全力持续运动数十秒，然后短暂休息，再重复短时间全力运动的训练方法，这是一种有氧和无氧运动相结合的锻炼方式，且可以不需要借助任何器械或是工具，能快速燃烧热量，达到减肥的目的</p>
<p> 99.2 无氧运动: anaerobic exercise</p>
<p> 99.2.2 概念:<br>无氧运动是指人体肌肉在无氧供能代谢状态下进行的运动。</p>
<p> 99.2.3 特征:<br>无氧运动大部分是负荷强度高、瞬间性强的运动，所以很难持续长时间，而且疲劳消除的时间也慢。</p>
<p>在运动过程中，身体的新陈代谢是加速的，加速的代谢需要消耗更多的能量。<br>人体的能量是通过身体内的糖、蛋白质和脂肪分解代谢得来的。</p>
<p>无氧运动的最大特征是：运动时氧气的摄取量非常低。<br>由于速度过快及爆发力过猛，人体内的糖分来不及经过氧气分解，而不得不依靠“无氧供能”。</p>
<p>这种运动会在体内产生过多的<strong>乳酸</strong>，导致肌肉疲劳不能持久，运动后感到肌肉酸痛，呼吸急促。</p>
<p>其实是<code>酵解</code>时产生大量<strong>丙酮酸</strong>、<strong>乳酸</strong>等<strong>中间代谢产物</strong>，不能通过呼吸排除。</p>
<p>这些酸性产物堆积在<strong>细胞</strong>和<strong>血液</strong>中，就成了“疲劳毒素”，会让人感到疲乏无力、肌肉酸痛，还会出现呼吸、心跳加快和心律失常，严重时会出现酸中毒和增加肝肾负担。</p>
<p>人体<strong>预存</strong>的ATP能量只能维持极限强度运动大约<strong>2秒</strong>，随后由CP合成ATP，大约能维持6秒，合计<strong>8秒</strong>左右。<br>也就是说，全速跑不到一百米即告罄，跑二百米时后面的一百米，必须由<strong>血糖</strong>在无氧状态下，迅速合成新的热能物质ATP来提供能量，其副产品是乳酸。</p>
<p>跑二百米或四百米、一百米游泳、网球和足球等运动，是利用<strong>肌糖原</strong>无氧分解所提供的能量，故运动后肌肉里累积大量<strong>乳酸</strong>，乳酸堆积是运动后引起肌肉痛的原因之一。</p>
<p> 99.2.4 供能系统:</p>
<p>参与无氧运动的供能系统为ATP-CP系统、糖酵解系统、氧化能系统，</p>
<p>例如，10秒内即可完成的百米跑，ATP-CP系统为主要供能系统，但糖酵解和氧化能系统也同时供应少部分能量。</p>
<h2 id="99-2-4-1-ATP-CP"><a href="#99-2-4-1-ATP-CP" class="headerlink" title="99.2.4.1 ATP-CP"></a>99.2.4.1 ATP-CP</h2><p>细胞可通过分解<strong>磷酸肌酸</strong>提供能量和<strong>无机磷酸</strong>，使ADP重新合成ATP，从而维持ATP水平的稳定，此过程非常迅速，而且不需要细胞内的特定结构即可完成，并且此过程不需要氧即可进行，但也可在有氧条件下进行。</p>
<p>像无氧运动这样的大强度、剧烈运动，在最初的几秒内，ATP含量维持在一个相对不变的水平，但磷酸肌酸含量却不断下降，因为要补充消耗的ATP。</p>
<p>力竭时，ATP和磷酸肌酸的含量显著下降，以至于不能继续提供能量来维持肌肉的收缩和舒张。</p>
<p>因此，分解磷酸肌酸来维持ATP含量的作用是有限的。</p>
<p>体内储存的ATP和磷酸肌酸，既能提供无氧运动（例如全速奔跑）3-15秒的能量供应，超过这个时间以后，肌肉将通过<strong>糖酵解</strong>和有氧氧化产生ATP供能。</p>
<p> 99.2.4.2 糖酵解<br>糖酵解即通过一系列<strong>糖酵解酶</strong>引起<strong>葡萄糖分解</strong>的过程。<br>糖酵解系统远比ATP-CP系统复杂得多，在<strong>糖原</strong>分解成乳酸的过程中需要10-12个<strong>酶促反应</strong>，所有的酶促反应都是在<strong>细胞质</strong>中进行的。</p>
<p>1分子<strong>糖原</strong>在糖酵解过程中会净产3分子的ATP，1分子<strong>葡萄糖</strong>糖酵解过程中会净产2分子ATP。<br>糖酵解系统不能产生大量ATP，但ATP-CP系统和糖酵解系统仍可在氧气不足的情况下提供能量，供肌肉收缩，这两大系统主要为大强度运动的前几分钟供能。</p>
<p>在完整的无氧运动中，这两个系统<strong>只能维持不到2分钟</strong>，长时间的运动需要第三个能量系统——<strong>氧化能系统</strong>。</p>
<h2 id="99-2-4-3-氧化能"><a href="#99-2-4-3-氧化能" class="headerlink" title="99.2.4.3 氧化能"></a>99.2.4.3 氧化能</h2><p>机体在有氧条件下分解底物产生能量的过程，称为细胞内呼吸，此过程需要氧的参与，因此成为有氧过程。<br>在长时间运动中，骨骼肌需要一个稳定的供能系统来维持<strong>肌纤维</strong>的收缩。<br>相对于无氧产生ATP，有氧代谢系统的动员速度慢，但其<strong>具有强大的产能能力</strong>，因此有氧代谢是耐力运动的主要供能方式，但在无氧运动中，虽然产能速率不能跟上机体的运动速度，但其在无氧运动后程供能不可小觑。</p>
<p>研究发现，通过无氧运动可以提高机体的肌肉力量、爆发力、增加肌肉体积，提高运动速度。<br>常见的无氧运动项目有：<code>短跑</code>、<code>举重</code>、<code>投掷</code>、<code>跳高</code>、<code>跳远</code>、<code>拔河</code>、<code>俯卧撑</code>、<code>潜水</code>、<code>肌力训练</code>（长时间的肌肉收缩）等。</p>
<h2 id="99-2-5-无氧运动与有氧运动的区别"><a href="#99-2-5-无氧运动与有氧运动的区别" class="headerlink" title="99.2.5 无氧运动与有氧运动的区别"></a>99.2.5 无氧运动与有氧运动的区别</h2><p>有氧运动也叫做有氧代谢运动，是指人体在氧气充分供应的情况下进行的体育锻炼。</p>
<p>有氧运动的好处是：可以提升氧气的摄取量，能更好地消耗体内多余的热量。</p>
<p>特点是强度低、有节奏、持续时间较长。要求每次锻炼的时间不少于1小时，每周坚持3到5次。</p>
<p>通过这种锻炼，氧气能充分酵解体内的糖分，还可消耗体内脂肪，增强和改善心肺功能，预防骨质疏松，调节心理和精神状态，是健身的主要运动方式。</p>
<p>有氧运动的主要供能方式为<strong>氧化能系统</strong>。</p>
<p>常见的有氧运动项目有：瑜伽、步行、<code>慢跑</code>、滑冰、<code>游泳</code>、<code>骑自行车</code>、打太极拳、跳健身舞、做韵律操等。</p>
<p>人体运动是需要能量的，如果能量来自细胞内的有氧代谢（氧化反应），就是有氧运动；但若能量来自<strong>无氧酵解</strong>，就是无氧运动。</p>
<p>有氧代谢时，充分氧化1个分子葡萄糖，能产生38个ATP的能量；<br>而在无氧酵解时，1个分子的葡萄糖仅产生2个ATP。</p>
<p>有氧运动时葡萄糖代谢后生成水和二氧化碳，可以通过呼吸很容易被排出体外，对人体无害。<br>然而在酵解时产生大量乳酸等中间代谢产物。</p>
<p>两者区别：在增加肌肉力量方面，无氧运动的贡献较大。</p>
<p>一项最新研究显示,握力不够的人更有可能罹患心脏病或者中风,且握力损失越大,风 险越高。</p>
<p>某国一项研究人员花了4年时间跟踪调查了17个国家年龄在35~70岁的14万人,并采用手持设备对受试者的握力进行了衡量。</p>
<p>结果表明,握力每下降5公 斤,跟运动密切相关的 [2]  心血管疾病风险或由其他原因导致的循环系统疾病就相应增加17%。</p>
<p>人体预存的ATP能量只能维持极限强度运动大约2秒，随后由CP合成ATP，大约能维持6秒，合计8秒左右。<br>也就是说，全速跑不到一百米即告罄，跑二百米时后面的一百米，必须由血糖在无氧状态下，迅速合成新的热能物质ATP来提供能量，其副产品是乳酸。<br>跑二百米或四百米、一百米游泳、网球和足球等运动，是利用肌糖原无氧分解所提供的能量，故运动后肌肉里累积大量乳酸，乳酸堆积是运动后引起肌肉痛的原因之一。</p>
<p>肌糖原无氧分解所提供的能量，只能维持一分钟左右，跑完四百米后就全部用完。</p>
<p>跑八百米时，后面的四百米，必须由糖、脂肪酸和氨基酸在有氧状态下，合成新的热能物质ATP来提供能量，而糖由糖原分解后供应，脂肪酸由脂肪分解后供应，氨基酸由蛋白质分解后供应，这整个过程需要氧气，也就是靠氧气燃烧糖、脂肪和蛋白质来生产热能物质ATP，供应后段运动所需的热量，这后段的运动就是有氧运动。</p>
<p>跑八百米或一千五百米、二百和四百米游泳、拳击等运动，都需要开始利用氧气燃烧糖原、脂肪和蛋白质，故此类运动的后段都是有氧运动，作为有氧运动，心率一般在<strong>130次&#x2F;分</strong>为最佳。</p>
<p>运动的前段大约五分钟先烧<strong>糖原</strong>，运动持续越久会烧掉越多的脂肪，只要持续<strong>半小时至一小时</strong>，所消耗热量的五成，就由燃烧<strong>脂肪</strong>来供应。</p>
<p>两者选择：至于选择有氧运动还是无氧运动，首先要看自己的锻炼目的是什么和个人的实际情况。<br>有氧运动的强度相对较低，比较安全，机体各器官的负荷也相对较小，不易出现伤害事故；<br>而无氧运动强度相对高，机体各器官的承受的负荷也是相对较大，可以更好地提高机体的工作能力。</p>
<p>例如，想要<strong>提高自己的心肺机能</strong>，选择有氧运动就比较好。<br>而如果你现在只能举起60斤的重物，你想要提高您的力量，举起70斤的重物，那么你就要选择无氧运动了。<br>无氧运动对于塑造肌肉的线条，增加肌肉力量而言是首选的。</p>
<h2 id="99-3-有氧运动：Aerobic-exercise"><a href="#99-3-有氧运动：Aerobic-exercise" class="headerlink" title="99.3 有氧运动：Aerobic exercise"></a>99.3 有氧运动：Aerobic exercise</h2><p>是不是“有氧运动”，衡量的标准是心率。心率保持在<strong>150次&#x2F;分钟</strong>的运动量为有氧运动，因为此时血液可以供给心肌足够的氧气；<br>因此，它的特点是强度低、有节奏、持续时间较长。<br>要求每次锻炼的时间不少于30分钟，每周坚持3到5次。</p>
<p>这种锻炼，氧气能充分燃烧（即氧化）体内的糖分，还可消耗体内脂肪，增强和改善心肺功能，预防骨质疏松，调节心理和精神状态，是健身的主要运动方式。</p>
<p>健身价值</p>
<p>通过有规律的有氧运动锻炼，人体<strong>心脏功能</strong>更强，<strong>脉搏输出量</strong>更多，则<strong>供氧能力</strong>更强，<strong>脉搏数</strong>会适当减少。<br>一个心肺功能好的人可以参加较长时间的有氧运动，且运动恢复也较快。</p>
<p>排行榜<br>NO1、游泳<br>运动优点：游泳需克服水的阻力而非重力，肌肉和关节不易受损，能有效保护膝关节;冷水环境下游泳热量消耗大，属于减肥效果显著的运动；当配合节食时，效果更加显著。<br>适宜人群：膝关节受损；体重严重超标；减肥；增强体质的族群。<br>运动周期：每周<strong>3～4次</strong>，每次<strong>30～60分钟</strong>。<br>热量消耗：约650千卡&#x2F;小时</p>
<p>NO2、慢跑<br>运动优点：提高睡眠质量，通过跑步，大脑的供血、供氧量可以提升20%，这样夜晚的睡眠质量也会跟着提高；“通风”作用，在跑步的过程中，肺部的容量平均从5.8L上升到6.2L，同时，血液中氧气的携带量也会大大增加；提高心脏功能，长期慢跑可使安静<strong>心率减慢</strong>、<strong>血管壁的弹性增加</strong>；解压，慢跑可以缓解紧张和焦虑，有益健康。<br>适宜人群：减肥，需要缓解压力，缓解亚健康，以及预防心血管疾病的族群。<br>运动周期：每周<strong>3～4次</strong>，每次<strong>40～60分钟</strong>。<br>热量消耗：约650千卡&#x2F;小时</p>
<p>健身观点</p>
<p>库珀可谓美国知名的预防医学大腕，他长期担任美国总统的私人医生，曾是“有氧健身运动”的首创者。<br>他认为每个人生命的长短和质量完全取决于个人对疾病的预防，而不是医生和其他什么人所能左右得了的；与预防相比，任何挽救生命的医疗措施都显得为时已晚。</p>
<p>库珀凭自己的实践经验，向人们亮明了自己对健身运动的观点。<br>1.适度锻炼。<br>大运动量的健身运动有可能会慢慢损伤你的身体，比如，每周跑步超过15英里就有些过量了。<br>建议每周锻炼4至5次，每次30分钟。<br>库珀认为，只要适量运动，就可以有效降低患心血管病和癌症的可能性。</p>
<p>减肥</p>
<p>!<br>7.应该怎样安排力量练习和有氧锻炼呢？<br>有氧运动比起力量训练消耗的热量要多，力量训练只是为了锻炼肌肉、增加肌肉，热量消耗要少，<br>所以应该把<strong>有氧运动</strong>放在<strong>力量训练</strong><code>后</code>进行，这样安排，就可以保证既有体力进行有氧运动，又能进行力量训练。</p>
<p>有氧运动(3张)<br>有氧运动需要大量呼吸空气，对心、肺是很好的锻炼，可以增强肺活量和心脏功能。<br>长期坚持有氧运动能<code>增加体内血红蛋白的数量</code>，<code>提高机体抵抗力</code>，<code>抗衰老</code>，<code>增强大脑皮层</code>的工作效率和<code>心肺功能</code>，增加脂肪消耗，<code>防止动脉硬化</code>，降低心脑血管疾病的发病率。</p>
<p><code>Ⅱ型糖尿病患者</code>、<code>肥胖症患</code>者以及<code>脂肪肝患者</code>，一定要做有氧运动，<br>患有<code>心律不齐</code>、<code>心脑动脉血管硬化</code>的人，以及年龄大的人，也都应该做有氧运动。</p>
<p>如果是为了强壮肌肉、健美体形，预防椎间盘突出症、颈椎病以及骨质疏松、骨质软化的人，应当做无氧运动。</p>
<p>如果心率达到<strong>150～160次&#x2F;分钟</strong>，此时血液对心肌供氧已不充分，便为半有氧运动。</p>
<p>如果心率达到<strong>160次&#x2F;分钟</strong>以上，便为无氧运动了，即血液中的氧气对心肌已是供不应求了。</p>
<p>新陈代谢需要氧气的参与，有氧运动由于氧气充足，可使体内营养物质代谢彻底，即达到最终代谢——营养物质分解为二氧化碳和水。</p>
<p>有氧运动能够达到瘦身减肥的效果，晚饭后进行<strong>半小时</strong>的散步，就能很好地将晚饭中的脂肪进而蛋白质进行调节消耗。</p>
<p>减肥</p>
<p>1、心率<br><strong>脂肪</strong>的<strong>分解代谢</strong>是一系列复杂的生化反应，而心率反映的是<strong>交感神经</strong>的兴奋度，交感神经的兴奋促进了一系列<strong>脂解激素</strong>的分泌，从而活化<strong>脂解酶</strong>，使储存在<strong>脂肪细胞组织</strong>里的脂肪分解为游离<strong>脂酸和甘油</strong>，而脂酸在氧供给充足的条件下，可分解成二氧化碳和水并释放大量的能量。</p>
<p>最大心率：MHR为220－你的年龄，最低心率，一般在早晨测试。</p>
<p>保留心率就是最大心率－最低心率。</p>
<p>减肥心率也就是有氧运动的心率范围应该是最低心率+保留心率×50%～60%：124</p>
<p>锻炼耐力的心率范围是最低心率+保留心率×60%～70%：136.8</p>
<p>2、时间<br>根据美国运动医学的研究，有氧运动<strong>前15分钟</strong>，由<strong>肝糖元</strong>作为主要能源供应，<strong>脂肪</strong>供能在运动后<strong>15～20分钟</strong>才开始启动，</p>
<p>有氧运动</p>
<p>2、接近而不超过“靶心率”一般来说，靶心率为170－年龄的数值。<br>如果你60岁，靶心率就是170－60&#x3D;110（次&#x2F;分）。：138<br>3、自我感觉是掌握运动量和运动强度的重要指标，</p>
<p>包括轻度呼吸急促、感到有点心跳、周身微热、面色微红、津津小汗，这表明运动适量；<br>如果有明显的心慌、<strong>气短</strong>、心口发热、<strong>头晕</strong>、大汗、疲惫不堪，表明运动超限。</p>
<p>5、放松与热身有同样的作用，<br>在运动中，血液循环加快，血液的量也增加了，特别是四肢部分。<br>如果马上停止运动，<strong>血液</strong>会<strong>囤积</strong>在<strong>下肢</strong>而给心脏造成多余的负担。<br>严重时会影响到大脑供血，甚至出现眩晕和头昏。所以运动目的达到后应该有5～10分钟的放松，也就是逐步减小运动强度，慢慢地恢复到安静状态。<br>一周量</p>
<p>关于运动的频率，美国运动医学会推荐<strong>正常人</strong>应该<strong>每周运动2～5次</strong></p>
<p>一般人慢跑一分钟消耗15千卡左右热量（体重越大消耗越多），而一公斤（1000克）的脂肪是4500千卡。<br>如果每天慢跑30分钟，在饮食没有变化的情况下10天可减一公斤。</p>
<p>研究发现，<strong>两小时</strong>中量的<strong>有氧</strong>锻炼可耗尽体内90%的<strong>白氨酸</strong>——对肌肉生长非常重要的一种氨基酸。</p>
<p>要改变脂肪与肌肉比率，应该采用相对重些的力量练习发展并保持肌肉总量。力量练习之后，进行中到高强度的有氧锻炼。</p>
<p>有利心脏<br>事实：美国心脏协会指出，每周3～4次、每次至少30分钟，以最大心率的50%～75%锻炼的有氧运动对心脏最有利。<br>它将对心血管系统和心肺功能有积极的改善作用，并显著减少相关疾病的危险。<br>美国心脏协会建议，初练者的运动心率以最大心率的50%为宜，几周后，强度逐渐增加到最大心率的75%<br>。总之，训练强度越大。你的体型保持得越好。因为心脏与其他部位一样，也是一块肌肉，它同样需要大强度的练习！</p>
<p>有氧运动方法</p>
<p>3、匀速跑心率控制在每分钟150次左右，负荷时间保持在30分钟以上。<br>5、跳绳3分钟，休息1分钟，再进行下一组的练习。每次训练做3组即可。当受训者觉得适应此运动量时，可去掉中间的休息时间，连续跳3分钟。<br>6、空击3分钟为一组，做3～5组。</p>
<p>综述<br>有氧运动是增强人体吸入与使用氧气的耐久运动。它的运动特点是负荷量轻、有节律感、持续时间长。运动医学测定，有氧运动适宜的运动负荷为<br><strong>每周4～5次</strong>，每次持续<strong>20～30分钟</strong>，运动时心率为<strong>120～135次&#x2F;分</strong></p>
]]></content>
      <tags>
        <tag>life</tag>
        <tag>gym</tag>
      </tags>
  </entry>
  <entry>
    <title>免费 零基础自行动手 pdf转文字</title>
    <url>/2024/06/03/%E5%85%8D%E8%B4%B9-%E9%9B%B6%E5%9F%BA%E7%A1%80%E8%87%AA%E8%A1%8C%E5%8A%A8%E6%89%8B-pdf%E8%BD%AC%E6%96%87%E5%AD%97/</url>
    <content><![CDATA[<h1 id="免费-零基础自行动手-pdf转文字"><a href="#免费-零基础自行动手-pdf转文字" class="headerlink" title="免费 零基础自行动手 pdf转文字"></a>免费 零基础自行动手 pdf转文字</h1><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p><a href="https://ocrmypdf.readthedocs.io/en/latest/index.html">ocrmypdf 文档</a><br><a href="https://ocrmypdf.readthedocs.io/en/latest/installation.html">ocrmypdf 文档 官网具体下载教程</a><br><a href="https://ghostscript.com/releases/gsdnld.html">Ghostscript 下载地址</a></p>
<ul>
<li>Python 64-bit</li>
<li>Tesseract 64-bit</li>
<li>Ghostscript 64-bit</li>
</ul>
<figure class="highlight bat"><table><tr><td class="code"><pre><span class="line">winget install -e --id Python.Python.<span class="number">3</span>.<span class="number">11</span></span><br><span class="line">winget install -e --id UB-Mannheim.TesseractOCR</span><br><span class="line">python3 -m pip install ocrmypdf</span><br></pre></td></tr></table></figure>

<h2 id="当前目录-批量转化pdf为可复制文字的图片-执行代码"><a href="#当前目录-批量转化pdf为可复制文字的图片-执行代码" class="headerlink" title="当前目录 批量转化pdf为可复制文字的图片 执行代码"></a>当前目录 批量转化pdf为可复制文字的图片 执行代码</h2><p><a href="batch.py">代码文件</a></p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">python ./batch.py <span class="string">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="batch-py-源码"><a href="#batch-py-源码" class="headerlink" title="batch.py 源码"></a>batch.py 源码</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ocrmypdf</span><br><span class="line"></span><br><span class="line"><span class="comment"># pylint: disable=logging-format-interpolation</span></span><br><span class="line"><span class="comment"># pylint: disable=logging-not-lazy</span></span><br><span class="line"></span><br><span class="line">script_dir = Path(__file__).parent</span><br><span class="line"><span class="built_in">print</span>(script_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    start_dir = Path(sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    start_dir = Path(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(start_dir)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">2</span>:</span><br><span class="line">    log_file = Path(sys.argv[<span class="number">2</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    log_file = script_dir.with_name(<span class="string">&#x27;ocr-tree.log&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(log_file)</span><br><span class="line"></span><br><span class="line">logging.basicConfig(</span><br><span class="line">    level=logging.INFO,</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s %(message)s&#x27;</span>,</span><br><span class="line">    filename=log_file,</span><br><span class="line">    filemode=<span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ocrmypdf.configure_logging(ocrmypdf.Verbosity.quiet)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> filename <span class="keyword">in</span> start_dir.glob(<span class="string">&quot;**/*.pdf&quot;</span>):</span><br><span class="line">    logging.info(<span class="string">f&quot;Processing <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Processing <span class="subst">&#123;filename&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(filename)</span><br><span class="line">    output_file = <span class="string">f&quot;<span class="subst">&#123;filename&#125;</span>_tmp.pdf&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(output_file)</span><br><span class="line"></span><br><span class="line">    result = ocrmypdf.ocr(filename, output_file, deskew=<span class="literal">True</span>, language=[<span class="string">&quot;chi_sim&quot;</span>,<span class="string">&quot;eng&quot;</span>], jobs=<span class="number">2</span>, skip_text=<span class="literal">True</span>, progress_bar=<span class="literal">True</span>, optimize=<span class="number">1</span>, png_quality=<span class="number">30</span>, jpeg_quality=<span class="number">40</span>)</span><br><span class="line">    <span class="comment">#, jbig2_page_group_size=1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> result == ocrmypdf.ExitCode.already_done_ocr:</span><br><span class="line">        logging.error(<span class="string">&quot;Skipped document because it already contained text&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> result == ocrmypdf.ExitCode.ok:</span><br><span class="line">        logging.info(<span class="string">&quot;OCR complete&quot;</span>)</span><br><span class="line">    logging.info(result)</span><br></pre></td></tr></table></figure>

<h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><h3 id="OCR识别pdf"><a href="#OCR识别pdf" class="headerlink" title="OCR识别pdf"></a>OCR识别pdf</h3><blockquote>
<p>ocrmypdf –force-ocr old.pdf new.pdf</p>
</blockquote>
<h3 id="配合img2pdf，把图片转为OCR识别的pdf"><a href="#配合img2pdf，把图片转为OCR识别的pdf" class="headerlink" title="配合img2pdf，把图片转为OCR识别的pdf"></a>配合img2pdf，把图片转为OCR识别的pdf</h3><blockquote>
<p>img2pdf –pagesize A4 page*.png | ocrmypdf - myfile.pdf</p>
</blockquote>
<h3 id="如果使用-poppler-得安装MSCV"><a href="#如果使用-poppler-得安装MSCV" class="headerlink" title="如果使用 poppler 得安装MSCV"></a>如果使用 poppler 得安装MSCV</h3><ul>
<li><input disabled="" type="checkbox"> <a href="https://blog.csdn.net/sinat_37967865/article/details/102477235">教程</a></li>
<li><input disabled="" type="checkbox"> <a href="https://github.com/writecrow/ocr2text">ocr2text 教程</a></li>
</ul>
<h3 id="把OCR识别转为txt文本"><a href="#把OCR识别转为txt文本" class="headerlink" title="把OCR识别转为txt文本"></a>把OCR识别转为txt文本</h3><p><a href="https://github.com/writecrow/ocr2text">英文教程</a></p>
<p><a href="https://blog.csdn.net/m0_37576542/article/details/132315537">超详细解决pytesseract.pytesseract.TesseractNotFoundError: tesseract is not installed or it‘s not in yo…</a></p>
<p><a href="https://pymupdf.readthedocs.io/en/latest/pixmap.html#Pixmap.pil_tobytes">pymupdf 文档</a></p>
<p><a href="https://tesseract-ocr.github.io/tessdoc/Command-Line-Usage.html">tesseract-ocr 使用文档</a><br>例如：</p>
<blockquote>
<p>tesseract.exe images&#x2F;eurotext.png -l eng+deu</p>
</blockquote>
<ul>
<li><p><input disabled="" type="checkbox"> 
下载 <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/">anaconda</a></p>
</li>
<li><p><input disabled="" type="checkbox"> 
下载 <a href="https://github.com/UB-Mannheim/tesseract/wiki">tesseract-ocr</a> 安装程序 <em><strong>记得勾选中文支持库</strong></em></p>
</li>
<li><p><input disabled="" type="checkbox"> 
pip install pytesseract </p>
<ol>
<li>pytesseract 实际上是使用python代码 执行 <code>tesseract.exe</code> 程序 所以传参方式还是参考 <code>tesseract-ocr 使用文档</code></li>
<li>另外还需要 修改 pytesseract 库中 <code>tesseract.exe</code> 的执行路径 为用户安装 <code>tesseract-ocr</code> 的路径</li>
<li>另外 把<code>tesseract.exe</code>的安装路径 以及 <code>tesseract-ocr</code> 文字库的路径 设置于系统变量</li>
</ol>
<p>  具体参考 <a href="https://blog.csdn.net/m0_37576542/article/details/132315537">超详细解决pytesseract.pytesseract.TesseractNotFoundError: tesseract is not installed or it‘s not in yo…</a></p>
</li>
<li><p><input disabled="" type="checkbox"> 
下载 识别转化脚本</p>
<blockquote>
<p>git clone <a href="https://github.com/writecrow/ocr2text.git">https://github.com/writecrow/ocr2text.git</a></p>
</blockquote>
</li>
<li><p><input disabled="" type="checkbox"> 
运行 <code>Anaconda Powershell Prompt</code> 然后 cd <code>ocr2text</code> 目录下 执行</p>
<blockquote>
<p>pip install –user –requirement requirements.txt<br>python3.12.exe .\ocr2text.py</p>
</blockquote>
</li>
</ul>
<h3 id="ocr2text-py-源码-带点小修改"><a href="#ocr2text-py-源码-带点小修改" class="headerlink" title="ocr2text.py 源码 带点小修改"></a>ocr2text.py 源码 带点小修改</h3><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"><span class="keyword">import</span> errno</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"><span class="keyword">import</span> tempfile</span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> mkdtemp</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error: You need to install the &quot;Image&quot; package. Type the following:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;pip install Image&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> pytesseract</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error: You need to install the &quot;pytesseract&quot; package. Type the following:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;pip install pytesseract&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">from</span> pdf2image <span class="keyword">import</span> convert_from_path, convert_from_bytes</span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Error: You need to install the &quot;pdf2image&quot; package. Type the following:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;pip install pdf2image&#x27;</span>)</span><br><span class="line">    exit()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> textract <span class="keyword">import</span> exceptions</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">update_progress</span>(<span class="params">progress</span>):</span><br><span class="line">    barLength = <span class="number">10</span>  <span class="comment"># Modify this to change the length of the progress bar</span></span><br><span class="line">    status = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">isinstance</span>(progress, <span class="built_in">int</span>):</span><br><span class="line">        progress = <span class="built_in">float</span>(progress)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(progress, <span class="built_in">float</span>):</span><br><span class="line">        progress = <span class="number">0</span></span><br><span class="line">        status = <span class="string">&quot;error: progress var must be float\r\n&quot;</span></span><br><span class="line">    <span class="keyword">if</span> progress &lt; <span class="number">0</span>:</span><br><span class="line">        progress = <span class="number">0</span></span><br><span class="line">        status = <span class="string">&quot;Halt...\r\n&quot;</span></span><br><span class="line">    <span class="keyword">if</span> progress &gt;= <span class="number">1</span>:</span><br><span class="line">        progress = <span class="number">1</span></span><br><span class="line">        status = <span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    block = <span class="built_in">int</span>(<span class="built_in">round</span>(barLength*progress))</span><br><span class="line">    text = <span class="string">&quot;\rPercent: [&#123;0&#125;] &#123;1&#125;% &#123;2&#125;&quot;</span>.<span class="built_in">format</span>(</span><br><span class="line">        <span class="string">&quot;#&quot;</span>*block + <span class="string">&quot;-&quot;</span>*(barLength-block), progress*<span class="number">100</span>, status)</span><br><span class="line">    sys.stdout.write(text)</span><br><span class="line">    sys.stdout.flush()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">args</span>):</span><br><span class="line">        <span class="comment"># run a subprocess and put the stdout and stderr on the pipe object</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            pipe = subprocess.Popen(</span><br><span class="line">                args,</span><br><span class="line">                stdout=subprocess.PIPE, stderr=subprocess.PIPE,</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">if</span> e.errno == errno.ENOENT:</span><br><span class="line">                <span class="comment"># File not found.</span></span><br><span class="line">                <span class="comment"># This is equivalent to getting exitcode 127 from sh</span></span><br><span class="line">                <span class="keyword">raise</span> exceptions.ShellError(</span><br><span class="line">                    <span class="string">&#x27; &#x27;</span>.join(args), <span class="number">127</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">        <span class="comment"># pipe.wait() ends up hanging on large files. using</span></span><br><span class="line">        <span class="comment"># pipe.communicate appears to avoid this issue</span></span><br><span class="line">        stdout, stderr = pipe.communicate()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># if pipe is busted, raise an error (unlike Fabric)</span></span><br><span class="line">        <span class="keyword">if</span> pipe.returncode != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.ShellError(</span><br><span class="line">                <span class="string">&#x27; &#x27;</span>.join(args), pipe.returncode, stdout, stderr,</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> stdout, stderr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">extract_tesseract</span>(<span class="params">filename</span>):</span><br><span class="line">        <span class="comment">#temp_dir = mkdtemp()</span></span><br><span class="line">        <span class="comment">#base = os.path.join(temp_dir, &#x27;conv&#x27;)</span></span><br><span class="line">        <span class="comment">#temp_dir = &#x27;tempdir&#x27;           </span></span><br><span class="line">        temp_dir, _ = os.path.splitext(filename)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(temp_dir):</span><br><span class="line">                os.makedirs(temp_dir)</span><br><span class="line">        contents = []</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">        </span><br><span class="line">            <span class="keyword">import</span> pymupdf</span><br><span class="line"></span><br><span class="line">            doc = pymupdf.<span class="built_in">open</span>(filename) <span class="comment"># open a document</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> page_index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(doc)): <span class="comment"># iterate over pdf pages</span></span><br><span class="line">                page = doc[page_index] <span class="comment"># get the page</span></span><br><span class="line">                image_list = page.get_images()</span><br><span class="line"></span><br><span class="line">                <span class="comment"># print the number of images found on the page</span></span><br><span class="line">                <span class="comment">#if image_list:</span></span><br><span class="line">                <span class="comment">#    print(f&quot;Found &#123;len(image_list)&#125; images on page &#123;page_index&#125;&quot;)</span></span><br><span class="line">                <span class="comment">#else:</span></span><br><span class="line">                <span class="comment">#   print(&quot;No images found on page&quot;, page_index)</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> image_index, img <span class="keyword">in</span> <span class="built_in">enumerate</span>(image_list, start=<span class="number">1</span>): <span class="comment"># enumerate the image list</span></span><br><span class="line">                    xref = img[<span class="number">0</span>] <span class="comment"># get the XREF of the image</span></span><br><span class="line">                    pix = pymupdf.Pixmap(doc, xref) <span class="comment"># create a Pixmap</span></span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> pix.n - pix.alpha &gt; <span class="number">3</span>: <span class="comment"># CMYK: convert to RGB first</span></span><br><span class="line">                        pix = pymupdf.Pixmap(pymupdf.csRGB, pix)</span><br><span class="line"></span><br><span class="line">                    pix.save(<span class="string">&quot;%s\\page_%05d-image_%02d.png&quot;</span> % (temp_dir, page_index, image_index)) <span class="comment"># save the image as png</span></span><br><span class="line">                    png_bytes = pix.tobytes()</span><br><span class="line">                    page_content = pytesseract.image_to_string(Image.<span class="built_in">open</span>(io.BytesIO(png_bytes)), <span class="string">&#x27;eng+chi_sim&#x27;</span>)</span><br><span class="line">                    contents.append(page_content)</span><br><span class="line">                    pix = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> dirpath, dirnames, files <span class="keyword">in</span> os.walk(temp_dir):</span><br><span class="line">                <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">                    filename, file_extension = os.path.splitext(name)</span><br><span class="line">                    <span class="keyword">if</span> (file_extension.lower() != <span class="string">&#x27;.png&#x27;</span>):</span><br><span class="line">                        <span class="keyword">continue</span></span><br><span class="line">                    source_path = os.path.join(dirpath, name)</span><br><span class="line">                    relative_directory = os.path.dirname(os.path.realpath(name))</span><br><span class="line">                    pngfile = os.path.join(relative_directory, source_path)</span><br><span class="line">                    <span class="comment">#print(&#x27;pic path: &#x27; + repr(pngfile))</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">#page_content = pytesseract.image_to_string(Image.open(io.BytesIO(pngfile)), &#x27;eng+chi_sim&#x27;)</span></span><br><span class="line">                    <span class="comment">#contents.append(page_content)</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(contents)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># https://python-pptx.readthedocs.io/en/latest/</span></span><br><span class="line">            <span class="comment">#stdout, _ = run([&#x27;pdftoppm&#x27;, filename, base])</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;extract_tesseract: &#x27;</span> + filename)</span><br><span class="line">            <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">sorted</span>(os.listdir(temp_dir)):</span><br><span class="line">                page_path = os.path.join(temp_dir, page)</span><br><span class="line">                <span class="comment"># https://github.com/Belval/pdf2image</span></span><br><span class="line">                page_content = pytesseract.image_to_string(Image.<span class="built_in">open</span>(page_path))</span><br><span class="line">                contents.append(page_content)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(contents)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment">#shutil.rmtree(temp_dir)</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert_recursive</span>(<span class="params">source, destination, count</span>):</span><br><span class="line">    pdfCounter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> dirpath, dirnames, files <span class="keyword">in</span> os.walk(source):</span><br><span class="line">        <span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">            <span class="keyword">if</span> file.lower().endswith(<span class="string">&#x27;.pdf&#x27;</span>):</span><br><span class="line">                pdfCounter += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;pdfCounter: &#x27;</span> + <span class="built_in">str</span>(pdfCounter))</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; Helper function for looping through files recursively &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> dirpath, dirnames, files <span class="keyword">in</span> os.walk(source):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> files:</span><br><span class="line">            filename, file_extension = os.path.splitext(name)</span><br><span class="line">            <span class="keyword">if</span> (file_extension.lower() != <span class="string">&#x27;.pdf&#x27;</span>):</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;name:&#x27;</span> + name)</span><br><span class="line">            relative_directory = os.path.relpath(dirpath, source)</span><br><span class="line">            source_path = os.path.join(dirpath, name)</span><br><span class="line">            output_directory = os.path.join(destination, relative_directory)</span><br><span class="line">            output_filename = os.path.join(output_directory, filename + <span class="string">&#x27;.txt&#x27;</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(output_directory):</span><br><span class="line">                os.makedirs(output_directory)</span><br><span class="line">            count = convert(source_path, output_filename, count, pdfCounter)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">convert</span>(<span class="params">sourcefile, destination_file, count, pdfCounter</span>):</span><br><span class="line">    text = extract_tesseract(sourcefile)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(destination_file, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f_out:</span><br><span class="line">        f_out.write(text)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;Converted &#x27;</span> + source)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    update_progress(count / pdfCounter)</span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;********************************&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;*** PDF to TXT file, via OCR ***&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;********************************&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line">dir_path = os.path.dirname(os.path.realpath(__file__))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Source file or folder of PDF(s) [&#x27;</span> + dir_path + <span class="string">&#x27;]:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;(Press [Enter] for current working directory)&#x27;</span>)</span><br><span class="line">source = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> source == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">    source = dir_path</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Destination folder for TXT [&#x27;</span> + dir_path + <span class="string">&#x27;]:&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;(Press [Enter] for current working directory)&#x27;</span>)</span><br><span class="line">destination = <span class="built_in">input</span>()</span><br><span class="line"><span class="keyword">if</span> destination == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line">    destination = dir_path</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (os.path.exists(source)):</span><br><span class="line">    <span class="keyword">if</span> (os.path.isdir(source)):</span><br><span class="line">        count = convert_recursive(source, destination, count)</span><br><span class="line">    <span class="keyword">elif</span> os.path.isfile(source):  </span><br><span class="line">        filepath, fullfile = os.path.split(source)</span><br><span class="line">        filename, file_extension = os.path.splitext(fullfile)</span><br><span class="line">        <span class="keyword">if</span> (file_extension.lower() == <span class="string">&#x27;.pdf&#x27;</span>):</span><br><span class="line">            count = convert(source, os.path.join(destination, filename + <span class="string">&#x27;.txt&#x27;</span>), count, <span class="number">1</span>)</span><br><span class="line">    plural = <span class="string">&#x27;s&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">        plural = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(count) + <span class="string">&#x27; file&#x27;</span> + plural + <span class="string">&#x27; converted&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;The path &#x27;</span> + source + <span class="string">&#x27; seems to be invalid&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="然后就能通过朗读-边读边看-提升阅读效率"><a href="#然后就能通过朗读-边读边看-提升阅读效率" class="headerlink" title="然后就能通过朗读 边读边看 提升阅读效率"></a>然后就能通过朗读 边读边看 提升阅读效率</h2><h2 id="pdf转docx"><a href="#pdf转docx" class="headerlink" title="pdf转docx"></a><a href="https://pdf2docx.readthedocs.io/en/latest/index.html">pdf转docx</a></h2>]]></content>
      <tags>
        <tag>python</tag>
        <tag>ocrmypdf</tag>
        <tag>Tesseract</tag>
        <tag>pdf转文字</tag>
      </tags>
  </entry>
  <entry>
    <title>啊哈算法 读书笔记</title>
    <url>/2024/06/03/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="啊哈算法-读书笔记"><a href="#啊哈算法-读书笔记" class="headerlink" title="啊哈算法 读书笔记"></a>啊哈算法 读书笔记</h1><blockquote>
<p><a href="https://github.com/chenchen-cs/Aha-algorithm/">《啊哈算法》源码</a> &gt; <a href="https://github.com/OctopusLian/AhaAlgorithms/">啊哈算法》第八章源码</a></p>
</blockquote>
<div class="gallery-container" data-type="data" data-button="" data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg","alt":"","title":""}]</div>
  </div>


<h2 id="第-1-章-一大波数正在靠近——排序-1"><a href="#第-1-章-一大波数正在靠近——排序-1" class="headerlink" title="第 1 章 一大波数正在靠近——排序 1"></a>第 1 章 一大波数正在靠近——排序 1</h2><h3 id="第-1-节-最帛最简单的排序——桶排序-2"><a href="#第-1-节-最帛最简单的排序——桶排序-2" class="headerlink" title="第 1 节 最帛最简单的排序——桶排序 2"></a>第 1 节 最帛最简单的排序——桶排序 2</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bucket[max + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        bucket[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (bucket[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[j++] = i;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    bucketSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-2-节-邻居好说话——冒泡排序-7"><a href="#第-2-节-邻居好说话——冒泡排序-7" class="headerlink" title="第 2 节 邻居好说话——冒泡排序 7"></a>第 2 节 邻居好说话——冒泡排序 7</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 arr[j] 和 arr[j + 1]</span></span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    bubbleSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-3-节-最常用的排序——快速排序"><a href="#第-3-节-最常用的排序——快速排序" class="headerlink" title="第 3 节 最常用的排序——快速排序"></a>第 3 节 最常用的排序——快速排序</h3><p>|基准-&gt;   mid   &lt;-|<br>|mid-&gt;   基准|   &lt;-|</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">101</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, t, temp;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span>;</span><br><span class="line">    temp = a[left];</span><br><span class="line">    i = left;</span><br><span class="line">    j = right;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            t = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = a[i];</span><br><span class="line">    a[i] = temp;</span><br><span class="line"></span><br><span class="line">    quicksort(left, i - <span class="number">1</span>);</span><br><span class="line">    quicksort(i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组的大小：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组元素：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quicksort(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-4-节-小哼买书-20"><a href="#第-4-节-小哼买书-20" class="headerlink" title="第 4 节 小哼买书 20"></a>第 4 节 小哼买书 20</h3><blockquote>
<p>在粗略计算时间复杂度的时候，我们通常认为计算机每秒钟大约运行 10 亿次（当然实际情况要更快）。<br>桶排序是昀快的，它的时间复杂度是 O(N+M)；冒泡排序是 O(N 2 )；快速排序是 O(NlogN)</p>
</blockquote>
<h2 id="第-2-章-栈、队列、链表"><a href="#第-2-章-栈、队列、链表" class="headerlink" title="第 2 章 栈、队列、链表"></a>第 2 章 栈、队列、链表</h2><h3 id="第-1-节-解密-QQ-号——队列"><a href="#第-1-节-解密-QQ-号——队列" class="headerlink" title="第 1 节 解密 QQ 号——队列"></a>第 1 节 解密 QQ 号——队列</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data[<span class="number">100</span>]; <span class="comment">// 队列的主体，用来存储内容</span></span><br><span class="line">    <span class="type">int</span> head;      <span class="comment">// 队首</span></span><br><span class="line">    <span class="type">int</span> tail;      <span class="comment">// 队尾</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue</span> <span class="title">q</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 初始刖队列</span></span><br><span class="line">    q.head = <span class="number">1</span>;</span><br><span class="line">    q.tail = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 依次向队列插入9个数</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q.data[q.tail]);</span><br><span class="line">        q.tail++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q.head &lt; q.tail) <span class="comment">// 当队列不为空的时候执行循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印队首并将队首出队</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q.data[q.head]);</span><br><span class="line">        q.head++;</span><br><span class="line">        <span class="comment">// 先将新队首的数添加到队尾</span></span><br><span class="line">        q.data[q.tail] = q.data[q.head];</span><br><span class="line">        q.tail++;</span><br><span class="line">        <span class="comment">// 再将队首出队</span></span><br><span class="line">        q.head++;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-2-节-解密回文——栈"><a href="#第-2-节-解密回文——栈" class="headerlink" title="第 2 节 解密回文——栈"></a>第 2 节 解密回文——栈</h3><h3 id="第-3-节-纸牌游戏——小猫钓鱼-35"><a href="#第-3-节-纸牌游戏——小猫钓鱼-35" class="headerlink" title="第 3 节 纸牌游戏——小猫钓鱼 35"></a>第 3 节 纸牌游戏——小猫钓鱼 35</h3><h3 id="第-4-节-链表"><a href="#第-4-节-链表" class="headerlink" title="第 4 节 链表"></a>第 4 节 链表</h3><h3 id="第-5-节-模拟链表-54"><a href="#第-5-节-模拟链表-54" class="headerlink" title="第 5 节 模拟链表 54"></a>第 5 节 模拟链表 54</h3><h2 id="第-3-章-枚举！廱暴力-57"><a href="#第-3-章-枚举！廱暴力-57" class="headerlink" title="第 3 章 枚举！廱暴力 57"></a>第 3 章 枚举！廱暴力 57</h2><h3 id="第-1-节-坑爹的奥数-58"><a href="#第-1-节-坑爹的奥数-58" class="headerlink" title="第 1 节 坑爹的奥数 58"></a>第 1 节 坑爹的奥数 58</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">book[<span class="number">10</span>], total = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 定义深度优先搜索函数，用于生成符合加法运算规则的数字组合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> step)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果递归到了第10步，即生成了一个完整的数字序列</span></span><br><span class="line">    <span class="keyword">if</span> (step == <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断前六个数字组成的数加上第七个数字是否等于后三个数字组成的数</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] * <span class="number">100</span> + a[<span class="number">2</span>] * <span class="number">10</span> + a[<span class="number">3</span>] + a[<span class="number">4</span>] * <span class="number">100</span> + a[<span class="number">5</span>] * <span class="number">10</span> + a[<span class="number">6</span>] == a[<span class="number">7</span>] * <span class="number">100</span> + a[<span class="number">8</span>] * <span class="number">10</span> + a[<span class="number">9</span>]) &#123;</span><br><span class="line">            total++; <span class="comment">// 满足条件的组合数加一</span></span><br><span class="line">            <span class="comment">// 输出当前满足条件的组合</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d+%d%d%d=%d%d%d\n&quot;</span>, a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>], a[<span class="number">4</span>], a[<span class="number">5</span>], a[<span class="number">6</span>], a[<span class="number">7</span>], a[<span class="number">8</span>], a[<span class="number">9</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 返回上一层递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有数字（1-9）</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book[i] == <span class="number">0</span>) &#123; <span class="comment">// 判断当前数字是否可用</span></span><br><span class="line">            a[step] = i; <span class="comment">// 将当前数字放入数组的当前位置</span></span><br><span class="line">            book[i] = <span class="number">1</span>; <span class="comment">// 标记当前数字已使用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进入下一层递归，生成下一个数字序列</span></span><br><span class="line">            dfs(step + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            book[i] = <span class="number">0</span>; <span class="comment">// 回溯：重置当前数字状态，以便下次使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 返回上一层递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total=%d&quot;</span>, total / <span class="number">2</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-2-节-炸廐人"><a href="#第-2-节-炸廐人" class="headerlink" title="第 2 节 炸廐人"></a>第 2 节 炸廐人</h3><h3 id="第-3-节-火柴棍等庿-67"><a href="#第-3-节-火柴棍等庿-67" class="headerlink" title="第 3 节 火柴棍等庿 67"></a>第 3 节 火柴棍等庿 67</h3><h3 id="第-4-节-数的全排列-70"><a href="#第-4-节-数的全排列-70" class="headerlink" title="第 4 节 数的全排列 70"></a>第 4 节 数的全排列 70</h3><h2 id="第-4-章-万能的搜索"><a href="#第-4-章-万能的搜索" class="headerlink" title="第 4 章 万能的搜索"></a>第 4 章 万能的搜索</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>], book[<span class="number">10</span>], n;</span><br><span class="line"><span class="comment">// 定义dfs函数，用于递归地生成序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> step)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 如果已经递归到第n+1步，意味着生成了一个完整的序列</span></span><br><span class="line">    <span class="keyword">if</span> (step == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印序列中的每个元素</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印换行符</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回上一层递归</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历1到n个数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前数未被使用过</span></span><br><span class="line">        <span class="keyword">if</span> (book[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前数放入序列中</span></span><br><span class="line">            a[step] = i;</span><br><span class="line">            <span class="comment">// 标记当前数已被使用</span></span><br><span class="line">            book[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 递归进入下一层，继续生成序列</span></span><br><span class="line">            dfs(step + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 重置当前数的使用标记，以用于生成其他序列</span></span><br><span class="line">            book[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回上一层递归</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-1-节-不撞南墙不回头——深庞优先搜索-73"><a href="#第-1-节-不撞南墙不回头——深庞优先搜索-73" class="headerlink" title="第 1 节 不撞南墙不回头——深庞优先搜索 73"></a>第 1 节 不撞南墙不回头——深庞优先搜索 73</h3><blockquote>
<p><a href="#%E7%AC%AC-1-%E8%8A%82-%E5%9D%91%E7%88%B9%E7%9A%84%E5%A5%A5%E6%95%B0-58">编 号 为 1-9 的 九 张 扑 克 牌 , 然 后 将 这 九 张 扑 克牌 放 到 九 个 盒 子 中 ,并 使 得 口 口 口 + 口 口 口 &#x3D; 口 口 口 成 立</a></p>
</blockquote>
<h3 id="第-2-节-解救小哈-81"><a href="#第-2-节-解救小哈-81" class="headerlink" title="第 2 节 解救小哈 81"></a>第 2 节 解救小哈 81</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">/*	算法：深度优先搜索(DFS)</span></span><br><span class="line"><span class="comment">	时间：2021.10.28</span></span><br><span class="line"><span class="comment">	目的：找出小哼解救小哈的最短路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> n, m, p, q, min = <span class="number">99999999</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">51</span>][<span class="number">51</span>], book[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> step)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> tx, ty, k;</span><br><span class="line">	<span class="comment">//判断是否到达小哈的位置</span></span><br><span class="line">	<span class="keyword">if</span> (x == p &amp;&amp; y == q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//更新最小值</span></span><br><span class="line">		<span class="keyword">if</span> (step &lt; min)</span><br><span class="line">			min = step;</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//请注意这里的返回很重要</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//枚举4种走法</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//计算下一个点坐标</span></span><br><span class="line">		tx = x + next[k][<span class="number">0</span>];</span><br><span class="line">		ty = y + next[k][<span class="number">1</span>];</span><br><span class="line">		<span class="comment">//判断是否越界</span></span><br><span class="line">		<span class="keyword">if</span> (tx&lt;<span class="number">1</span> || tx&gt;n || ty&lt;<span class="number">1</span> || ty&gt;m)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//判断该点是否为障碍物或者已经在路径里</span></span><br><span class="line">		<span class="keyword">if</span> (a[tx][ty] == <span class="number">0</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			book[tx][ty] = <span class="number">1</span>;<span class="comment">//标记这个点已经被走过</span></span><br><span class="line">			dfs(tx, ty, step + <span class="number">1</span>);</span><br><span class="line">			book[tx][ty] = <span class="number">0</span>;<span class="comment">//尝试结束，取消这个点的标记</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, startx, starty;</span><br><span class="line">	<span class="comment">//读入n和m，n为行m为列</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//读入迷宫</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入起点和终点坐标</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;startx, &amp;starty, &amp;p, &amp;q);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从起点开始搜索</span></span><br><span class="line">	book[startx][startx] = <span class="number">1</span>;<span class="comment">//标记起点已经在路径中，防止后面重复走</span></span><br><span class="line">	<span class="comment">//第一个参数是起点的x坐标，第二个参数是起点的y坐标，第三个参数是初始步数为0</span></span><br><span class="line">	dfs(startx, starty, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出最短步数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, min);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-3-节-层层递进——广庞优先搜索"><a href="#第-3-节-层层递进——广庞优先搜索" class="headerlink" title="第 3 节 层层递进——广庞优先搜索"></a>第 3 节 层层递进——广庞优先搜索</h3><blockquote>
<p>广 度 优 先 搜 索 (Breadth First Search,BFS), 也 称 为 宽 度 优 先 搜 索</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">/*	算法：广度优先搜索（BFS)</span></span><br><span class="line"><span class="comment">	时间：2021.10.28</span></span><br><span class="line"><span class="comment">	目的：找出小哼解救小哈的最短路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> x;<span class="comment">//横坐标</span></span><br><span class="line">	<span class="type">int</span> y;<span class="comment">//纵坐标</span></span><br><span class="line">	<span class="type">int</span> f;<span class="comment">//父亲在队列中的编号，本题不要求输出路径，可以不需要f</span></span><br><span class="line">	<span class="type">int</span> s;<span class="comment">//步数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">note</span> <span class="title">que</span>[2501];</span><span class="comment">//因为地图大小不超过50*50，因此队列扩展不会超过2500个</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a[<span class="number">51</span>][<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;, book[<span class="number">51</span>][<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//定义一个用于表示走的方向的数组</span></span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> head, tail;</span><br><span class="line">	<span class="type">int</span> i, j, k, n, m, startx, starty, p, q, tx, ty, flag;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (i =<span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;startx, &amp;starty, &amp;p, &amp;q);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//队列初始化</span></span><br><span class="line">	head = <span class="number">1</span>;</span><br><span class="line">	tail = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//往队列输入迷宫入口坐标</span></span><br><span class="line">	que[tail].x = startx;</span><br><span class="line">	que[tail].y = starty;</span><br><span class="line">	que[tail].f = <span class="number">0</span>;</span><br><span class="line">	que[tail].s = <span class="number">0</span>;</span><br><span class="line">	tail++;</span><br><span class="line">	book[startx][starty]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	flag = <span class="number">0</span>;<span class="comment">//用来标记是否到达目标点，0表示暂时还没有到达，1表示到达</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//枚举四个方向</span></span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//计算下一个点的坐标</span></span><br><span class="line">			tx = que[head].x + next[k][<span class="number">0</span>];</span><br><span class="line">			ty = que[head].y + next[k][<span class="number">1</span>];</span><br><span class="line">			<span class="comment">//判断是否越界</span></span><br><span class="line">			<span class="keyword">if</span> (tx&lt;<span class="number">1</span> || tx&gt;n || ty&lt;<span class="number">1</span> || ty&gt;m)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//判断是否是障碍物或者已经在路径中</span></span><br><span class="line">			<span class="keyword">if</span> (a[tx][ty] == <span class="number">0</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//把这个点标记为已经走过</span></span><br><span class="line">				<span class="comment">//注意宽搜每个点只入队一次，所以和深搜不同，不需要将book数组还原</span></span><br><span class="line">				book[tx][ty] = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//插入新的点到队列中</span></span><br><span class="line">				que[tail].x = tx;</span><br><span class="line">				que[tail].y = ty;</span><br><span class="line">				que[tail].f = head;<span class="comment">//因为这个点是从head扩展出来的，所以他的父亲是</span></span><br><span class="line">				<span class="comment">//head，本题目不需要求路径，因此本句可省略</span></span><br><span class="line">				que[tail].s = que[head].s + <span class="number">1</span>;<span class="comment">//步数是父亲的步数+1</span></span><br><span class="line">				tail++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果到目标点了，停止扩展，任务结束，退出循环</span></span><br><span class="line">			<span class="keyword">if</span> (tx == p &amp;&amp; ty == q)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//注意下面两句话的位置千万不要写反了</span></span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		head++;<span class="comment">//注意这地方千万不要忘记，当一个点扩展结束后，head++才能对后面的点在进行扩展</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印队列中末尾最后一个点（目标点）的步数</span></span><br><span class="line">	<span class="comment">//注意tail是指向队列队尾（即最后一位）的下一个位置，所以这需要-1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, que[tail - <span class="number">1</span>].s);</span><br><span class="line"></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-4-节-再解炸廐人-95"><a href="#第-4-节-再解炸廐人-95" class="headerlink" title="第 4 节 再解炸廐人 95"></a>第 4 节 再解炸廐人 95</h3><h4 id="广度优先搜索-解法"><a href="#广度优先搜索-解法" class="headerlink" title="广度优先搜索 解法"></a>广度优先搜索 解法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">/*	算法：广度优先搜索（BFS)</span></span><br><span class="line"><span class="comment">	时间：2021.10.28</span></span><br><span class="line"><span class="comment">	目的：优化3.2炸弹人的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> x;<span class="comment">//横坐标</span></span><br><span class="line">	<span class="type">int</span> y;<span class="comment">//纵坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> a[<span class="number">20</span>][<span class="number">21</span>];<span class="comment">//用来存储地图</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum, x, y;</span><br><span class="line">	sum = <span class="number">0</span>;<span class="comment">//sum用来计数（可以消灭的敌人数），所以初始化为0</span></span><br><span class="line">	<span class="comment">//将坐标i,j复制到两个新变量x,y中，以便以后向上下左右四个方向统计可以消灭的敌人数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//向上统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)<span class="comment">//判断的点不是墙，如果不是墙就继续</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果当前的点是敌人，则进行计数</span></span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//x--的作用是继续向上统计</span></span><br><span class="line">		x--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向下统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//x++的作用是继续向下统计</span></span><br><span class="line">		x++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向左统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//y--的作用是继续向左统计</span></span><br><span class="line">		y--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向右统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//y++的作用是继续向右统计</span></span><br><span class="line">		y++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">que</span>[401];</span><span class="comment">//假设地图大小不超过20*20，因此队列扩展不会超过400个</span></span><br><span class="line">	<span class="type">int</span> head, tail;</span><br><span class="line">	<span class="type">int</span> book[<span class="number">20</span>][<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//定义一个标记数组并全部初始化为0</span></span><br><span class="line">	<span class="type">int</span> i, j, k, sum, max = <span class="number">0</span>, mx, my, n, m, startx, starty, tx, ty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个用于表达走的方向的数组</span></span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入n和m,n表示有多少行字符，m表示每行有多少列</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;startx, &amp;starty);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入n行字符</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//队列初始化</span></span><br><span class="line">	head = <span class="number">1</span>;</span><br><span class="line">	tail = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//往队列插入小人的起始坐标</span></span><br><span class="line">	que[tail].x = startx;</span><br><span class="line">	que[tail].y = starty;</span><br><span class="line">	tail++;</span><br><span class="line">	book[startx][starty] = <span class="number">1</span>;</span><br><span class="line">	max = getnum(startx, starty);</span><br><span class="line">	mx = startx;</span><br><span class="line">	my = starty;</span><br><span class="line">	<span class="comment">//当队列不为空的时候循环</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//枚举4个方向</span></span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//尝试走的下一个点的坐标</span></span><br><span class="line">			tx = que[head].x + next[k][<span class="number">0</span>];</span><br><span class="line">			ty = que[head].y + next[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">//判断是否越界</span></span><br><span class="line">			<span class="keyword">if</span> (tx&lt;<span class="number">0</span> || tx&gt;n - <span class="number">1</span> || ty&lt;<span class="number">0</span> || ty&gt;m - <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//判断是否为平地或者曾经走过</span></span><br><span class="line">			<span class="keyword">if</span> (a[tx][ty] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//每个点只入队一次，所以需要标记这个点已经走过</span></span><br><span class="line">				book[tx][ty] = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//插入新扩展的点到队列中</span></span><br><span class="line">				que[tail].x = tx;</span><br><span class="line">				que[tail].y = ty;</span><br><span class="line">				tail++;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//统计当前新扩展的点可以消灭的敌人总数</span></span><br><span class="line">				sum = getnum(tx, ty);</span><br><span class="line">				<span class="comment">//更新max的值</span></span><br><span class="line">				<span class="keyword">if</span> (sum &gt; max)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//如果当前统计出的所能消灭敌人数大于max,则更新max</span></span><br><span class="line">					<span class="comment">//并用mx和my记录该点坐标</span></span><br><span class="line">					max = sum;</span><br><span class="line">					mx = tx;</span><br><span class="line">					my = ty;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		head++;<span class="comment">//注意这地方千万不要忘记，当一个点扩展结束后，必须要head++才能对后面的点进行扩展</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后输出这个点和最多可以消灭的敌人数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;将炸弹放置在（%d,%d)处，可以消灭%d个敌人\n&quot;</span>, mx, my, max);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深度优先搜索-解法"><a href="#深度优先搜索-解法" class="headerlink" title="深度优先搜索 解法"></a>深度优先搜索 解法</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">/*	算法：深度优先搜索（DFS)</span></span><br><span class="line"><span class="comment">	时间：2021.10.29</span></span><br><span class="line"><span class="comment">	目的：优化3.2炸弹人的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">20</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> book[<span class="number">20</span>][<span class="number">20</span>], max, mx, my, n, m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getnum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum, x, y;</span><br><span class="line">	sum = <span class="number">0</span>;<span class="comment">//sum用来计数（可以消灭的敌人数），所以初始化为0</span></span><br><span class="line">	<span class="comment">//将坐标i,j复制到两个新变量x,y中，以便以后向上下左右四个方向统计可以消灭的敌人数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//向上统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)<span class="comment">//判断的点不是墙，如果不是墙就继续</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果当前的点是敌人，则进行计数</span></span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//x--的作用是继续向上统计</span></span><br><span class="line">		x--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向下统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//x++的作用是继续向下统计</span></span><br><span class="line">		x++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向左统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//y--的作用是继续向左统计</span></span><br><span class="line">		y--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向右统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//y++的作用是继续向上统计</span></span><br><span class="line">		y++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//定义一个用于表示走的方向的数组</span></span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> k, sum, tx, ty;</span><br><span class="line">	<span class="comment">//计算这个点当前可以消灭的敌人总数</span></span><br><span class="line">	sum = getnum(x, y);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新max的值</span></span><br><span class="line">	<span class="keyword">if</span> (sum &gt; max)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果当前的点统计出的所能消灭的敌人数大于max,</span></span><br><span class="line">		<span class="comment">//则更新max，并用mx和my记录当前点的坐标</span></span><br><span class="line">		max = sum;</span><br><span class="line">		mx = x;</span><br><span class="line">		my = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//枚举四个方向</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//下个点的坐标</span></span><br><span class="line">		tx = x + next[k][<span class="number">0</span>];</span><br><span class="line">		ty = y + next[k][<span class="number">1</span>];</span><br><span class="line">		<span class="comment">//判断是否越界</span></span><br><span class="line">		<span class="keyword">if</span> (tx&lt;<span class="number">0</span> || tx&gt;n - <span class="number">1</span> || ty&lt;<span class="number">0</span> || ty&gt;m - <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//判断是否围墙或者已经走过</span></span><br><span class="line">		<span class="keyword">if</span> (a[tx][ty] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			book[tx][ty] = <span class="number">1</span>;<span class="comment">//标记这个点已走过</span></span><br><span class="line">			dfs(tx, ty);<span class="comment">//开始尝试下一个点</span></span><br><span class="line">			<span class="comment">//book[tx][ty]=0</span></span><br><span class="line"><span class="comment">//此处不用收回，与路径或者步数有关的深搜，需要收回标记，无关则不需要回收</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, startx, starty;</span><br><span class="line">	<span class="comment">//读入n和m，n表示有多少行字符，m表示每行有多少字符</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;startx, &amp;starty);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入n行字符</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a[i]);</span><br><span class="line">	<span class="comment">//从小人站的位置开始尝试</span></span><br><span class="line">	book[startx][starty] = <span class="number">1</span>;</span><br><span class="line">	max = getnum(startx, starty);</span><br><span class="line">	mx = startx;</span><br><span class="line">	my = starty;</span><br><span class="line">	dfs(startx, starty);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;将炸弹放置在（%d %d),最多可以下消灭%d个敌人\n&quot;</span>, mx, my, max);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-5-节-宝岛探险"><a href="#第-5-节-宝岛探险" class="headerlink" title="第 5 节 宝岛探险"></a>第 5 节 宝岛探险</h3><h4 id="广度搜索"><a href="#广度搜索" class="headerlink" title="广度搜索"></a>广度搜索</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：BFS</span></span><br><span class="line"><span class="comment">//	时间：2021.10.29</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> x;<span class="comment">//横坐标</span></span><br><span class="line">	<span class="type">int</span> y;<span class="comment">//纵坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">que</span>[2501];</span></span><br><span class="line">	<span class="type">int</span> head, tail;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line">	<span class="type">int</span> book[<span class="number">51</span>][<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> i, j, k, sum, max = <span class="number">0</span>, mx, my, n, m, startx, starty, tx, ty;</span><br><span class="line">	<span class="comment">//定义一个方向数组</span></span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//读入n行m列以及小哼降落的坐标</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;startx, &amp;starty);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入地图</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">	<span class="comment">//队列初始化</span></span><br><span class="line">	head = <span class="number">1</span>;</span><br><span class="line">	tail = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//往队列插入降落的起始坐标</span></span><br><span class="line">	que[tail].x = startx;</span><br><span class="line">	que[tail].y = starty;</span><br><span class="line">	tail++;</span><br><span class="line">	book[startx][starty] = <span class="number">1</span>;</span><br><span class="line">	sum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当队列不为空的时候循环</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//枚举4个方向</span></span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//计算下一步的坐标</span></span><br><span class="line">			tx = que[head].x + next[k][<span class="number">0</span>];</span><br><span class="line">			ty = que[head].y + next[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">//判断是否越界</span></span><br><span class="line">			<span class="keyword">if</span> (tx&lt;<span class="number">1</span> || tx&gt;n || ty&lt;<span class="number">1</span> || ty&gt;m)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//判断是否是陆地或者曾经是否走过</span></span><br><span class="line">			<span class="keyword">if</span> (a[tx][ty] &gt; <span class="number">0</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sum++;</span><br><span class="line">				<span class="comment">//每个点只入队一次，所以需要标记这个点已经走过</span></span><br><span class="line">				book[tx][ty] = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//将新扩展的点加入队列</span></span><br><span class="line">				que[tail].x = tx;</span><br><span class="line">				que[tail].y = ty;</span><br><span class="line">				tail++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		head++;<span class="comment">//注意这地方千万不能忘记</span></span><br><span class="line">		<span class="comment">//当一个点扩展结束后，head++才能继续往下扩展</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后输出岛屿的大小</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="深度探索"><a href="#深度探索" class="headerlink" title="深度探索"></a>深度探索</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：DFS</span></span><br><span class="line"><span class="comment">//	时间：2021.10.29</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="type">int</span> book[<span class="number">51</span>][<span class="number">51</span>], n, m, sum;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//定义一个方向数组</span></span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> k, tx, ty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//枚举4个方向</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//计算下一步坐标</span></span><br><span class="line">		tx = x + next[k][<span class="number">0</span>];</span><br><span class="line">		ty = y + next[k][<span class="number">1</span>];</span><br><span class="line">		<span class="comment">//判断是否越界</span></span><br><span class="line">		<span class="keyword">if</span> (tx&lt;<span class="number">1</span> || tx&gt;n || ty&lt;<span class="number">1</span> || ty&gt;m)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//判断是否是陆地</span></span><br><span class="line">		<span class="keyword">if</span> (a[tx][ty] &gt; <span class="number">0</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sum++;</span><br><span class="line">			book[tx][ty] = <span class="number">1</span>;<span class="comment">//标记这个点已走过</span></span><br><span class="line">			dfs(tx, ty);<span class="comment">//开始尝试下一个点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, startx, starty;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;startx, &amp;starty);</span><br><span class="line">	<span class="comment">//读入地图</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">	book[startx][starty] = <span class="number">1</span>;</span><br><span class="line">	sum = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//从降落的位置开始</span></span><br><span class="line">	dfs(startx, starty);</span><br><span class="line">	<span class="comment">//最后输出岛屿的大小</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其 实 这 就 是 求 一 个 图 中 独 立 子 图 的 个 数 . 这 个 算 法 就 是 鼎 鼎 大 名 的 Floodfill 漫水填 充 法<br>( 也 称 种 子 填 充 法 ),Floodfill 在 计 算 昺 图 形 学 中 昉 着 非 常 广 泛 的 运 用 , 比 如 图 像 分 割 、 物 体<br>识 别 等 等 。 古 外 我 们 熟 知 的 Windows 下 “ 画 图“ 软 件 的 油 漆 桶 工 具 就 是 基 于 这 个 算 法 的 。<br>当 你 需 要 给 棠 个 密 闭 区 域 涂 色 或 者 更 改 标 个 密 闭 区 域的 颜 色 时 , 程 序 自 动 选 中 与 种 子 点 ( 鼠<br>标 左 键 单 击 的 位 置 ) 周 边 颜 色 相 同 的 区 域 , 拳 着 将 该 区 域 替 扢 成 戇 定 的 颜 色 。Photoshop 的<br>魔 是 桐 选 择 工 具 也 可 以 基 于 这 个 算 法 实 现 。 具 体 的 算 法 是 : 曥 找 种 子 点 周 边 的 点 , 将 与 种 子<br>点 颜 色 相 近 的 点 ( 可 以 设 置 一 个 闹 值 ) 入 队 作 为 新 种 子 , 并 对 新 入 队 的 种 子 也 迹 行 同 样 的 扩<br>展 操 作 , 这 样 就 选 取 了 和 昀 初 种 子 相 近 颜 色 的 区 域</p>
<h3 id="第-6-节-水管工游戏-117"><a href="#第-6-节-水管工游戏-117" class="headerlink" title="第 6 节 水管工游戏 117"></a>第 6 节 水管工游戏 117</h3><p><a href="https://github.com/0joe1/algorithm/">github 0joe1 水管工游戏 源码</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="type">int</span> book[<span class="number">51</span>][<span class="number">51</span>],n,m,flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pos</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;s[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">isvalid</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; a[x][y])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> front)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==n<span class="number">-1</span> &amp;&amp; y==m)&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;top;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,s[i].x,s[i].y);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isvalid(x,y) || book[x][y])&#123;</span><br><span class="line">       <span class="comment">// printf(&quot;(%d,%d)&quot;,x,y);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    book[x][y]=<span class="number">1</span>;</span><br><span class="line">    s[top].x=x;</span><br><span class="line">    s[top].y=y;</span><br><span class="line">    top++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a[x][y]&gt;<span class="number">0</span> &amp;&amp; a[x][y]&lt;=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (front)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            dfs(x<span class="number">-1</span>,y,<span class="number">4</span>);</span><br><span class="line">            dfs(x+<span class="number">1</span>,y,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            dfs(x,y<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">            dfs(x,y+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            dfs(x<span class="number">-1</span>,y,<span class="number">4</span>);</span><br><span class="line">            dfs(x+<span class="number">1</span>,y,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            dfs(x,y<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">            dfs(x,y+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[x][y]&gt;<span class="number">4</span> &amp;&amp; a[x][y]&lt;=<span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (front)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            dfs(x,y+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            dfs(x+<span class="number">1</span>,y,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            dfs(x,y<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            dfs(x<span class="number">-1</span>,y,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    book[x][y]=<span class="number">0</span>;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到铺设方案&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*5 4</span></span><br><span class="line"><span class="comment">5 3 5 3</span></span><br><span class="line"><span class="comment">1 5 3 0</span></span><br><span class="line"><span class="comment">2 3 5 1</span></span><br><span class="line"><span class="comment">6 1 1 5</span></span><br><span class="line"><span class="comment">1 5 5 4*/</span></span><br></pre></td></tr></table></figure>

<h2 id="第-5-章-图的遍历-128"><a href="#第-5-章-图的遍历-128" class="headerlink" title="第 5 章 图的遍历 128"></a>第 5 章 图的遍历 128</h2><h3 id="第-1-节-深庞和广庞优先究竟是指啥-129"><a href="#第-1-节-深庞和广庞优先究竟是指啥-129" class="headerlink" title="第 1 节 深庞和广庞优先究竟是指啥 129"></a>第 1 节 深庞和广庞优先究竟是指啥 129</h3><h4 id="深度优先搜索遍历图"><a href="#深度优先搜索遍历图" class="headerlink" title="深度优先搜索遍历图"></a>深度优先搜索遍历图</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.10.30</span></span><br><span class="line"><span class="comment">//  目的：用深度优先搜索遍历图（无向）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> book[<span class="number">101</span>], sum, n, e[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="comment">//这里的图是用一个二维数组e来存储，二维数组中第i行第j列表示的就是顶点i到&#x27;</span></span><br><span class="line"><span class="comment">//顶点j是否有边，1表示有边，无穷表示没有边。这里我们将自己到自己（即i等于j)</span></span><br><span class="line"><span class="comment">//设为0.我们将这种存储图的方法称为图的邻接矩阵存储法。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur)</span><span class="comment">//cur是当前所在的顶点编号</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cur);</span><br><span class="line">	sum++;<span class="comment">//每访问一个顶点，sum就加1</span></span><br><span class="line">	<span class="keyword">if</span> (sum == n)   <span class="keyword">return</span>;<span class="comment">//所有的顶点都已经访问过则直接退出</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//从1号顶点到n号顶点依次尝试，看哪些顶点与当前顶点cur有边相连</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//判断当前顶点cur到顶点i是否有边，并判断顶点i是否已访问过</span></span><br><span class="line">		<span class="keyword">if</span> (e[cur][i] == <span class="number">1</span> &amp;&amp; book[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			book[i] = <span class="number">1</span>;</span><br><span class="line">			dfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, m, a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//初始化二维矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j) e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> e[i][j] = <span class="number">99999999</span>;<span class="comment">//我们这里假设99999999为正无穷</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入顶点之间的边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		e[a][b] = <span class="number">1</span>;</span><br><span class="line">		e[b][a] = <span class="number">1</span>;<span class="comment">//这里是无向图，所以需要将e[b][a]也赋为1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从1号城市出发</span></span><br><span class="line">	book[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//标记1号顶点已访问</span></span><br><span class="line">	dfs(<span class="number">1</span>);<span class="comment">//从1号顶点开始遍历</span></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="广度优先搜索遍历图"><a href="#广度优先搜索遍历图" class="headerlink" title="广度优先搜索遍历图"></a>广度优先搜索遍历图</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.10.30</span></span><br><span class="line"><span class="comment">//  目的：用广度优先搜索遍历图(无向）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, n, m, a, b, cur, book[<span class="number">101</span>] = &#123; <span class="number">0</span> &#125;, e[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">	<span class="type">int</span> que[<span class="number">10001</span>], head, tail;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//初始化二维矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j) e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> e[i][j] = <span class="number">99999999</span>;<span class="comment">//假设99999999为无穷大</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入顶点之间的边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		e[a][b] = <span class="number">1</span>;</span><br><span class="line">		e[b][a] = <span class="number">1</span>;<span class="comment">//因为这里是无向图</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//队列初始化</span></span><br><span class="line">	head = <span class="number">1</span>;</span><br><span class="line">	tail = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从1号顶点出发，将1号顶点加入队列</span></span><br><span class="line">	que[tail] = <span class="number">1</span>;</span><br><span class="line">	tail++;</span><br><span class="line">	book[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//标记1号顶点已访问</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//当队列不为空的时候循环</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		cur = que[head];<span class="comment">//当前正在访问的顶点编号</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//从1-n依次尝试</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//判断从顶点cur到顶点i是否有边，并判断顶点i是否已经访问过</span></span><br><span class="line">			<span class="keyword">if</span> (e[cur][i] == <span class="number">1</span> &amp;&amp; book[i] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//如果从顶点cur到顶点i有边，并且顶点i没有被访问过，则将顶点i入队</span></span><br><span class="line">				que[tail] = i;</span><br><span class="line">				tail++;</span><br><span class="line">				book[i] = <span class="number">1</span>;<span class="comment">//标记顶点i已访问</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果tail大于n，则表明所有顶点都已经被访问过了</span></span><br><span class="line">			<span class="keyword">if</span> (tail &gt; n)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		head++;<span class="comment">//注意这个地方，千万不要忘记当一个顶点扩展结束后，head++，然后才能继续向下扩展</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; tail; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, que[i]);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-2-节-城市地图——图的深庞优先遍历"><a href="#第-2-节-城市地图——图的深庞优先遍历" class="headerlink" title="第 2 节 城市地图——图的深庞优先遍历"></a>第 2 节 城市地图——图的深庞优先遍历</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.11.1</span></span><br><span class="line"><span class="comment">//	算法：用深度优先搜索遍历图（有向）</span></span><br><span class="line"><span class="comment">//	目的：找出两个地点的最短路径</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> min = <span class="number">99999999</span>, book[<span class="number">101</span>], n, e[<span class="number">101</span>][<span class="number">101</span>];<span class="comment">//我们这里假设99999999为正无穷</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cur是当前所在的城市编号，dis是当前已经走过的路程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> dis)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="comment">//如果当前走过的路程已经大于之前找到的最短路，则没有必要再往下尝试了，立即返回</span></span><br><span class="line">	<span class="keyword">if</span> (dis &gt; min) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (cur == n)<span class="comment">//判断是否到达了目标城市</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dis &lt; min) min = dis;<span class="comment">//更新最小值</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//从1号城市到n号城市依次尝试</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//判断当前城市cur到城市j是否有路，并判断城市j是否在已走过的路径中</span></span><br><span class="line">		<span class="keyword">if</span> (e[cur][j] != <span class="number">99999999</span> &amp;&amp; book[j] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			book[j] = <span class="number">1</span>;<span class="comment">//标记城市j已经在路径中</span></span><br><span class="line">			dfs(j, dis + e[cur][j]);<span class="comment">//从城市j再出发，继续寻找目标城市</span></span><br><span class="line">			book[j] = <span class="number">0</span>;<span class="comment">//之前一步探索完毕之后，取消对城市j的标记</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, m, a, b, c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//初始化二维矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j) e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span>   e[i][j] = <span class="number">99999999</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入城市之间的道路</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		e[a][b] = c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从1号城市出发</span></span><br><span class="line">	book[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//标记1号城市已经在路径中</span></span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">0</span>);<span class="comment">//1表示当前所在的城市编号，0表示当前已经走过的路程</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, min);<span class="comment">//打印1号城市到5号城市的最短路径</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-3-节-最少转机——图的广庞优先遍历"><a href="#第-3-节-最少转机——图的广庞优先遍历" class="headerlink" title="第 3 节 最少转机——图的广庞优先遍历"></a>第 3 节 最少转机——图的广庞优先遍历</h3><p>广 度 优 先 搜 索 更加 适 用 于 所 有边的权 值 相 同的 情 况<br>图 的 邻接 矩 阵 存 傅 法 。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//   时间：2021.11.3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> x;<span class="comment">//城市编号</span></span><br><span class="line">	<span class="type">int</span> s;<span class="comment">//转机次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">que</span>[2501];</span></span><br><span class="line">	<span class="type">int</span> e[<span class="number">51</span>][<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;, book[<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> head, tail;</span><br><span class="line">	<span class="type">int</span> i, j, n, m, a, b, cur, start, end, flag = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;start, &amp;end);</span><br><span class="line">	<span class="comment">//初始化二维矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j)  e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span>  e[i][j] = <span class="number">99999999</span>;</span><br><span class="line">	<span class="comment">//读入城市之间的航班</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="comment">//注意这里是无向图</span></span><br><span class="line">		e[a][b] = <span class="number">1</span>;</span><br><span class="line">		e[b][a] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//队列初始化</span></span><br><span class="line">	head = <span class="number">1</span>;</span><br><span class="line">	tail = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从start号城市出发，将start号城市加入队列</span></span><br><span class="line">	que[tail].x = start;</span><br><span class="line">	que[tail].s = <span class="number">0</span>;</span><br><span class="line">	tail++;</span><br><span class="line">	book[<span class="number">1</span>] = start;<span class="comment">//标记start号城市已在队列中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//当队列不为空的时候循环</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		cur = que[head].x;<span class="comment">//当前队列中首城市的编号</span></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//从1到n依次尝试</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//从城市cur到城市j是否有航班并且判断城市j是否已经在队列中</span></span><br><span class="line">			<span class="keyword">if</span> (e[cur][j] != <span class="number">99999999</span> &amp;&amp; book[j] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//如果从城市cur到城市j有航班并且城市j不在队列中，则将j号城市入队</span></span><br><span class="line">				que[tail].x = j;</span><br><span class="line">				que[tail].s = que[head].s + <span class="number">1</span>;<span class="comment">//转机次数+1</span></span><br><span class="line">				tail++;</span><br><span class="line">				<span class="comment">//标记城市j已经在队列中</span></span><br><span class="line">				book[j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果到达目标城市，停止扩展，任务结束，退出循环</span></span><br><span class="line">			<span class="keyword">if</span> (que[tail].x == end)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//注意下面两句话的位置千万不要写颠倒了</span></span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		head++;<span class="comment">//注意这地方，千万不要忘记当一个点扩展结束后，head++才能继续扩展</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印队列中末尾最后一个（目标城市）的转机次数</span></span><br><span class="line">	<span class="comment">//注意tail是指向队列队尾（即最后一位）的下一个位置，所以需要-1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, que[tail - <span class="number">1</span>].s);</span><br><span class="line"></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第-6-章-最短路廮"><a href="#第-6-章-最短路廮" class="headerlink" title="第 6 章 最短路廮"></a>第 6 章 最短路廮</h2><h3 id="第-1-节-只有五行的算法——Floyd-Warshall"><a href="#第-1-节-只有五行的算法——Floyd-Warshall" class="headerlink" title="第 1 节 只有五行的算法——Floyd-Warshall"></a>第 1 节 只有五行的算法——Floyd-Warshall</h3><p>多 源 最 短 路 径</p>
<p>如果要让任意两点(例如从顶点 a 到顶点 b)之间的路程变短，<br>只能引入第三个点(顶点 k)，并通过这个顶点 k 中转即 a→k→b，才可能缩短原来从顶点 a 到顶点 b 的路程。那么这个中转的顶点 k 是 1~n 中的哪个点呢?<br>甚至有时候不只通过一个点，而是经过两个点或者更多点中转会更短，<br>即 a→k1→k2→b 或者 a→k1→k2→…ki…→b。</p>
<p>比如上图中<br>从 4 号城市到 3 号城市(4-3)的路程 e[4][3]原本是 12,<br>如果只通过 1 号城市中转(4→1→3)，路程将缩短为 11(e[4][1]+e[1][3]&#x3D;5+6&#x3D;11)。<br>其实 1 号城市到 3 号城市也可以通过 2 号城市中转,使得 1 号到 3 号城市的路程缩短为 5<br>(e[1][2]+e[2][3]&#x3D;2+3&#x3D;5)。<br>所以如果同时经过 1 号和 2 号两个城市中转的话，从 4 号城市到 3 号城市的路程会进一步缩短为 10。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：Floyd-Warshall</span></span><br><span class="line"><span class="comment">//	时间：2021.11.3 22点41分</span></span><br><span class="line"><span class="comment">//  目的：求解多源路最短路径问题（任意两个点之间的最短路径）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> e[<span class="number">10</span>][<span class="number">10</span>], k, i, j, n, m, t1, t2, t3;</span><br><span class="line">	<span class="type">int</span> inf = <span class="number">99999999</span>;<span class="comment">//用inf(infinity的缩写)存储一个我们认为的正无穷值</span></span><br><span class="line">	<span class="comment">//读入n和m,n表示顶点个数，m表示边的条数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j) e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> e[i][j] = inf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;t1, &amp;t2, &amp;t3);</span><br><span class="line">		e[t1][t2] = t3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Floyd-Warshall算法核心语句</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				<span class="keyword">if</span> (e[i][j] &gt; e[i][k] + e[k][j])</span><br><span class="line">					e[i][j] = e[i][k] + e[k][j];</span><br><span class="line">	<span class="comment">//输出最终的结果</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%10d&quot;</span>, e[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-2-节-Dijkstra-算法——通过边实现松廅-155"><a href="#第-2-节-Dijkstra-算法——通过边实现松廅-155" class="headerlink" title="第 2 节 Dijkstra 算法——通过边实现松廅 155"></a>第 2 节 Dijkstra 算法——通过边实现松廅 155</h3><p>单 源 最 短 路 径 迪杰斯特拉</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.11.3 23点11分</span></span><br><span class="line"><span class="comment">//	算法：Dijkstra算法</span></span><br><span class="line"><span class="comment">//	目的：求解单源最短路径（指定一个点（源点）到其余各个顶点的最短路径）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> e[<span class="number">10</span>][<span class="number">10</span>], dis[<span class="number">10</span>], book[<span class="number">10</span>], i, j, n, m, t1, t2, t3, u, v, min;</span><br><span class="line">	<span class="type">int</span> inf = <span class="number">99999999</span>;<span class="comment">//用inf(infinity的缩写)存储一个我们认为的正无穷值</span></span><br><span class="line">	<span class="comment">//读入n和m,n表示顶点个数，m表示边的条数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j) e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> e[i][j] = inf;</span><br><span class="line">	<span class="comment">//读入边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;t1, &amp;t2, &amp;t3);</span><br><span class="line">		e[t1][t2] = t3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化dis数组</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		dis[i] = e[<span class="number">1</span>][i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//book数组初始化</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		book[i] = <span class="number">0</span>;</span><br><span class="line">	book[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Dijkstra算法核心语句</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//一共n个顶点，1号本身已经在p集合里面了，所以</span></span><br><span class="line">	&#123;						<span class="comment">//只需要循环n-1次即可</span></span><br><span class="line">		<span class="comment">//找到离1号顶点最近的顶点</span></span><br><span class="line">		min = inf;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (book[j] == <span class="number">0</span> &amp;&amp; dis[j] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = dis[j];</span><br><span class="line">				u = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		book[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (v = <span class="number">1</span>; v &lt;= n; v++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (e[u][v] &lt; inf)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (dis[v] &gt; dis[u] + e[u][v])</span><br><span class="line">					dis[v] = dis[u] + e[u][v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出最后的结果</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line"></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通 过 上 面 的 代 码 我 们 可 以 看 出 , 这 个 算 法 的 时 间 复 時 度 是 O 吉 。 其 中 每 次 找 到 离 1 号<br>项 点 昀 近 的 顶 点 的 时 间 复 時 度 是 O (9J, 这 里 我 们 可 以 用 “ 堆 “( 将 在 下 一 章 学 到 〕 晥 优 化 ,<br>使 得 这一部分的时 间 复 時 度 降 低 到 O(logW。 另 外 对 于 边 数 M 少 于 A 的 稀 疏 图 晥 说 ( 我 们<br>把 M 远 小 于 F 的 图 称 为 稀 疏 图 , 而 M 相 对 较 大 的 图 称 为 稠 密 图 ), 我 们 可以 用 邰 接 表 ( 这<br>是 个 神 马 东 西 ? 不 要 着 急 , 待 会 再 仔 细 讲 解) 晥 代 替 邻 接 矩 阵 , 使 得 整 个 时 间 复 時 度 优 化 到<br>O(M+N)logN. 请 注 意 ! 在 昀 坏 的 情 况 下 M 就 是 , 这 朷 的 话 (M+WilogW 要 比 P 还 要 大 。<br>但 是 大 多 数 情 况 下 并 不 会 昉 那 么 多 边 , 因 此 (M+WiogN 要 比 F 小 很 多 。<br>这 里 我 们 主 要 晥 讲 解 如 何 使 用 邻 接 表 晥 存 储 一 个 图 , 先 上 数</p>
<p>不 过 朹 据<br>这 个 原 理 , 用 昬 算 法 求 昀 短 路 径 的 囹 是 不 能 昉 负 晃 边 的 , 因 为 扩 展 到 负 晃 边 的 时 候 会 产 生 更<br>短 的 路 程 , 昉 可 能 就 破 坏 了 已 经 更 新 的 点 路 程 不 会 改 变 的 性 质</p>
<h4 id="数据结构：邻接矩阵"><a href="#数据结构：邻接矩阵" class="headerlink" title="数据结构：邻接矩阵"></a>数据结构：邻接矩阵</h4><p><img src="/../img/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="邻接矩阵"></p>
<h4 id="数据结构：邻接表"><a href="#数据结构：邻接表" class="headerlink" title="数据结构：邻接表"></a>数据结构：邻接表</h4><p><img src="/../img/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt="邻接表"></p>
<h3 id="第-3-节-Bellman-Ford——解决负权边"><a href="#第-3-节-Bellman-Ford——解决负权边" class="headerlink" title="第 3 节 Bellman-Ford——解决负权边"></a>第 3 节 Bellman-Ford——解决负权边</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.11.14  22点08分</span></span><br><span class="line"><span class="comment">//	算法：Bellman-Ford</span></span><br><span class="line"><span class="comment">//	目的：解决负权边得问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> dis[<span class="number">10</span>], bak[<span class="number">10</span>], i, k, n, m, u[<span class="number">10</span>], v[<span class="number">10</span>], w[<span class="number">10</span>], check, flag;</span><br><span class="line">	<span class="type">int</span> inf = <span class="number">99999999</span>;<span class="comment">//用inf存储一个我们认为得正无穷值</span></span><br><span class="line">	<span class="comment">//读入n和m，n表示顶点个数，m表示边的个数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u[i], &amp;v[i], &amp;w[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化dis数组，这里是1号顶点到其余各个顶点得初始路程</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		dis[i] = inf;</span><br><span class="line">	dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Bellman-Ford算法核心语句</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n - <span class="number">1</span>; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将dis数组备份到bak数组中</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) bak[i] = dis[i];</span><br><span class="line">		<span class="comment">//进行一轮松弛</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">			<span class="keyword">if</span> (dis[v[i]] &gt; dis[u[i]] + w[i])</span><br><span class="line">				dis[v[i]] = dis[u[i]] + w[i];</span><br><span class="line">		<span class="comment">//松弛完毕后检测dis是否有更新</span></span><br><span class="line">		check = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (bak[i] != dis[i]) &#123; check = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (check == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//如果dis数组没有更新，提前退出循环结束算法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检测负权回路</span></span><br><span class="line">	flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="keyword">if</span> (dis[v[i]] &gt; dis[u[i]] + w[i]) flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;此图含有负权回路&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输出最终的结果</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-4-节-Bellman-Ford-的队列优化"><a href="#第-4-节-Bellman-Ford-的队列优化" class="headerlink" title="第 4 节 Bellman-Ford 的队列优化"></a>第 4 节 Bellman-Ford 的队列优化</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.11.14  22点44分</span></span><br><span class="line"><span class="comment">//	算法：Bellman-Ford 算法队列优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n, m, i, j, k;</span><br><span class="line">	<span class="comment">//u,v和w的数组大小要根据实际情况来设置，要比m的最大值要大一</span></span><br><span class="line">	<span class="type">int</span> u[<span class="number">8</span>], v[<span class="number">8</span>], w[<span class="number">8</span>];</span><br><span class="line">	<span class="comment">//first要比n的最大值大1，next要比m的最大值要大一</span></span><br><span class="line">	<span class="type">int</span> first[<span class="number">6</span>], next[<span class="number">8</span>];</span><br><span class="line">	<span class="type">int</span> dis[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;, book[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//book数组用来记录那些顶点已经在队列中了</span></span><br><span class="line">	<span class="type">int</span> que[<span class="number">101</span>] = &#123; <span class="number">0</span> &#125;, head = <span class="number">1</span>, tail = <span class="number">1</span>;<span class="comment">//定义一个队列，并初始化队列</span></span><br><span class="line">	<span class="type">int</span> inf = <span class="number">99999999</span>;<span class="comment">//用inf来存储一个我们认为的正无穷值</span></span><br><span class="line">	<span class="comment">//读入n,m</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化dis数组，这里是1号顶点到其余各个顶点的初始化路程</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		dis[i] = inf;</span><br><span class="line">	dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化book数组，初始化为0，刚开始都不在队列中</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) book[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化first数组下标1~n的值为-1，表示1~n顶点暂时都没有边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) first[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//读入每一条边</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u[i], &amp;v[i], &amp;w[i]);</span><br><span class="line">		<span class="comment">//下面两句是建立邻接表的关键</span></span><br><span class="line">		next[i] = first[u[i]];</span><br><span class="line">		first[u[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//1号顶点入队</span></span><br><span class="line">	que[tail] = <span class="number">1</span>; tail++;</span><br><span class="line">	book[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//标记1号顶点已经入队</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)<span class="comment">//队列不为空的时候循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		k = first[que[head]];<span class="comment">//当前需要处理的队首顶点</span></span><br><span class="line">		<span class="keyword">while</span> (k != <span class="number">-1</span>)<span class="comment">//扫描当前顶点所有的边</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dis[v[k]] &gt; dis[u[k]] + w[k])<span class="comment">//判断是否松弛成功</span></span><br><span class="line">			&#123;</span><br><span class="line">				dis[v[k]] = dis[u[k]] + w[k];<span class="comment">//更新顶点1到顶点v[k]的路程</span></span><br><span class="line">				<span class="comment">//这里的book数组用来判断顶点v[k]是否在队列中</span></span><br><span class="line">				<span class="comment">//如果不使用一个数组来标记的话，判断一个顶点是否在队列中每次都需要</span></span><br><span class="line">				<span class="comment">//从队列的head到tail扫一遍，很浪费时间</span></span><br><span class="line">				<span class="keyword">if</span> (book[v[k]] == <span class="number">0</span>)<span class="comment">//0表示不在队列中，将顶点v[k]加入队列中</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//下面两句是入队操作</span></span><br><span class="line">					que[tail] = v[k];</span><br><span class="line">					tail++;</span><br><span class="line">					book[v[k]] = <span class="number">1</span>;<span class="comment">//同时标记顶点v[k]已经入队</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//出队</span></span><br><span class="line">		book[que[head]] = <span class="number">0</span>;</span><br><span class="line">		head++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出1号顶点到其余各点的最短路径</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line"></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-5-节-最短路廮算法对比分析"><a href="#第-5-节-最短路廮算法对比分析" class="headerlink" title="第 5 节 最短路廮算法对比分析"></a>第 5 节 最短路廮算法对比分析</h3><p><img src="/../img/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BB%AE%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90.png" alt="最短路廮算法对比分析"></p>
<p>如 暜 要 求 的 是 所 昉 点 对 间 的 昀 短 路 径 , 或 者 如 暜 数 据 范 围 较 小 , 则 Floyd 算 法 比 较 适 合 。<br>Dijkstra 算 法 昀 大 的 弊 端 是 它 无 法 适 应 昉 负 晃 边 的 图 . 但 是 Dijkstra 具 昉 良 好的 可 扩 展 性 , 扩展 后 可以 适 应 很 多 问 顾 。 古 外 用 堆 优 化 的 Dijkstra 算 法 的 时 间 复 時 度 可 以 达 到 O(MlogN).<br>当边 昉负 晃 时 , 需 要 使 用 Bellman-Ford 算 法 或 者 队 列 优 化 的 Bellman-Ford 算 法 .</p>
<h2 id="第-7-章-神奇的树"><a href="#第-7-章-神奇的树" class="headerlink" title="第 7 章 神奇的树"></a>第 7 章 神奇的树</h2><h3 id="第-1-节-康启“树”之旅"><a href="#第-1-节-康启“树”之旅" class="headerlink" title="第 1 节 康启“树”之旅"></a>第 1 节 康启“树”之旅</h3><p><img src="/../img/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%A0%91%E4%B8%8E%E5%9B%BE.png" alt="树与图"></p>
<h3 id="第-2-节-二叉树"><a href="#第-2-节-二叉树" class="headerlink" title="第 2 节 二叉树"></a>第 2 节 二叉树</h3><h3 id="第-3-节-堆——神奇的优先队列"><a href="#第-3-节-堆——神奇的优先队列" class="headerlink" title="第 3 节 堆——神奇的优先队列"></a>第 3 节 堆——神奇的优先队列</h3><h4 id="最小堆"><a href="#最小堆" class="headerlink" title="最小堆"></a>最小堆</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：堆排序（建立最小堆实现从小到大排序）</span></span><br><span class="line"><span class="comment">//	时间：2021.11.15 16点02分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> h[<span class="number">101</span>];<span class="comment">//用来存放堆的数组</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//用来存放堆中元素的个数，也就是堆的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换函数，用来交换队中两个元素的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	t = h[x];</span><br><span class="line">	h[x] = h[y];</span><br><span class="line">	h[y] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下调整的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftdown</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//传入一个需要向下调整的结点编号i,即从堆的顶点开始向下调整</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t, flag = <span class="number">0</span>;<span class="comment">//flag用来标记是否需要继续向下调整</span></span><br><span class="line">	<span class="comment">//当i结点有儿子（其实是至少有左儿子）并且有需要继续调整的时候循环就执行</span></span><br><span class="line">	<span class="keyword">while</span> (i * <span class="number">2</span> &lt;= n &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//首先判断它和左儿子的关系，并用t记录值较小的结点编号</span></span><br><span class="line">		<span class="keyword">if</span> (h[i] &gt; h[i * <span class="number">2</span>])</span><br><span class="line">			t = i * <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t = i;</span><br><span class="line">		<span class="comment">//如果它有右儿子，再对右儿子进行讨论</span></span><br><span class="line">		<span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果右儿子的值更小，更新较小的结点编号</span></span><br><span class="line">			<span class="keyword">if</span> (h[t] &gt; h[i * <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">				t = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果发现最小的结点编号不是自己，说明子结点中有比父结点更小的</span></span><br><span class="line">		<span class="keyword">if</span> (t != i)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(t, i);<span class="comment">//交换它们</span></span><br><span class="line">			i = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			flag = <span class="number">1</span>;<span class="comment">//否则说明当前的父结点已经比两个子结点都要小了，不需要在进行调整</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立堆的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">//从最后一个非叶结点到第一个结点依次进行向上调整</span></span><br><span class="line">	<span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		siftdown(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除最大的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletemax</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	t = h[<span class="number">1</span>];<span class="comment">//用一个临时变量记录堆顶点的值</span></span><br><span class="line">	h[<span class="number">1</span>] = h[n];<span class="comment">//将堆的最后一个点赋值到堆顶</span></span><br><span class="line">	n--;<span class="comment">//堆的元素减少1</span></span><br><span class="line">	siftdown(<span class="number">1</span>);<span class="comment">//向下调整</span></span><br><span class="line">	<span class="keyword">return</span> t;<span class="comment">//返回之前记录的堆的顶点的最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, num;</span><br><span class="line">	<span class="comment">//读入要排序的数字个数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">	n = num;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//建堆</span></span><br><span class="line">	creat();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除顶部元素,连续删除n次，其实也就是从大到小把数输出出来</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, deletemax());</span><br><span class="line"></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="最大堆"><a href="#最大堆" class="headerlink" title="最大堆"></a>最大堆</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：堆排序（建立最大堆实现从小到大排序）</span></span><br><span class="line"><span class="comment">//	时间：2021.11.15 16点44分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> h[<span class="number">101</span>];<span class="comment">//用来存放堆的数组</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//用来存储堆中元素的个数，也就是堆的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换函数，用来交换堆中的两个元素的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	t = h[x];</span><br><span class="line">	h[x] = h[y];</span><br><span class="line">	h[y] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向下调整函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftdown</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//传入一个需要向下调整的结点编号i，这里传入1，即从堆的顶点开始向下调整</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t, flag = <span class="number">0</span>;<span class="comment">//flag用来标记是否需要继续向下调整</span></span><br><span class="line">	<span class="comment">//当结点有儿子（其实是至少有左儿子）并且有需要继续调整的时候循环就执行</span></span><br><span class="line">	<span class="keyword">while</span> (i * <span class="number">2</span> &lt;= n &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//首先判断它和左儿子的关系，并且用t记录较大的结点编号</span></span><br><span class="line">		<span class="keyword">if</span> (h[i] &lt; h[i * <span class="number">2</span>])</span><br><span class="line">			t = i * <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t = i;</span><br><span class="line">		<span class="comment">//如果它有右儿子，再对右儿子进行讨论</span></span><br><span class="line">		<span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果右儿子的值更大，更新较小的结点编号</span></span><br><span class="line">			<span class="keyword">if</span> (h[t] &lt; h[i * <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">				t = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果发现最大的结点编号不是自己，说明子结点有比父结点更大的</span></span><br><span class="line">		<span class="keyword">if</span> (t != i)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(t, i);<span class="comment">//交换它们</span></span><br><span class="line">			i = t;<span class="comment">//更新i为刚才与它交换的儿子结点的编号，便于接下来继续向下调整</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			flag = <span class="number">1</span>;<span class="comment">//否则说明当前的父结点已经比两个子结点都要大了，不需要再进行调整了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立堆的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">//从最后一个非叶结点到第一个结点依次进行向上调整</span></span><br><span class="line">	<span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		siftdown(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapsort</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(<span class="number">1</span>, n);</span><br><span class="line">		n--;</span><br><span class="line">		siftdown(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, num;</span><br><span class="line">	<span class="comment">//读入n个数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">	n = num;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//建堆</span></span><br><span class="line">	creat();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//堆排序</span></span><br><span class="line">	heapsort();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[i]);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>支 持 插 入 元 素 和 寻 找 昀 大 〔 小 ) 值 元 素 的 数 据 结 暄称 为 优 先 队 列</p>
<p>使 用 普 通 队 列 晥 实 现 这 两 个 功 能 , 那 么 寻 找 昀 大 元 素 需 要 暚 举 整 个 队 列 ,这 朷 的 时 间 复 時 度 比 较高<br>如 暜 是 已 排 序 好 的 数 组 , 那 么 插 入 一 个 元 素 则 需 要 移 动 很 多 元 素 ,时 间 复 時 度 依 旧 很 高 。<br>而 堆 就 是 一 种 优 先 队 列 的 实 现 , 可 以 很 好 地 解 冯 这 两 种 操 作 。</p>
<p>堆 还 经 常 被 用 晥 求 一 个 数 列 中 第 K 大 的 数 ,<br>只 需 要 建 立 一 个 大 小为 人 的 昀 小 堆 , 堆 项 就 是 第 人 大的 数 。<br>假 设 昉 10 个 数 , 要 求 第 3 大 的 数 。<br>第一 步 选 取 任 意 3 个 数 , 比 如 说 是 前 3 个 , 将 这 3 个 数 建 成 昀 小 堆 ,<br>然 后 从 第 4 个 数 开 始 ,与堆 顶 的 数 比 较 , 如 暜 比 堆 顺 的 数 要 小 , 那 么 这 个 数 就 不 要 , 如 暜 比 堆 项 的 数 要 大 , 则 史 弃<br>当前 堆 顶 而 将 这 个 数 做 为 新 的 堆 顶 , 并 再 去 维 护 堆 , 用 同 朷 的 方 法 去 处理 第 5-~10</p>
<h3 id="第-4-节-擒贼先擒王——并查集"><a href="#第-4-节-擒贼先擒王——并查集" class="headerlink" title="第 4 节 擒贼先擒王——并查集"></a>第 4 节 擒贼先擒王——并查集</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：并查集</span></span><br><span class="line"><span class="comment">//	时间：2021.11.15 19点30分</span></span><br><span class="line"><span class="comment">//  目的：找出一共多少个犯罪团伙，其实就是找出多少个“祖宗”</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;, n, m, k, sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//这里初始化，非常的重要，数组里面存的是自己数组下标的编号就好了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		f[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是找爹的递归函数，不停地去找爹，直到找到祖宗为止，其实就是去找犯罪团伙的最高领导人</span></span><br><span class="line"><span class="comment">//“擒贼先擒王”原则</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getf</span><span class="params">(<span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[v] == v)</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这里是路径压缩，每次在函数返回的时候，顺带把路上遇到的人的“BOSS”</span></span><br><span class="line">		<span class="comment">//改为最后找到的祖宗编号，也就是犯罪团伙的最高领导人编号。这样可以提高</span></span><br><span class="line">		<span class="comment">//今后找到犯罪团伙的最高领导人（其实是数的祖先）的速度</span></span><br><span class="line">		f[v] = getf(f[v]);</span><br><span class="line">		<span class="keyword">return</span> f[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是合并两集合的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t1, t2;</span><br><span class="line">	t1 = getf(v);</span><br><span class="line">	t2 = getf(u);</span><br><span class="line">	<span class="keyword">if</span> (t1 != t2)<span class="comment">//判断两个结点是否在一个集合中，即是否为一个祖先</span></span><br><span class="line">	&#123;</span><br><span class="line">		f[t2] = t1;</span><br><span class="line">		<span class="comment">//靠左原则，左边变成右边的BOSS，即把右边的集合，作为左边集合的子集合</span></span><br><span class="line">		<span class="comment">//经过路径压缩以后，将f[u]的根的值也赋值为v的祖先f[t1]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, x, y;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//初始化是必须的</span></span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//开始合并犯罪团伙</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		merge(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后扫描有多少个独立的犯罪团伙</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[i] == i)</span><br><span class="line">			sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实 树还昉 很 多 神 奇的 用 法 , 比 如 :</p>
<ul>
<li>线 段 树、</li>
<li>数 状数 组、</li>
<li>Trie 树( 字 典 树)、</li>
<li>二 叉 搜 索 树、</li>
<li>红 黑 树( 是一 种 平 衡 二 叉 搜 索 树) 等 等</li>
</ul>
<h2 id="第-8-章-更多精廠算法"><a href="#第-8-章-更多精廠算法" class="headerlink" title="第 8 章 更多精廠算法"></a>第 8 章 更多精廠算法</h2><h3 id="第-1-节-镖局运镖——图的最小生成树"><a href="#第-1-节-镖局运镖——图的最小生成树" class="headerlink" title="第 1 节 镖局运镖——图的最小生成树"></a>第 1 节 镖局运镖——图的最小生成树</h3><h4 id="kruskal-最小生成树-并查集连通运用"><a href="#kruskal-最小生成树-并查集连通运用" class="headerlink" title="kruskal 最小生成树 并查集连通运用"></a>kruskal 最小生成树 并查集连通运用</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：图的最小生成树</span></span><br><span class="line"><span class="comment">//	时间：2021.11.15 20点23分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> u;</span><br><span class="line">	<span class="type">int</span> v;</span><br><span class="line">	<span class="type">int</span> w;</span><br><span class="line">&#125;;<span class="comment">//为了方便排序，这里创建了一个结构体用来存储边的关系</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> <span class="title">e</span>[10];</span><span class="comment">//数组大小根据实际情况来设置，要比m的最大值大1</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[<span class="number">7</span>] = &#123; <span class="number">0</span> &#125;, sum = <span class="number">0</span>, count = <span class="number">0</span>;<span class="comment">//并查集需要用到的一些变量</span></span><br><span class="line"><span class="comment">//f数组大小根据实际情况来设置，要比n的最大值大1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">edge</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (left &gt; right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	i = left;</span><br><span class="line">	j = right;</span><br><span class="line">	<span class="keyword">while</span> (i != j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//顺序很重要，要从右边开始找</span></span><br><span class="line">		<span class="keyword">while</span> (e[j].w &gt;= e[left].w &amp;&amp; i &lt; j)</span><br><span class="line">			j--;</span><br><span class="line">		<span class="comment">//再从左边开始找</span></span><br><span class="line">		<span class="keyword">while</span> (e[i].w &lt;= e[left].w &amp;&amp; i &lt; j)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="comment">//交换</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			t = e[i];</span><br><span class="line">			e[i] = e[j];</span><br><span class="line">			e[j] = t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最终将基准数归位，将left和i互换</span></span><br><span class="line">	t = e[left];</span><br><span class="line">	e[left] = e[i];</span><br><span class="line">	e[i] = t;</span><br><span class="line"></span><br><span class="line">	quicksort(left, i - <span class="number">1</span>);<span class="comment">//继续处理左边的，这里是一个递归的过程</span></span><br><span class="line">	quicksort(i+<span class="number">1</span>, right);<span class="comment">//继续处理右边的，这里是一个递归的过程</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集寻找祖先的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getf</span><span class="params">(<span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[v] == v)</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这里是路径压缩</span></span><br><span class="line">		f[v] = getf(f[v]);</span><br><span class="line">		<span class="keyword">return</span> f[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集合并两子集合的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t1, t2;</span><br><span class="line">	t1 = getf(v);</span><br><span class="line">	t2 = getf(u);</span><br><span class="line">	<span class="keyword">if</span> (t1 != t2)<span class="comment">//判断两个点是否在同一个集合中</span></span><br><span class="line">	&#123;</span><br><span class="line">		f[t2] = t1;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">//读入n和m，n表示顶点个数，m表示边的条数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//读入边，这里用一个结构体来存储边的关系</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w);</span><br><span class="line"></span><br><span class="line">	quicksort(<span class="number">1</span>, m);<span class="comment">//按照权值从小到大对边进行快速排序</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//并查集初始化</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		f[i] = i;</span><br><span class="line">	<span class="comment">//Kruskal算法核心部分</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//开始从小到大枚举每一条边</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//判断一条边的两个顶点是否已经联通，即判断是否在一个集合中</span></span><br><span class="line">		<span class="keyword">if</span> (merge(e[i].u, e[i].v))<span class="comment">//如果目前尚未不连通，则选用这条边</span></span><br><span class="line">		&#123;</span><br><span class="line">			count++;</span><br><span class="line">			sum = sum + e[i].w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (count == n - <span class="number">1</span>)<span class="comment">//直到选用了n-1条边之后退出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">//打印结果</span></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="第-2-节-再谈最小生成树"><a href="#第-2-节-再谈最小生成树" class="headerlink" title="第 2 节 再谈最小生成树"></a>第 2 节 再谈最小生成树</h3><p><a href="https://www.cs.usfca.edu/~galles/visualization/Prim.html">Prim 最小生成树 可视化算法(Prim Minimum Cost Spanning Treeh)</a><br><a href="https://algorithm-visualizer.org/greedy/prims-minimum-spanning-tree">Prim Minimum Cost Spanning Treeh</a></p>
<h4 id="Prim-最小生成树-距离树最短路径的顶点搜索-时间复杂度-O-N²"><a href="#Prim-最小生成树-距离树最短路径的顶点搜索-时间复杂度-O-N²" class="headerlink" title="Prim 最小生成树 距离树最短路径的顶点搜索 时间复杂度 O(N²)"></a>Prim 最小生成树 距离树最短路径的顶点搜索 时间复杂度 <em>O(N²)</em></h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,m,i,j,k,min,t1,t2,t3;</span><br><span class="line">	<span class="type">int</span> e[<span class="number">7</span>][<span class="number">7</span>],dis[<span class="number">7</span>],book[<span class="number">7</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> inf=<span class="number">99999999</span>;</span><br><span class="line">	<span class="type">int</span> count=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span>(i==j) e[i][j]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">else</span> e[i][j]=inf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始读入边</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">		e[t1][t2]=t3;</span><br><span class="line">		e[t2][t1]=t3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化dis数组</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		dis[i]=e[<span class="number">1</span>][i];</span><br><span class="line"></span><br><span class="line">	book[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	count++;</span><br><span class="line">	<span class="keyword">while</span>(count&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		min=inf;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(book[i]==<span class="number">0</span> &amp;&amp; dis[i]&lt;min)</span><br><span class="line">			&#123;</span><br><span class="line">				min=dis[i];</span><br><span class="line">				j=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		book[j]=<span class="number">1</span>;</span><br><span class="line">		count++;</span><br><span class="line">		sum=sum+dis[j];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(book[k]==<span class="number">0</span> &amp;&amp; dis[k]&gt;e[j][k])</span><br><span class="line">				dis[k]=e[j][k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line"></span><br><span class="line">	getchar();getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="prim-最小生成树-堆优化-邻接表-O-MlogN"><a href="#prim-最小生成树-堆优化-邻接表-O-MlogN" class="headerlink" title="prim 最小生成树 堆优化+邻接表 O(MlogN)"></a>prim 最小生成树 堆优化+邻接表 <em>O</em>(<em>M</em>log<em>N</em>)</h4><p>把6个点放进堆中 扫描一个点的 边邻接表以后 就pop出直到所有点pop出</p>
<p>稀疏图：边的数量远小于顶点数量的平方（|E| &lt;&lt; |V|^2）的图称为稀疏图。这里的“远小于”是一个相对的概念，没有绝对的数值界限。</p>
<p>稠密图：边的数量接近顶点数量的平方（|E| ≈ |V|^2）的图称为稠密图。<br><img src="http://www.aiug.cn/wp-content/uploads/2024/09/%E7%A8%80%E7%96%8F%E5%9B%BE%E5%92%8C%E7%A8%A0%E5%AF%86%E5%9B%BE.png" alt="稀疏图&amp;稠密图"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> dis[<span class="number">7</span>], book[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// bookB A aR MET BA BOA RAE</span></span><br><span class="line"><span class="type">int</span> h[<span class="number">7</span>], pos[<span class="number">7</span>], size;    <span class="comment">// b 用 晥 保 存 堆 ,pos 用 晥 存 傅 每 个 顶 点 在 堆 中 的 位 繮 ,size 为 堆 的 大 小</span></span><br><span class="line"><span class="comment">// 交 换函数 , 用 米 交 换 堆 中 的 两 个 元 素 的 值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    t = h[x];</span><br><span class="line">    h[x] = h[y];</span><br><span class="line">    h[y] = t;</span><br><span class="line">    <span class="comment">// 同 步 更 新 pos</span></span><br><span class="line">    t = pos[h[x]];</span><br><span class="line">    pos[h[x]] = pos[h[y]];</span><br><span class="line">    pos[h[y]] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向 下 调 整 函 数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftdown</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">// 优 入 一 个 霁 要 向 下 调 整 的 结 点 縖 号</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t, flag = <span class="number">0</span>; <span class="comment">// 5lag 用 晥 朇 记 是 否 需 要 继 续 向 下 调 整</span></span><br><span class="line">    <span class="keyword">while</span> (i * <span class="number">2</span> &lt;= size &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 比 较 i 和 它 左 儿 于 i42 在 ais 中 的 值 , 干 用 t 记 录 值 轼 小 的 结 点 縖 号</span></span><br><span class="line">        <span class="keyword">if</span> (dis[h[i]] &gt; dis[h[[i * <span class="number">2</span>]]])</span><br><span class="line">            t = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = i;</span><br><span class="line">        <span class="comment">// 加 暜 它 昉 右 儿 子 , 再 对 昉 儿 二 进 行 讨 论</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加 昨 昉 儿 子 的 值 更 小 , 更 新 较 小 的 结 点 縖号</span></span><br><span class="line">            <span class="keyword">if</span> (dis[h[[t]]] &gt; dis[h[i * <span class="number">2</span> + <span class="number">1</span>]])</span><br><span class="line">                t = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如 概 发 现 昀 小 的 结 点 縖 号 不 是 自 己 , 说 明 子 结 点 中 昉 比 父 结 点 更 尔 的</span></span><br><span class="line">        <span class="keyword">if</span> (t != i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(t, i) <span class="comment">// 交 换 它 们</span></span><br><span class="line">                i = t; <span class="comment">// 更 新 ; 为 刚 才 与 它 交 换 的 儿 孔 结 点 的 縖 号 , 便 于 接 下 米 继 续 向 下 调 整</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag = <span class="number">1</span>; <span class="comment">// 则 说 明 当 前 的 文 结 点 已 经 比 两 个 孔 结 点 都 要 小 了 , 不 霜 要 彷 进 行 调 孤 了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siftup</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">// 传 入 一 个 需 要 向 上 调 整 的 结 点 縖 号</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">// 用 江朇 记 是 否 需 要 继 续 吊 上 调 整</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 如 暜 是 堆 顶 , 就 返 回 , 不 霜 要 调 驹 了</span></span><br><span class="line">    <span class="comment">// 不 在 堆 顶 , 并 东 当 前 结 点 3 的 值 比 文 结 点 小 的 时 候 继 续 向 上 调 整</span></span><br><span class="line">    <span class="keyword">while</span> (i != <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判 断 是 否 比 父 结 点 的 小</span></span><br><span class="line">        <span class="keyword">if</span> (dis[h[i]] &lt; dis[h[i / <span class="number">2</span>]])</span><br><span class="line">            swap(i, i / <span class="number">2</span>); <span class="comment">// RREME EEE</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag = <span class="number">1</span>; <span class="comment">// RAGA Hi SRE TAYE SC EEK</span></span><br><span class="line">        i = i / <span class="number">2</span>;    <span class="comment">// 这 句 话 很 重 要 , 更 新 縖 号 &#123; 为 它 父 结 点 的 縖 号 , 从 而 便 于 下 一 次 继 续 吊 上 调 整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 堆 顶 取 出 一 个 元 素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    t = h[<span class="number">1</span>];       <span class="comment">// 用 一 个 临 时 变 量 记 录 堆 顶 点 的 值</span></span><br><span class="line">    pos[t] = <span class="number">0</span>;     <span class="comment">// 其 实 这 句 要 不 要 无 所 谓</span></span><br><span class="line">    h[<span class="number">1</span>] = h[size]; <span class="comment">// 将 堆 的 昀 后 一 个 点 赔 值 到 绳 项</span></span><br><span class="line">    pos[h[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    size--;      <span class="comment">// 堆 的 元 素 凑 少 1</span></span><br><span class="line">    siftdown(<span class="number">1</span>); <span class="comment">// 向 下 调 整</span></span><br><span class="line">    <span class="keyword">return</span> t;    <span class="comment">// 返 回 之 前 记 录 的 蜡 项 点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m, i, j, k;</span><br><span class="line">    <span class="comment">// Vs w 和 next 的 数 组 大 小 要 朹 据 实 际 情 况 晥 设 繮 , 此 图 是 无 向 图 , 要 比 2 *m 的 昀 大 值 要 大 1</span></span><br><span class="line">    <span class="comment">// #izst 要 比 n 的 昀 大 值 要 大 1, 要 比 24m 的 昀 大 值 要 大 1</span></span><br><span class="line">    <span class="type">int</span> u[<span class="number">19</span>] v[<span class="number">19</span>], w[<span class="number">19</span>], sizet[<span class="number">7</span>], next[<span class="number">19</span>];</span><br><span class="line">    <span class="type">int</span> inf = <span class="number">99999999</span>;     <span class="comment">// 用 inf 《infini y 的 縩 冗 》 存 傅 一 个 我 们 认 为 的 正 无 穷 值</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, sum = <span class="number">0</span>; <span class="comment">// count 用 朗 记 录 生 成 朑 中 顶 点 的 个 数 ,sum 用 晥 存 借 路 往 之 和</span></span><br><span class="line">    <span class="comment">// 读 入 nm,n 表 示 顶 店 个 数 ,m 表 示 边 的 晡 数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读 入 边</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u[i], &amp;v[i], &amp;w[i]);</span><br><span class="line">    <span class="comment">// 这 里 是 无 向 图 , 所 以 需 要 将 所 昉 的 边 再 反 向 存 倩 一 次</span></span><br><span class="line">    <span class="keyword">for</span> (i = m + <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u[i] = v[i - m];</span><br><span class="line">        v[i] = u[i - m];</span><br><span class="line">        w[i] = w[i - m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开 始使 用 邻 接 表 存 傅 边</span></span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= n; i++)</span><br><span class="line">        first[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        next[i] = first[u[i]];</span><br><span class="line">        first[u[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2rim 朸 心部分 开 始</span></span><br><span class="line">    <span class="comment">//  将 2 号 顶 点 加 入 生 或 朑</span></span><br><span class="line">    book[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 这 里 用 book 暗 朇 记 一 个 项 点 已 经 加 入 生 成 朑</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 初 始 化 ais 数 组 , 这 里 是 1 号 顶 点 到 其 余 各 个 顶 点 的 初 始 跌 高</span></span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    k = first[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (k != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[v[k]] = w[k];</span><br><span class="line">        k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初 始 化 堆</span></span><br><span class="line">    size = n;</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= size; i++)</span><br><span class="line">        &#123;h[i] = i; pos[i]=i&#125;</span><br><span class="line">    <span class="keyword">for</span> (i = size / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        siftdown(i);</span><br><span class="line"></span><br><span class="line">    pop(); <span class="comment">// 先 弹 出 一 个 堆 顶 元 素 , 因 为 此 时 堆 顶 是 1 号 顶 点</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        j = pop();</span><br><span class="line">        book[j] = <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">        sum = sum + dis[j];</span><br><span class="line">        k = first[j];</span><br><span class="line">        <span class="keyword">while</span> (k != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (book[v[k]] == <span class="number">0</span> &amp;&amp; dis[v[k]] &gt; w[k])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v[k]] = w[k];</span><br><span class="line">                siftup(pos[v[k]]);</span><br><span class="line">            &#125;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-3-节-重要城市——图的割点"><a href="#第-3-节-重要城市——图的割点" class="headerlink" title="第 3 节 重要城市——图的割点"></a>第 3 节 重要城市——图的割点</h3><iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=883492649&bvid=BV1ZK4y1x7dm&cid=198468710&p=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> graph[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], parent[MAXN];</span><br><span class="line"><span class="type">int</span> isCut[MAXN];</span><br><span class="line"><span class="type">int</span> timeCounter;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    dfn[u] = low[u] = ++timeCounter;</span><br><span class="line">    <span class="type">int</span> children = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[u][v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                children++;</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                tarjan(v, n);</span><br><span class="line">                low[u] = (low[u] &lt; low[v]) ? low[u] : low[v];</span><br><span class="line">                <span class="keyword">if</span> (parent[u] == <span class="number">-1</span> &amp;&amp; children &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    isCut[u] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (parent[u] != <span class="number">-1</span> &amp;&amp; low[v] &gt;= dfn[u]) &#123;</span><br><span class="line">                    isCut[u] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v != parent[u]) &#123;</span><br><span class="line">                low[u] = (low[u] &lt; dfn[v]) ? low[u] : dfn[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph));</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">    <span class="built_in">memset</span>(parent, <span class="number">-1</span>, <span class="keyword">sizeof</span>(parent));</span><br><span class="line">    <span class="built_in">memset</span>(isCut, <span class="number">0</span>, <span class="keyword">sizeof</span>(isCut));</span><br><span class="line">    timeCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        graph[u][v] = <span class="number">1</span>;</span><br><span class="line">        graph[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">            tarjan(i, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCut[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Cut vertex: %d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-4-节-关键道路——图的割边"><a href="#第-4-节-关键道路——图的割边" class="headerlink" title="第 4 节 关键道路——图的割边"></a>第 4 节 关键道路——图的割边</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> graph[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], parent[MAXN];</span><br><span class="line"><span class="type">int</span> timeCounter;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    dfn[u] = low[u] = ++timeCounter;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[u][v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                tarjan(v, n);</span><br><span class="line">                low[u] = (low[u] &lt; low[v]) ? low[u] : low[v];</span><br><span class="line">                <span class="keyword">if</span> (low[v] &gt; dfn[u]) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Bridge: %d - %d\n&quot;</span>, u, v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v != parent[u]) &#123;</span><br><span class="line">                low[u] = (low[u] &lt; dfn[v]) ? low[u] : dfn[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph));</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">    <span class="built_in">memset</span>(parent, <span class="number">-1</span>, <span class="keyword">sizeof</span>(parent));</span><br><span class="line">    timeCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        graph[u][v] = <span class="number">1</span>;</span><br><span class="line">        graph[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">            tarjan(i, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第-5-节-我要做月老——二分图最大匹配"><a href="#第-5-节-我要做月老——二分图最大匹配" class="headerlink" title="第 5 节 我要做月老——二分图最大匹配"></a>第 5 节 我要做月老——二分图最大匹配</h3><h4 id="概念性的东西-二分图-匈牙利算法-增广路算法"><a href="#概念性的东西-二分图-匈牙利算法-增广路算法" class="headerlink" title="概念性的东西 二分图 匈牙利算法 增广路算法"></a>概念性的东西 二分图 匈牙利算法 增广路算法</h4><h2 id="第-9-章-还能更好吗——币软亚洲研究院面试"><a href="#第-9-章-还能更好吗——币软亚洲研究院面试" class="headerlink" title="第 9 章 还能更好吗——币软亚洲研究院面试"></a>第 9 章 还能更好吗——币软亚洲研究院面试</h2><h4 id="我的第一本算法书"><a href="#我的第一本算法书" class="headerlink" title="我的第一本算法书"></a>我的第一本算法书</h4><p>序章算法的基本知识001<br>0-1什么是算法002<br>0-2运行时间的计算方法007<br>第1章数据结构009<br>1-1什么是数据结构010<br>1-2链表013<br>1-3数组016<br>1-4栈020<br>1-5队列022<br>1-6哈希表024<br>1-7堆032<br>1-8二叉查找树036<br>第2章排序043<br>2-1什么是排序044<br>2-2冒泡排序046<br>2-3选择排序050<br>2-4插入排序052<br>2-5堆排序056<br>2-6归并排序060<br>2-7快速排序064<br>第3章数组的查找071<br>3-1线性查找072<br>3-2二分查找074<br>第4章图的搜索077<br>4-1什么是图078<br>4-2广度优先搜索082<br>4-3深度优先搜索086<br>4-4贝尔曼-福特算法090<br>4-5狄克斯特拉算法096<br>4-6A算法103<br>第5章安全算法107<br>5-1安全和算法108<br>5-2加密的基础知识112<br>5-3哈希函数116<br>5-4共享密钥加密120<br>5-5公开密钥加密124<br>5-6混合加密132<br>5-7迪菲-赫尔曼密钥交换136<br>5-8消息认证码144<br>5-9数字签名152<br>5-10数字证书158<br>第6章聚类165<br>6-1什么是聚类166<br>6-2k-means算法168<br>第7章其他算法173<br>7-1欧几里得算法174<br>7-2素性测试178<br>7-3网页排名182<br>7-4汉诺塔190</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>读书</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>小说 《A不在现场》爬虫</title>
    <url>/2024/05/19/%E5%B0%8F%E8%AF%B4-%E3%80%8AA%E4%B8%8D%E5%9C%A8%E7%8E%B0%E5%9C%BA%E3%80%8B%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="scrapy-爬虫"><a href="#scrapy-爬虫" class="headerlink" title="scrapy 爬虫"></a>scrapy 爬虫</h1><h2 id="爬取-小说正文-http-st-kanxshuo-com"><a href="#爬取-小说正文-http-st-kanxshuo-com" class="headerlink" title="爬取 小说正文 http://st.kanxshuo.com"></a>爬取 小说正文 <a href="http://st.kanxshuo.com/">http://st.kanxshuo.com</a></h2><p>保存为markdown 格式 <a href="kanxshuo-%E4%BB%96%E4%B8%8D%E5%9C%A8%E7%8E%B0%E5%9C%BA-%E8%8B%8F%E6%A0%BC%E6%8B%89%E5%A4%AB%E9%A1%BF-27846.txt">《A不在现场》前11章</a></p>
<h3 id="使用-vim-正则表达式-处理连接修改-视频字幕小说正文"><a href="#使用-vim-正则表达式-处理连接修改-视频字幕小说正文" class="headerlink" title="使用 vim 正则表达式 处理连接修改 视频字幕小说正文"></a>使用 vim 正则表达式 处理连接修改 视频字幕小说正文</h3><p><a href="%E3%80%8A%E4%B8%8D%E5%9C%A8%E7%8E%B0%E5%9C%BA%E3%80%8B11%E7%AB%A0%E5%88%B0%E6%9C%80%E5%90%8E%E4%B8%80%E7%AB%A0.txt">《不在现场》11章到最后一章</a></p>
<h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><ul>
<li><a href="spider-kanxshuo.py">spider-kanxshuo.py</a> </li>
<li><a href="./utils/mylog.py">mylog.py</a></li>
<li>依赖 <ul>
<li><a href="https://docs.scrapy.org/en/latest/">scrapy</a> </li>
<li><a href="https://scrapy-16.readthedocs.io/zh-cn/">中文版</a></li>
</ul>
</li>
</ul>
<h4 id="spider-kanxshuo-py"><a href="#spider-kanxshuo-py" class="headerlink" title="spider-kanxshuo.py"></a>spider-kanxshuo.py</h4><blockquote>
<p>其中 <code>./utils</code> 文件夹 与 <code>spider-kanxshuo.py</code> 同级</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> scrapy</span><br><span class="line"><span class="keyword">from</span> scrapy.selector <span class="keyword">import</span> Selector</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> mylog</span><br><span class="line">logger = mylog.mylogger(__name__)</span><br><span class="line"></span><br><span class="line">outDict = []</span><br><span class="line">bookCode = <span class="string">&#x27;27846&#x27;</span></span><br><span class="line">website = <span class="string">&#x27;st.kanxshuo.com/&#x27;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">kanxshuoSpider</span>(scrapy.Spider):</span><br><span class="line">    name = <span class="string">&#x27;kanxshuo-&#x27;</span>+<span class="built_in">str</span>(bookCode)</span><br><span class="line">    start_urls = [<span class="string">f&#x27;http://<span class="subst">&#123;website&#125;</span>/book-<span class="subst">&#123;bookCode&#125;</span>-1.html&#x27;</span>,]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse</span>(<span class="params">self, response</span>):</span><br><span class="line">        <span class="keyword">global</span> outDict</span><br><span class="line"></span><br><span class="line">        urltitle = response.css(<span class="string">&#x27;div.bm_h::text&#x27;</span>).get()       </span><br><span class="line">        </span><br><span class="line">       <span class="comment">#windows 文件名不能把包含以下字符</span></span><br><span class="line">        urltitle = urltitle.replace(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;:&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;*&#x27;</span>, <span class="string">&#x27;&#x27;</span>)\</span><br><span class="line">        .replace(<span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;&lt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;&lt;br&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        body = response.css(<span class="string">&#x27;div.bookContent&#x27;</span>).get()</span><br><span class="line">        body = body.replace(<span class="string">&#x27;&lt;/div&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>).replace(<span class="string">&#x27;&lt;br&gt;&#x27;</span>, <span class="string">&#x27;\n&#x27;</span>)\</span><br><span class="line">            .replace(<span class="string">&#x27;&lt;div class=&quot;bookContent&quot; id=&quot;fontzoom&quot;&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)\</span><br><span class="line">            .replace(<span class="string">&#x27;&lt;div id=&quot;a_d_4&quot;&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/skin/a_728.js&quot;&gt;&lt;/script&gt;&#x27;</span>,<span class="string">&#x27;&#x27;</span>)\</span><br><span class="line">            .replace(<span class="string">&#x27;&lt;span id=&quot;a_d_1&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/skin/a_336.js&quot;&gt;&lt;/script&gt; &lt;/span&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)\</span><br><span class="line">            .replace(<span class="string">&#x27;&lt;span id=&quot;a_d_2&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/skin/a_728.js&quot;&gt;&lt;/script&gt; &lt;/span&gt;&#x27;</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        logger.info(<span class="string">&#x27;当前页: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(urltitle))</span><br><span class="line">        logger.debug(<span class="string">&#x27;正文: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(body))</span><br><span class="line">        outDict.append(&#123;</span><br><span class="line">            <span class="string">&#x27;当前页&#x27;</span>: urltitle,</span><br><span class="line">            <span class="string">&#x27;正文&#x27;</span>: body,</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            <span class="string">&#x27;当前页&#x27;</span>: urltitle,</span><br><span class="line">            <span class="string">&#x27;正文&#x27;</span>: body,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next_page = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">for</span> nextpage <span class="keyword">in</span> response.css(<span class="string">&#x27;div.bpages&#x27;</span>).css(<span class="string">&#x27;a&#x27;</span>):</span><br><span class="line">            pagename = nextpage.css(<span class="string">&#x27;a.pn::text&#x27;</span>).get()</span><br><span class="line">            <span class="comment">#logger.debug(&#x27;&#123;&#125; &#x27;.format(pagename))</span></span><br><span class="line">            <span class="keyword">if</span> pagename == <span class="string">&#x27;下─页&#x27;</span>:</span><br><span class="line">                next_page = nextpage.css(<span class="string">&#x27;a::attr(&quot;href&quot;)&#x27;</span>).get()</span><br><span class="line">                logger.debug(next_page)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment">#elif pagename != &#x27;尾页&#x27; and pagename != &#x27;首页&#x27; and pagename != &#x27;上一页&#x27; \</span></span><br><span class="line">            <span class="comment">#and int(pagename) and int(pagename) &gt; 5000000:</span></span><br><span class="line">            <span class="comment">#    break</span></span><br><span class="line">        <span class="keyword">if</span> next_page <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">yield</span> response.follow(next_page, <span class="variable language_">self</span>.parse)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            outjsonName = <span class="string">&quot;./txt-jsons/kanxshuo-%s-%s.json&quot;</span> % (urltitle, bookCode)</span><br><span class="line">            <span class="comment">#logger.debug(&quot;+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++&quot;)</span></span><br><span class="line">            logger.debug(outDict)</span><br><span class="line">            outMDName = <span class="string">&quot;./txt-markdown/kanxshuo-%s-%s.md&quot;</span> % (urltitle, bookCode)</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(outMDName, <span class="string">&#x27;w+&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> ff:</span><br><span class="line">                <span class="keyword">for</span> item <span class="keyword">in</span> outDict:</span><br><span class="line">                    title =  item[<span class="string">&#x27;当前页&#x27;</span>]</span><br><span class="line">                    body = item[<span class="string">&#x27;正文&#x27;</span>]</span><br><span class="line">                    md_item = <span class="string">f&#x27;##### <span class="subst">&#123;title&#125;</span>&#x27;</span> + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">                    md_item += <span class="string">f&#x27;<span class="subst">&#123;body&#125;</span>&#x27;</span> + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">                    md_item += <span class="string">&#x27;\n---\n\n&#x27;</span></span><br><span class="line">                    logger.info(md_item)</span><br><span class="line">                    ff.writelines(md_item)</span><br><span class="line">            <span class="comment">#with open(outjsonName, &quot;w+&quot;, encoding=&#x27;utf-8&#x27;) as f:</span></span><br><span class="line">            <span class="comment">#    # json.dump(dict_, f)  # 写为一行</span></span><br><span class="line">            <span class="comment">#    json.dump(outDict, f, indent=2, sort_keys=False, ensure_ascii=False)  # 写为多行</span></span><br></pre></td></tr></table></figure>

<h4 id="utils-mylog-py"><a href="#utils-mylog-py" class="headerlink" title=".&#x2F;utils&#x2F;mylog.py"></a>.&#x2F;utils&#x2F;mylog.py</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging, coloredlogs</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mylogger</span>(<span class="params">name</span>):</span><br><span class="line">    logger = logging.getLogger(name)</span><br><span class="line"></span><br><span class="line">    level_styles = coloredlogs.DEFAULT_LEVEL_STYLES.copy()</span><br><span class="line">    level_styles[<span class="string">&#x27;debug&#x27;</span>] = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;magenta&#x27;</span>&#125;</span><br><span class="line">    level_styles[<span class="string">&#x27;info&#x27;</span>] = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;yellow&#x27;</span>&#125;</span><br><span class="line">    level_styles[<span class="string">&#x27;error&#x27;</span>] = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>&#125;</span><br><span class="line">    level_styles[<span class="string">&#x27;warning&#x27;</span>] = &#123;<span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;blue&#x27;</span>&#125;</span><br><span class="line">    coloredlogs.install(</span><br><span class="line">        level=<span class="string">&quot;DEBUG&quot;</span>,  <span class="comment"># show only debug and above</span></span><br><span class="line">        <span class="comment">#fmt=&quot;%(asctime)s - %(hostname)s - %(name)s[%(process)d] -\</span></span><br><span class="line">        <span class="comment">#  %(pathname)s -%(filename)s - %(funcName)s - %(lineno)d - %(module)s - %(levelname)s - %(message)s&quot;,</span></span><br><span class="line">        fmt=<span class="string">&quot;%(asctime)s - %(hostname)s - %(name)s[%(process)d] - %(filename)s::%(funcName)s::%(lineno)d - %(levelname)s - %(message)s&quot;</span>,</span><br><span class="line"> </span><br><span class="line">        logger=logger,</span><br><span class="line">        level_styles=level_styles,</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> logger</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        logger.debug(&#x27;Print log level：debug&#x27;)</span></span><br><span class="line"><span class="string">        logger.info(&#x27;Print log level：info&#x27;)</span></span><br><span class="line"><span class="string">        logger.warning(&#x27;Print log level：warning&#x27;)</span></span><br><span class="line"><span class="string">        logger.error(&#x27;Print log level：error&#x27;)</span></span><br><span class="line"><span class="string">        logger.critical(&#x27;Print log level：critical&#x27;)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="python-执行脚本"><a href="#python-执行脚本" class="headerlink" title="python 执行脚本"></a>python 执行脚本</h3><p><code>scrapy runspider spider-kanxshuo.py -o spider-kanxshuo.json -s FEED_EXPORT_ENCODING=UTF-8 -s LOG_FILE=spider-kanxshuo.log</code></p>
<h2 id="爬取-B站-《庆余年》-有声小说视频-视频-小说-伴读书郎"><a href="#爬取-B站-《庆余年》-有声小说视频-视频-小说-伴读书郎" class="headerlink" title="爬取 B站 《庆余年》 有声小说视频 (视频+小说&#x3D;伴读书郎)"></a>爬取 B站 《庆余年》 有声小说视频 (视频+小说&#x3D;伴读书郎)</h2><ul>
<li>下载B站 有声小说视频 使用剪映 识别视频字幕 保存为小说正文</li>
<li>使用 vim 正则表达式 处理 爬取小说正文</li>
<li><a href="%E3%80%8A%E5%BA%86%E4%BD%99%E5%B9%B4%E3%80%8B_qinkan.net.txt">《庆余年》小说正文</a></li>
</ul>
<h2 id="爬虫本地数据库-NoSQL数据库"><a href="#爬虫本地数据库-NoSQL数据库" class="headerlink" title="爬虫本地数据库 NoSQL数据库"></a>爬虫本地数据库 NoSQL数据库</h2><ul>
<li><p>LiteDB</p>
<ul>
<li><a href="https://dev.listera.top/docs/litedb/">litedb_doc</a></li>
<li><a href="https://github.com/lidanger/LiteDB.wiki_Translation_zh-cn?tab=readme-ov-file">LiteDB</a></li>
</ul>
</li>
<li><p><a href="https://github.com/FileXdb/FileXdb.py">FileXdb.py</a></p>
</li>
<li><p>TinyDB</p>
<ul>
<li><a href="https://blog.csdn.net/cui_yonghua/article/details/120060474">和SQLite数据库对应的NoSQL数据库：TinyDB的详细使用（python3经典编程案例</a></li>
<li><a href="https://blog.csdn.net/GitHub_miao/article/details/139188174">Python TinyDB库：轻量级NoSQL数据库的终极指南</a></li>
<li><a href="https://tinydb.readthedocs.io/en/latest/index.html">tinydb_doc</a></li>
</ul>
</li>
</ul>
<h3 id="TinyDB"><a href="#TinyDB" class="headerlink" title="TinyDB"></a>TinyDB</h3><h4 id="更快的json读写插件-BetterJSONStorage"><a href="#更快的json读写插件-BetterJSONStorage" class="headerlink" title="更快的json读写插件 BetterJSONStorage"></a>更快的json读写插件 <a href="https://github.com/MrPigss/BetterJSONStorage">BetterJSONStorage</a></h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> BetterJSONStorage <span class="keyword">import</span> BetterJSONStorage</span><br><span class="line"><span class="keyword">from</span> tinydb <span class="keyword">import</span> TinyDB, Query</span><br><span class="line"><span class="keyword">from</span> pathlib <span class="keyword">import</span> Path</span><br><span class="line"></span><br><span class="line">path = Path(<span class="string">&#x27;./output/moviedb4.json&#x27;</span>)</span><br><span class="line">moviedb = TinyDB(path, access_mode=<span class="string">&quot;r+&quot;</span>, storage=BetterJSONStorage)</span><br><span class="line"></span><br><span class="line">moviedb.default_table_name = <span class="string">&#x27;movietable&#x27;</span></span><br><span class="line">movietable = moviedb.table(<span class="string">&#x27;movietable&#x27;</span>)</span><br><span class="line"></span><br><span class="line">query = Query()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入或者更新DB</span></span><br><span class="line">ret = movietable.upsert(movieJson, query.name == name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询DB</span></span><br><span class="line"><span class="keyword">if</span> movietable.get(query.name == name) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">doc_id = movietable.get(query.name == name).doc_id</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新DB</span></span><br><span class="line">movietable.update(&#123;<span class="string">&#x27;url&#x27;</span>:url&#125;, doc_ids = [doc_id])</span><br><span class="line">movietable.update(&#123;<span class="string">&#x27;screenshots&#x27;</span>:jsonResult[<span class="string">&#x27;screenshots&#x27;</span>]&#125;, doc_ids = [doc_id])</span><br><span class="line">movietable.update(&#123;<span class="string">&#x27;cover&#x27;</span>:cover_url&#125;, doc_ids = [doc_id])</span><br><span class="line">logger.debug(movietable.get(doc_id=doc_id))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印DB</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_db</span>():</span><br><span class="line">    outMDName = <span class="string">&quot;./db/actorDB.md&quot;</span></span><br><span class="line">    logger.info(<span class="string">&#x27;outMDName total: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(outMDName))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取数据写 markdown</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(outMDName, <span class="string">&#x27;w+&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> ff:</span><br><span class="line">        logger.info(<span class="string">&#x27;outMDName: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(outMDName))</span><br><span class="line">        <span class="keyword">with</span> TinyDB(path, access_mode=<span class="string">&quot;r+&quot;</span>, storage=BetterJSONStorage) <span class="keyword">as</span> actorDB:</span><br><span class="line">            logger.info(<span class="string">&#x27;DB total: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(actorDB))</span><br><span class="line">            actorTable = actorDB.table(<span class="string">&#x27;actorTable&#x27;</span>)</span><br><span class="line">            logger.info(<span class="string">&#x27;DB table: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(actorTable))</span><br><span class="line"></span><br><span class="line">            i = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> item <span class="keyword">in</span> actorTable.<span class="built_in">all</span>():</span><br><span class="line">                logger.info(item)</span><br><span class="line"></span><br><span class="line">                md_item = print_item(item)</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                ff.writelines(md_item)</span><br><span class="line">                ff.flush()</span><br><span class="line">                logger.info(md_item)</span><br><span class="line">                logger.info(i)</span><br><span class="line">            actorDB.close()</span><br><span class="line">        ff.close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入DB</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">flush_db</span>():</span><br><span class="line">    outDict = []</span><br><span class="line">    ...</span><br><span class="line">    outDict.append(user_dict)</span><br><span class="line">    ...</span><br><span class="line">    path = Path(<span class="string">f&#x27;./db/actorDB.json&#x27;</span>)</span><br><span class="line">    <span class="keyword">with</span> TinyDB(path, access_mode=<span class="string">&quot;r+&quot;</span>, storage=BetterJSONStorage) <span class="keyword">as</span> actorDB:</span><br><span class="line">        actorDB.default_table_name = <span class="string">&#x27;actorTable&#x27;</span></span><br><span class="line">        actorTable = actorDB.table(<span class="string">&#x27;actorTable&#x27;</span>)</span><br><span class="line">        query = Query()</span><br><span class="line">        <span class="keyword">for</span> actor <span class="keyword">in</span> outDict:</span><br><span class="line">            logger.info(<span class="string">&#x27;actor:::::::::::&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(actor))</span><br><span class="line">            actorTable.upsert(actor, query.name == actor.name<span class="string">&#x27;])</span></span><br><span class="line"><span class="string">        logger.info(&#x27;</span>DB total: &#123;&#125;<span class="string">&#x27;.format(actorDB))</span></span><br><span class="line"><span class="string">        actorDB.close()</span></span><br></pre></td></tr></table></figure>

<p>Here is a footnote reference,[^1] and another.[^longnote]</p>
<h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>[^1]: Here is the footnote.<br>[^longnote]: Here’s one with multiple blocks.</p>
]]></content>
      <tags>
        <tag>爬虫</tag>
        <tag>scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>批处理</title>
    <url>/2024/07/06/%E6%89%B9%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><h3 id="无限循环，定时，固定时间间隔"><a href="#无限循环，定时，固定时间间隔" class="headerlink" title="无限循环，定时，固定时间间隔"></a>无限循环，定时，固定时间间隔</h3><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line">:<span class="built_in">start</span></span><br><span class="line"><span class="built_in">echo</span> jajaja</span><br><span class="line">choice /t <span class="number">5</span> /d y /n &gt;nul</span><br><span class="line"></span><br><span class="line">goto <span class="built_in">start</span></span><br></pre></td></tr></table></figure>

<h2 id="搜索目录"><a href="#搜索目录" class="headerlink" title="搜索目录"></a>搜索目录</h2><figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">::搜索当前目录下的文件</span><br><span class="line"><span class="keyword">for</span> %%i <span class="keyword">in</span> (*.*) <span class="keyword">do</span> <span class="built_in">echo</span> <span class="string">&quot;%%i&quot;</span></span><br><span class="line">:: 或者</span><br><span class="line"><span class="keyword">for</span> /<span class="built_in">r</span> <span class="string">&quot;目录路径&quot;</span> %%a <span class="keyword">in</span> (匹配规则，例如*.txt) <span class="keyword">do</span> 执行操作</span><br><span class="line">pause</span><br></pre></td></tr></table></figure>

<h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><blockquote>
<p>reference</p>
</blockquote>
<p><a href="https://blog.csdn.net/m0_56208280/article/details/129074215">Windows 批处理(bat) for循环语句使用教程</a></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> %%a <span class="keyword">in</span> (ele1 ele2 ele3) <span class="keyword">do</span> (</span><br><span class="line">	<span class="built_in">echo</span> %%a</span><br><span class="line">)</span><br><span class="line"><span class="keyword">for</span> %%a <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">do</span> (</span><br><span class="line">	<span class="built_in">echo</span> %%a</span><br><span class="line">)</span><br><span class="line">pause</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /d %%i <span class="keyword">in</span> (./docs/) <span class="keyword">do</span> (<span class="built_in">echo</span> %%i)</span><br><span class="line"></span><br><span class="line">:: <span class="keyword">for</span> /l %%i  <span class="keyword">in</span> (<span class="built_in">start</span>,step,<span class="keyword">end</span>) <span class="keyword">do</span> command</span><br><span class="line"><span class="keyword">for</span> /l %%i <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">3</span>,<span class="number">20</span>) <span class="keyword">do</span> (<span class="built_in">echo</span> %%i)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> /f %%i <span class="keyword">in</span> (.\test.txt) <span class="keyword">do</span> (<span class="built_in">echo</span> %%i)</span><br><span class="line"></span><br><span class="line">:: delims这个参数，=后面有一个空格，意思是再将每一个元素以空格分割，默认是只取分割以后的第一个元素。</span><br><span class="line"><span class="keyword">for</span> /f <span class="string">&quot;delims= &quot;</span> %%i <span class="keyword">in</span> (.\test.txt) <span class="keyword">do</span> <span class="built_in">echo</span> %%i</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="If-命令-有三种格式"><a href="#If-命令-有三种格式" class="headerlink" title="If 命令 有三种格式:"></a>If 命令 有三种格式:</h2><h3 id="1-if-“参数”-“字符串”-待执行的命令"><a href="#1-if-“参数”-“字符串”-待执行的命令" class="headerlink" title="1. if “参数” &#x3D;&#x3D; “字符串” 　待执行的命令"></a>1. if “参数” &#x3D;&#x3D; “字符串” 　待执行的命令</h3><p>参数如果等于指定的字符串，则条件成立，运行命令，否则运行下一句。(注意是两个等号）如</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="string">&quot;%1&quot;</span>==<span class="string">&quot;a&quot;</span> format a:</span><br><span class="line"><span class="keyword">if</span> &#123; %<span class="number">1</span> &#125;==&#123; &#125; goto noparms</span><br><span class="line"><span class="keyword">if</span> &#123; %<span class="number">2</span> &#125;==&#123; &#125; goto noparms</span><br></pre></td></tr></table></figure>

<h3 id="2-if-exist-文件名-待执行的命令"><a href="#2-if-exist-文件名-待执行的命令" class="headerlink" title="2. if exist 文件名　 待执行的命令"></a>2. if exist 文件名　 待执行的命令</h3><p>如果有指定的文件，则条件成立，运行命令，否则运行下一句 如</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> exist config.sys edit config.sys</span><br></pre></td></tr></table></figure>

<h3 id="3-if-errorlevel-if-not-errorlevel-数字-待执行的命令"><a href="#3-if-errorlevel-if-not-errorlevel-数字-待执行的命令" class="headerlink" title="3. if errorlevel &#x2F; if not errorlevel 数字　 待执行的命令"></a>3. if errorlevel &#x2F; if not errorlevel 数字　 待执行的命令</h3><p>如果返回码等于指定的数字，则条件成立，运行命令，否则运行下一句。<br>如</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> errorlevel <span class="number">2</span> goto x2 　</span><br></pre></td></tr></table></figure>

<p>DOS 程序运行时都会返回一个数字给 DOS，称为错误码 errorlevel 或称返回码，常见的返回码为 0、1。</p>
<h2 id="注释方式"><a href="#注释方式" class="headerlink" title="注释方式"></a>注释方式</h2><p>1、:: 注释内容（第一个冒号后也可以跟任何一个非字母数字的字符）<br>2、rem 注释内容（不能出现重定向符号和管道符号）<br>3、echo 注释内容（不能出现重定向符号和管道符号）〉nul<br>4、if not exist nul 注释内容（不能出现重定向符号和管道符号）<br>5、:注释内容（注释文本不能与已有标签重名）<br>6、%注释内容%（可以用作行间注释，不能出现重定向符号和管道符号）<br>7、goto 标签 注释内容（可以用作说明 goto 的条件和执行内容）<br>8、:标签 注释内容（可以用作标签下方段的执行内容）</p>
<p>@echo off 表示执行了这条命令后关闭所有命令(包括本身这条命令)的回显。<br>而 echo off 命令则表示关闭其他所有命令(不包括本身这条命令)的回显，<br>@的作用就是关闭紧跟其后的一条命令的回显，</p>
<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2><h3 id="1-判断字符串相等。"><a href="#1-判断字符串相等。" class="headerlink" title="1. 判断字符串相等。"></a>1. 判断字符串相等。</h3><p>示例如下：新建一个文本文件，命名为 ifstring，修改文件类型为 bat，：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> <span class="string">&quot;var=this is an apple&quot;</span></span><br><span class="line">rem 比较%var%是否等于apple,如果相等,返回OK,否则返回NO.</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="string">&quot;%var%&quot;</span>==<span class="string">&quot;apple&quot;</span> (<span class="built_in">echo</span> OK) <span class="keyword">else</span> <span class="built_in">echo</span> NO</span><br><span class="line"></span><br><span class="line">pause&gt;nul</span><br></pre></td></tr></table></figure>

<p>注意：if 判断字符串相等时候，后面用的是“&#x3D;&#x3D;”，而不是“&#x3D;”。</p>
<h3 id="2-判断数值相等。"><a href="#2-判断数值相等。" class="headerlink" title="2. 判断数值相等。"></a>2. 判断数值相等。</h3><p>示例如下：新建一个文本文件，命名为 ifnumber，修改文件类型为 bat，：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> /a num1=<span class="number">100</span></span><br><span class="line"><span class="built_in">set</span> /a num2=<span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> %num1% gtr %num2% <span class="built_in">echo</span> %num1%大于%num2%</span><br><span class="line"><span class="keyword">if</span> %num1% EQU %num2% <span class="built_in">echo</span> %num1%等于%num2%</span><br><span class="line"><span class="keyword">if</span> %num1% LSS %num2% <span class="built_in">echo</span> %num1%小于%num2%</span><br><span class="line"></span><br><span class="line">pause&gt;nul</span><br></pre></td></tr></table></figure>

<p>注意：比较运算符分为以下几种：</p>
<p>EQU - 等于<br>　　 NEQ - 不等于<br>　　 LSS - 小于<br>　　 LEQ - 小于或等于<br>　　 GTR - 大于<br>　　 GEQ - 大于或等于</p>
<h3 id="3-结合-errorlevel-使用"><a href="#3-结合-errorlevel-使用" class="headerlink" title="3. 结合 errorlevel 使用"></a>3. 结合 errorlevel 使用</h3><p>示例如下：新建一个文本文件，命名为 iferrorlevel，修改文件类型为 bat，：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">ECHO</span> off</span><br><span class="line"></span><br><span class="line">XCOPY F:\studybat\if\iferrorlevel.bat D:\</span><br><span class="line"><span class="keyword">IF</span> ERRORLEVEL <span class="number">1</span> <span class="built_in">ECHO</span> 文件拷贝失败</span><br><span class="line"><span class="keyword">IF</span> ERRORLEVEL <span class="number">0</span> <span class="built_in">ECHO</span> 成功拷贝文件</span><br><span class="line"></span><br><span class="line">pause&gt;nul</span><br></pre></td></tr></table></figure>

<p>注意：环境变量 errorlevel 的初始值为 0，当一些命令执行不成功，就会返回一个数值，如：1 ，2 等</p>
<h3 id="4-判断变量定义与否。"><a href="#4-判断变量定义与否。" class="headerlink" title="4. 判断变量定义与否。"></a>4. 判断变量定义与否。</h3><p>示例如下：新建一个文本文件，命名为 ifdefined，修改文件类型为 bat，：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line"><span class="built_in">set</span> <span class="string">&quot;str1=ok&quot;</span></span><br><span class="line"><span class="built_in">set</span> <span class="string">&quot;str2=no&quot;</span></span><br><span class="line"><span class="keyword">if</span> defined str1 <span class="built_in">echo</span> str1已经被定义</span><br><span class="line"><span class="keyword">if</span> defined str2 <span class="built_in">echo</span> str2已经被定义</span><br><span class="line"><span class="keyword">if</span> defined str3 (<span class="built_in">echo</span> str3已经被定义) <span class="keyword">else</span> <span class="built_in">echo</span> str3 没有被定义</span><br><span class="line"></span><br><span class="line">pause&gt;nul</span><br></pre></td></tr></table></figure>

<p>Here is a footnote reference,[^1] and another.[^longnote]</p>
<h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>[^1]: Here is the footnote.<br>[^longnote]: Here’s one with multiple blocks.</p>
]]></content>
      <tags>
        <tag>windows</tag>
        <tag>批处理</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2024/07/07/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="basic"><a href="#basic" class="headerlink" title="basic"></a>basic</h2><figure class="highlight re"><table><tr><td class="code"><pre><span class="line">/a.c/ -&gt; aac、abc、acc、adc</span><br><span class="line">/a*b/ -&gt; <span class="string">&quot;b&quot;</span>、<span class="string">&quot;ab&quot;</span>、<span class="string">&quot;aab&quot;</span>、<span class="string">&quot;aaab&quot;</span> </span><br><span class="line">/a+b/ -&gt; <span class="string">&quot;ab&quot;</span>、<span class="string">&quot;aab&quot;</span>、<span class="string">&quot;aaab&quot;</span> </span><br><span class="line">/colou?r/ -&gt; <span class="string">&quot;color&quot;</span> 或 <span class="string">&quot;colour&quot;</span></span><br><span class="line"></span><br><span class="line">用户名由若干个字母、数字、下划线和中划线组成，所以需要用到<span class="operator"> + </span>表示 <span class="number">1</span> 次或多次出现</span><br><span class="line">[a-zA-<span class="type">Z0</span>-<span class="number">9_</span>-]+</span><br><span class="line"></span><br><span class="line">匹配 iframe 标签</span><br><span class="line">/&lt;iframe(([\s\<span class="type">S</span>])*?)&lt;\/iframe&gt;/</span><br><span class="line"></span><br><span class="line">匹配所有 img 标签</span><br><span class="line">/&lt;img.*?src=<span class="string">&quot;(.*?)&quot;</span>.*?\/?&gt;/gi</span><br><span class="line"></span><br><span class="line">中括号表达式 匹配字符组的一个列表</span><br><span class="line">/<span class="type">Chapter</span> [<span class="number">1</span>-<span class="number">5</span>]/</span><br><span class="line">/<span class="type">Chapter</span> [<span class="number">12345</span>]/ -&gt; <span class="type">Chapter</span> <span class="number">1</span>、<span class="type">Chapter</span> <span class="number">2</span>、<span class="type">Chapter</span> <span class="number">3</span>、<span class="type">Chapter</span> <span class="number">4</span> 和 <span class="type">Chapter</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">[!--]</span><br><span class="line">[!-~]</span><br><span class="line">/<span class="type">Chapter</span> [^<span class="number">1</span>-<span class="number">5</span>]/</span><br><span class="line">/[<span class="type">A</span>-<span class="type">Za</span>-z0-<span class="number">9</span>]/</span><br><span class="line"></span><br><span class="line">/^(<span class="type">Chapter</span>|<span class="type">Section</span>) [<span class="number">1</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;$/</span><br><span class="line"></span><br><span class="line">\b	匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b<span class="string">&quot;可以匹配&quot;</span>never<span class="string">&quot;中的&quot;</span>er<span class="string">&quot;，但不能匹配&quot;</span>verb<span class="string">&quot;中的&quot;</span>er<span class="string">&quot;。</span></span><br><span class="line"><span class="string">\B	匹配非单词边界。“er\B&quot;</span>能匹配<span class="string">&quot;verb&quot;</span>中的<span class="string">&quot;er&quot;</span>，但不能匹配<span class="string">&quot;never&quot;</span>中的<span class="string">&quot;er&quot;</span>。</span><br><span class="line"></span><br><span class="line">\n	匹配一个换行符。等价于\x0a和\cJ。</span><br><span class="line">\r	匹配一个回车符。等价于\x0d和\cM。</span><br><span class="line"></span><br><span class="line">\s	匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \f\n\r\t\v]。</span><br><span class="line">\<span class="type">S</span>	匹配任何非空白字符。等价于[^ \f\n\r\t\v]</span><br><span class="line"></span><br><span class="line">\w	匹配包括下划线的任何单词字符。等价于“[<span class="type">A</span>-<span class="type">Za</span>-z0-<span class="number">9_</span>]<span class="string">&quot;。</span></span><br><span class="line"><span class="string">\W	匹配任何非单词字符。等价于“[^A-Za-z0-9_]&quot;</span>。</span><br></pre></td></tr></table></figure>

<h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><blockquote>
<p>reference</p>
</blockquote>
<p><a href="https://stackoverflow.org.cn/regexsucha/">regexsucha</a><br><a href="https://stackoverflow.org.cn/regex/">在线测试reg</a></p>
<figure class="highlight re"><table><tr><td class="code"><pre><span class="line">汉字(字符)	[\u4e00-\u9fa5]</span><br><span class="line">匹配双字节字符(包括汉字在内)	[^\x00-\xff]</span><br><span class="line">空白行	\n\s*\r  </span><br><span class="line">        \n\n(editplus) </span><br><span class="line">        ^[\s\<span class="type">S</span> ]*\n</span><br><span class="line">用户名	/^[a-z0-<span class="number">9_</span>-]&#123;<span class="number">3</span>,<span class="number">16</span>&#125;$/</span><br><span class="line">密码	/^[a-z0-<span class="number">9_</span>-]&#123;<span class="number">6</span>,<span class="number">18</span>&#125;$/</span><br><span class="line">密码<span class="number">2</span>	(?=^.&#123;<span class="number">8</span>,&#125;$)(?=.*\d)(?=.*\<span class="type">W</span>+)(?=.*[<span class="type">A</span>-<span class="type">Z</span>])(?=.*[a-z])(?!.*\n).*$ (由数字/大写字母/小写字母/标点符号组成，四种都必有，<span class="number">8</span>位以上)</span><br><span class="line"><span class="type">URL</span>	/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;<span class="number">2</span>,<span class="number">6</span>&#125;)([\/\w \.-]*)*\/?$/ 或 [a-zA-z]+:<span class="comment">//[^\s]*</span></span><br><span class="line"><span class="type">IP</span> 地址	/((<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]\d|<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|[<span class="number">01</span>]?\d\d?)\.)&#123;<span class="number">3</span>&#125;(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]\d|<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|[<span class="number">01</span>]?\d\d?)/</span><br><span class="line">/^(?:(?:<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>][<span class="number">0</span>-<span class="number">9</span>]|[<span class="number">01</span>]?[<span class="number">0</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]?)\.)&#123;<span class="number">3</span>&#125;(?:<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>][<span class="number">0</span>-<span class="number">9</span>]|[<span class="number">01</span>]?[<span class="number">0</span>-<span class="number">9</span>][<span class="number">0</span>-<span class="number">9</span>]?)$/ 或 ((<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]\d|<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|[<span class="number">01</span>]?\d\d?)\.)&#123;<span class="number">3</span>&#125;(<span class="number">2</span>[<span class="number">0</span>-<span class="number">4</span>]\d|<span class="number">25</span>[<span class="number">0</span>-<span class="number">5</span>]|[<span class="number">01</span>]?\d\d?)</span><br></pre></td></tr></table></figure>
<h2 id="pattern"><a href="#pattern" class="headerlink" title="(pattern)"></a>(pattern)</h2><blockquote>
<p>匹配pattern并获取这一匹配。所获取的匹配可以</p>
</blockquote>
<ul>
<li>从产生的Matches集合得到，</li>
<li>在VBScript中使用SubMatches集合，</li>
<li>在JScript中则使用$0…$9属性。</li>
</ul>
<blockquote>
<p>要匹配圆括号字符，请使用“(“或”)“。</p>
</blockquote>
<h2 id="正向反向匹配"><a href="#正向反向匹配" class="headerlink" title="正向反向匹配"></a>正向反向匹配</h2><blockquote>
<p>Windows ：Windows 3.1、Windows 95 、Windows 98 和 Windows NT </p>
</blockquote>
<h3 id="pattern-1"><a href="#pattern-1" class="headerlink" title="(?:pattern)"></a>(?:pattern)</h3><blockquote>
<p>匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。<br>例如”industr(?:y|ies)”就是一个比”industry|industries”更简略的表达式。</p>
</blockquote>
<figure class="highlight re"><table><tr><td class="code"><pre><span class="line"><span class="type">Windows</span> (?:<span class="number">95</span> |<span class="number">98</span> |<span class="type">NT</span> ) -&gt; <span class="type">Windows</span> <span class="number">95</span> <span class="type">Windows</span> <span class="number">98</span> <span class="type">Windows</span> <span class="type">NT</span> </span><br></pre></td></tr></table></figure>

<h3 id="pattern-2"><a href="#pattern-2" class="headerlink" title="(?&#x3D;pattern)"></a>(?&#x3D;pattern)</h3><blockquote>
<p>正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。<br>例如，“Windows(?&#x3D;95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。<br>预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</p>
</blockquote>
<blockquote>
<p>Windows (?&#x3D;95 |98 |NT ) -&gt; <strong>Windows</strong> 95 <strong>Windows</strong> 98 <strong>Windows</strong> NT </p>
</blockquote>
<h3 id="pattern-3"><a href="#pattern-3" class="headerlink" title="(?!pattern)"></a>(?!pattern)</h3><blockquote>
<p>正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。<br>例如“Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。<br>预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</p>
</blockquote>
<blockquote>
<p>Windows (?!95 |98 |NT ) -&gt; <strong>Windows</strong> ：<strong>Windows</strong> 3.1</p>
</blockquote>
<h3 id=""><a href="#" class="headerlink" title="(?&lt;&#x3D;pattern)"></a>(?&lt;&#x3D;pattern)</h3><blockquote>
<p>反向肯定预查，与正向肯定预查类拟，只是方向相反。<br>例如，“(?&lt;&#x3D;95|98|NT|2000)Windows”能匹配”2000Windows”中的”Windows”，但不能匹配”3.1Windows”中的”Windows”。</p>
</blockquote>
<h3 id="-1"><a href="#-1" class="headerlink" title="(?&lt;!pattern)"></a>(?&lt;!pattern)</h3><blockquote>
<p>反向否定预查，与正向否定预查类拟，只是方向相反。<br>例如“(?&lt;!95|98|NT|2000)Windows”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows”。</p>
</blockquote>
<p>Here is a footnote reference,[^1] and another.[^longnote]</p>
<h2 id="vim-相关"><a href="#vim-相关" class="headerlink" title="vim 相关"></a>vim 相关</h2><blockquote>
<p>reference</p>
</blockquote>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/346058975">神级编辑器 Vim 使用-正则替换篇</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/670012180">Vim使用技巧</a></li>
</ul>
<blockquote>
<p>Examples</p>
</blockquote>
<h3 id="vim-每-5行-合并为一行"><a href="#vim-每-5行-合并为一行" class="headerlink" title="vim 每 5行 合并为一行"></a>vim 每 5行 合并为一行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nomarl 模式</span><br><span class="line"></span><br><span class="line">输入 qa 进入录制模式</span><br><span class="line"></span><br><span class="line">按5次 J 合并 5行</span><br><span class="line"></span><br><span class="line">按j 跳下一行 </span><br><span class="line"></span><br><span class="line">输入 q 退出录制模式</span><br><span class="line"></span><br><span class="line">输入 3000@a 表示 重复执行3000次录制操作</span><br></pre></td></tr></table></figure>

<h3 id="vim-匹配-数字数字-并前后插入换行符"><a href="#vim-匹配-数字数字-并前后插入换行符" class="headerlink" title="vim 匹配 #### 数字数字. 并前后插入换行符"></a>vim 匹配 <code>####</code> 数字数字. 并前后插入换行符</h3><p><a href="https://zhuanlan.zhihu.com/p/346058975">&amp; 表示使用匹配串</a></p>
<p><code>:%s/#### \d\d. /\r\r&amp;\r\r\/</code></p>
<h3 id="vim-每10行插入-3行空行"><a href="#vim-每10行插入-3行空行" class="headerlink" title="vim 每10行插入 3行空行"></a>vim 每10行插入 3行空行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">normal 模式下 yy辅助一行空行</span><br><span class="line"></span><br><span class="line">输入 qa 进入录制模式</span><br><span class="line"></span><br><span class="line">按10次 j 跳过10行</span><br><span class="line"></span><br><span class="line">按3次 P 插入拷贝空行</span><br><span class="line"></span><br><span class="line">输入q 退出录制模式</span><br><span class="line"></span><br><span class="line">输入 150@a 表示重复执行 150次录制操作</span><br></pre></td></tr></table></figure>

<h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>[^1]: Here is the footnote.<br>[^longnote]: Here’s one with multiple blocks.</p>
]]></content>
      <tags>
        <tag>正则表达式</tag>
        <tag>vim</tag>
        <tag>re</tag>
      </tags>
  </entry>
  <entry>
    <title>油猴脚本</title>
    <url>/2024/06/20/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="斗鱼开播提醒"><a href="#斗鱼开播提醒" class="headerlink" title="斗鱼开播提醒"></a>斗鱼开播提醒</h1><h2 id="🌎使用方法"><a href="#🌎使用方法" class="headerlink" title="🌎使用方法"></a>🌎使用方法</h2><ul>
<li>打开<a href="https://www.douyu.com/directory/myFollow"><code>斗鱼关注页面</code></a>(<a href="https://www.douyu.com/directory/myFollow">https://www.douyu.com/directory/myFollow</a>)</li>
<li>并放置在后台 有主播开播&#x2F;更改标题时自动发送通知提醒</li>
</ul>
<h2 id="💼Plus功能"><a href="#💼Plus功能" class="headerlink" title="💼Plus功能"></a>💼Plus功能</h2><ul>
<li><input checked="" disabled="" type="checkbox"> 下播提醒</li>
<li><input checked="" disabled="" type="checkbox"> 每次提醒重新刷新 <code>关注页面</code></li>
<li><input checked="" disabled="" type="checkbox"> 最近10条历史通知 弹窗查看</li>
<li><input checked="" disabled="" type="checkbox"> 彩虹旋转边框环绕带牌子直播间<br>  <img src="https://zirpon.github.io/2024/06/20/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/PixPin_2024-09-03_20-11-26.gif" alt="彩虹旋转边框"></li>
<li><input checked="" disabled="" type="checkbox"> <code>视频轮播</code> 单元格窗口 置灰 （鼠标移至视频轮播单元格仍然可以预览视频轮播内容）<br>  <img src="https://zirpon.github.io/2024/06/20/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/PixPin_2024-09-03_20-29-31.gif" alt="置灰视频轮播"></li>
<li><input checked="" disabled="" type="checkbox"> 粤语&#x2F;国语 语音播报 <code>改标题/下播/开播</code> 提醒<br>  <img src="https://image-static.segmentfault.com/995/584/9955847-62a9b4b214bea_fix732" alt="语音列表"></li>
</ul>
<h2 id="🚀版本更新"><a href="#🚀版本更新" class="headerlink" title="🚀版本更新"></a>🚀版本更新</h2><blockquote>
<p>3.4.10</p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 关闭历史通知 不再弹窗提示刷新网页 </li>
<li><input checked="" disabled="" type="checkbox"> 把 <strong><code>我的关注</code></strong> 里 <em><strong><code>视频轮播</code></strong></em> 的单元格置灰</li>
<li><input checked="" disabled="" type="checkbox"> 增加主页&#x2F;更新按钮</li>
<li><input checked="" disabled="" type="checkbox"> 开播下播历史通知逆时排序 先看最近的</li>
<li><input checked="" disabled="" type="checkbox"> 只保留最近10条历史通知</li>
</ul>
<blockquote>
<p>3.3.6</p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 关闭系统通知时 用页面常驻弹窗通知</li>
</ul>
<blockquote>
<p>3.3.5</p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 3.3.5 油猴脚本工程化项目 版本更新</li>
</ul>
<blockquote>
<p>3.3.4</p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 增加通知提醒开关按钮</li>
</ul>
<blockquote>
<p>3.3.3</p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 增加语音播报开关按钮</li>
</ul>
<blockquote>
<p>3.3.2</p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 关闭设置界面不再刷新 关注页面 而是语音播报设置修改内</li>
</ul>
<blockquote>
<p>3.2</p>
</blockquote>
<ul>
<li><input checked="" disabled="" type="checkbox"> 增加设置界面 方便用户使用</li>
</ul>
<h2 id="🙏致谢"><a href="#🙏致谢" class="headerlink" title="🙏致谢"></a>🙏致谢</h2><blockquote>
<p>此 <a href="https://greasyfork.org/zh-CN/scripts/498616-douyu%E6%96%97%E9%B1%BC-%E4%B8%BB%E6%92%AD%E5%BC%80%E6%92%AD%E4%B8%8B%E6%92%AD%E6%8F%90%E9%86%92-%E7%B2%A4%E8%AF%AD-%E5%9B%BD%E8%AF%AD%E8%AF%AD%E9%9F%B3%E6%92%AD%E6%8A%A5%E9%80%9A%E7%9F%A5">Script</a> 继承了 @P- 的 <a href="https://greasyfork.org/zh-CN/scripts/378317-douyu-%E6%96%97%E9%B1%BC%E5%BC%80%E6%92%AD%E6%8F%90%E9%86%92">原脚本</a> 在此感谢 <a href="https://greasyfork.org/zh-CN/users/250428-p">@P-</a> 的开发工作。</p>
</blockquote>
<h2 id="🐊源码"><a href="#🐊源码" class="headerlink" title="🐊源码"></a>🐊源码</h2><p><a href="https://raw.githubusercontent.com/Zirpon/zirpon.github.io/master/source/src/douyu_followpage.js">源码</a></p>
<figure class="highlight js"><figcaption><span>油猴脚本</span><a href="https://raw.githubusercontent.com/Zirpon/zirpon.github.io/master/source/src/douyu_followpage.js">douyu_followpage源码</a></figcaption><table><tr><td class="code"><pre><span class="line marked"><span class="keyword">function</span> <span class="title function_">speak</span>(<span class="params"></span></span><br><span class="line"><span class="params">    &#123; text, speechRate, lang, volume, pitch &#125;,</span></span><br><span class="line"><span class="params">    endEvent,</span></span><br><span class="line marked"><span class="params">    startEvent</span></span><br><span class="line marked"><span class="params"></span>) &#123;</span><br><span class="line marked">    <span class="keyword">if</span> (!<span class="variable language_">window</span>.<span class="property">SpeechSynthesisUtterance</span>) &#123;</span><br><span class="line marked">        <span class="variable language_">console</span>.<span class="title function_">warn</span>(<span class="string">&quot;当前浏览器不支持文字转语音服务&quot;</span>);</span><br><span class="line marked">        <span class="keyword">return</span>;</span><br><span class="line marked">    &#125;</span><br><span class="line marked"></span><br><span class="line marked">    <span class="keyword">if</span> (!text) &#123;</span><br><span class="line marked">        <span class="keyword">return</span>;</span><br><span class="line marked">    &#125;</span><br><span class="line marked">    <span class="keyword">let</span> onoff = <span class="title function_">GM_getValue</span>(<span class="string">&quot;switchVoice&quot;</span>, <span class="literal">true</span>);</span><br><span class="line marked">    <span class="keyword">if</span> (onoff != <span class="literal">true</span>) &#123;</span><br><span class="line marked">        <span class="keyword">return</span>;</span><br><span class="line marked">    &#125;</span><br><span class="line marked"></span><br><span class="line marked">    <span class="keyword">let</span> setlang = <span class="title function_">GM_getValue</span>(<span class="string">&quot;LANG&quot;</span>, <span class="string">&quot;zh-CN&quot;</span>);</span><br><span class="line marked">    <span class="keyword">let</span> setrate = <span class="title function_">GM_getValue</span>(<span class="string">&quot;RATE&quot;</span>, <span class="number">1</span>);</span><br><span class="line marked">    <span class="keyword">const</span> speechUtterance = <span class="keyword">new</span> <span class="title class_">SpeechSynthesisUtterance</span>();</span><br><span class="line marked">    speechUtterance.<span class="property">text</span> = text;</span><br><span class="line marked">    speechUtterance.<span class="property">rate</span> = speechRate || setrate;</span><br><span class="line marked">    speechUtterance.<span class="property">lang</span> = lang || setlang;</span><br><span class="line marked">    speechUtterance.<span class="property">volume</span> = volume || <span class="number">1</span>;</span><br><span class="line marked">    speechUtterance.<span class="property">pitch</span> = pitch || <span class="number">1</span>;</span><br><span class="line marked">    speechUtterance.<span class="property">onend</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line marked">        endEvent &amp;&amp; <span class="title function_">endEvent</span>();</span><br><span class="line marked">    &#125;;</span><br><span class="line marked">    speechUtterance.<span class="property">onstart</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line marked">        startEvent &amp;&amp; <span class="title function_">startEvent</span>();</span><br><span class="line marked">    &#125;;</span><br><span class="line marked">    <span class="keyword">var</span> timeFun = <span class="variable language_">window</span>.<span class="built_in">setInterval</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line marked">        <span class="variable language_">window</span>.<span class="built_in">clearInterval</span>(timeFun);</span><br><span class="line marked">        speechSynthesis.<span class="title function_">speak</span>(speechUtterance);</span><br><span class="line marked">    &#125;, <span class="number">500</span>);</span><br><span class="line marked"></span><br><span class="line marked">    <span class="keyword">return</span> speechUtterance;</span><br><span class="line marked">&#125;</span><br></pre></td></tr></table></figure>

<p>Here is a footnote reference,[^1] and another.[^longnote]</p>
<h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>[^1]: Here is the footnote.<br>[^longnote]: Here’s one with multiple blocks.</p>
]]></content>
      <tags>
        <tag>油猴</tag>
        <tag>斗鱼</tag>
        <tag>Tampermonkey</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>油猴脚本学习笔记</title>
    <url>/2024/07/09/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="油猴脚本学习笔记"><a href="#油猴脚本学习笔记" class="headerlink" title="油猴脚本学习笔记"></a>油猴脚本学习笔记</h1><h2 id="基础资料"><a href="#基础资料" class="headerlink" title="基础资料"></a>基础资料</h2><p><a href="https://bbs.tampermonkey.net.cn/forum.php?mod=viewthread&tid=1909" title="website title">Tampermonkey中文文档</a><br><a href="https://semver.org/lang/zh-CN/">世界通用版本号规则</a><br><a href="https://bbs.tampermonkey.net.cn/forum.php?mod=viewthread&tid=271">Tampermonkey菜单</a><br><a href="https://iknow.fun/2022/08/03/vscode-webpack-typescript-you-hou-kai-fa-huan-jing-da-jian-ben-di-diao-shi-shi-shi-re-shua-xin-zi-dong-gou-jian-he-fa-bu/" title="油猴脚本开发进阶】VSCode + Webpack + TypeScript 油猴开发环境搭建，本地调试、实时热刷新、自动构建和发布">油猴脚本开发进阶 VSCode + Webpack + TypeScript 油猴开发环境搭建，本地调试、实时热刷新、自动构建和发布</a><br><a href="https://iknow.fun/2022/08/01/webpack-typescript-kai-fa-you-hou-jiao-ben-dou-yu-zhi-bo-zi-dong-qie-huan-hua-zhi-2-0/">Webpack 配置的改进</a><br><a href="https://blog.csdn.net/weixin_45047039/article/details/110262176" title="webpack使用html-loader加载js中引入的html资源">webpack使用html-loader加载js中引入的html资源</a></p>
<h2 id="油猴webpack脚手架框架介绍"><a href="#油猴webpack脚手架框架介绍" class="headerlink" title="油猴webpack脚手架框架介绍"></a><a href="https://iknow.fun/2022/08/03/vscode-webpack-typescript-you-hou-kai-fa-huan-jing-da-jian-ben-di-diao-shi-shi-shi-re-shua-xin-zi-dong-gou-jian-he-fa-bu/" title="油猴脚本开发进阶】VSCode + Webpack + TypeScript 油猴开发环境搭建，本地调试、实时热刷新、自动构建和发布">油猴webpack脚手架</a>框架介绍</h2><h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><p><img src="/../img/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/QQ_1720489834153.png"></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">│</span><br><span class="line">│─package.json</span><br><span class="line">│   (- yarn start/dev/build 自定义命令 </span><br><span class="line">│       建议参照 yarn build 自定义增加编译 douyu.dev.user.js 的命令 如: yarn builddev </span><br><span class="line">│        注意：自定义参数不能有空格</span><br><span class="line">│   - 项目名字 版本 描述 作者 主页 开源协议 依赖 脚本</span><br><span class="line">│   )</span><br><span class="line">├─config</span><br><span class="line">│      common.meta.json</span><br><span class="line">│        (生产环境油猴脚本banner元数据 json文件)</span><br><span class="line">│      dev.meta.json</span><br><span class="line">│        (调试环境油猴脚本banner元数据 json文件 &quot;require&quot;键对应的修改为本地文件 douyu.dev.user.js 的路径) </span><br><span class="line">│      webpack.config.base.js</span><br><span class="line">│        (webpack项目基础配置)   </span><br><span class="line">│      webpack.dev.js</span><br><span class="line">│        (webpack项目开发环境 生成目标文件的配置)</span><br><span class="line">│      webpack.prod.js</span><br><span class="line">│        (webpack项目生产环境 生成目标文件的配置)</span><br><span class="line">│</span><br><span class="line">├─dist</span><br><span class="line">│      douyu.user.js</span><br><span class="line">│        (yarn build 生成的脚本 生产环境脚本)</span><br><span class="line">│      douyu.dev.user.js</span><br><span class="line">│        (yarn start 跟 yarn dev 生成的脚本 开发环境脚本)</span><br><span class="line">│</span><br><span class="line">├─public</span><br><span class="line">│      index.html</span><br><span class="line">│        (本地调试目标页面 执行 yarn start 启动页面)</span><br><span class="line">│</span><br><span class="line">└─src</span><br><span class="line">    │  app.ts</span><br><span class="line">    │    (油猴脚本源码入口)</span><br><span class="line">    │  devTools.ts</span><br><span class="line">    │   (框架调试工具接口)</span><br><span class="line">    │  global.d.ts</span><br><span class="line">    │  index.ts</span><br><span class="line">    │   (项目入口文件)</span><br><span class="line">    ├─lib</span><br><span class="line">    │      ajax.ts</span><br><span class="line">    │      message.ts</span><br><span class="line">    └─mock</span><br><span class="line">            douyu.less</span><br><span class="line">            douyuPlayer.ts</span><br><span class="line">            (本地调试目标页面 ts部分)</span><br></pre></td></tr></table></figure>

<h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><ul>
<li><p>yarn install 安装依赖</p>
</li>
<li><p>执行 yarn start 或者 yarn dev 或者 (自定义的)yarn builddev 目的是编译生成 douyu.dev.user.js</p>
</li>
<li><p>如果运行 yarn start<br>  项目 <code>devTools.ts</code> 的函数 <code>autoInstall</code> 文件会 弹出油猴脚本安装网页提示安装脚本 安装脚本成功后<br>  修改 脚本内容 就是你磁盘文件 <code>douyu.dev.user.js</code> 的路径<br>  <code>// @require    file://D://xxxxx//dist//douyu.dev.user.js</code></p>
</li>
<li><p>如果你没安装脚本 则手动 打开油猴脚本控制面板 新建空白脚本 然后 把 生成的 <code>douyu.dev.user.js</code> 的 <code>banner</code> 拷贝到油猴面板空白脚本当中<br>  特别注意 不要拷贝整个文件内容 只需要拷贝 <code>banner</code> 部分 如下格式 不然 下次再次运行 <code>yarn start</code> 的时候 会疯狂刷新调试页面</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==UserScript== </span></span><br><span class="line">··· </span><br><span class="line"><span class="comment">// ==/UserScript==</span></span><br></pre></td></tr></table></figure></li>
<li><p>修改 <code>config/dev.meta.json</code> 文件 require键对应的本地文件 douyu.dev.user.js 的路径</p>
</li>
<li><p>至此 项目基本运行调试是没问题了 接下来就是修改 项目信息</p>
</li>
<li><p>具体需要编辑的 文件 就是 <code>common.meta.json</code> <code>dev.meta.json</code> <code>package.json</code></p>
</li>
</ul>
<h3 id="编码注意事项"><a href="#编码注意事项" class="headerlink" title="编码注意事项"></a>编码注意事项</h3><ul>
<li>index.js 是项目入口<ul>
<li>项目调试页面代码 在于 <code>mock</code> 文件夹的的源文件 可随意修改定制</li>
<li>项目油猴 入口在于 <code>app.ts</code> </li>
<li><code>index.ts</code> 是通过 <code>import app</code> <code>app()</code> 进入油猴源码入口的</li>
<li>所以一切的逻辑代码 都必须编辑在 <code>app.ts</code> 的 <code>const app = () =&gt; &#123;&#125;;</code> 中</li>
<li>比如 <code>GM_registerMenuCommand(&#39;test&#39;, () =&gt; console.log(&#39;test&#39;));</code><br>  <code>GM_registerMenuCommand</code> 只能在 <code>const app = () =&gt; &#123;&#125;;</code> 中解析调用<br>  否则 无法识别 <code>GM_registerMenuCommand</code> 函数</li>
</ul>
</li>
<li>菜单栏 少量HTML标签元素 导入<ul>
<li>依赖 <code>core-js</code> <code>html-loader</code>  <figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">npm install <span class="literal">--safe-dev</span> core<span class="literal">-js</span></span><br><span class="line">npm install <span class="literal">--safe-dev</span> html<span class="literal">-loader</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">yarn add core<span class="literal">-js</span> <span class="literal">--dev</span></span><br><span class="line">yarn add html<span class="literal">-loader</span> <span class="literal">--dev</span></span><br></pre></td></tr></table></figure></li>
<li>配置文件 <code>webpack.config.base.js</code></li>
</ul>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.html$/i</span>,</span><br><span class="line">      <span class="attr">use</span>: &#123;</span><br><span class="line">      <span class="attr">loader</span>: <span class="string">&#x27;html-loader&#x27;</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">sources</span>: &#123;</span><br><span class="line">          <span class="attr">list</span>: [</span><br><span class="line">              <span class="string">&#x27;...&#x27;</span>, <span class="comment">// 所有默认支持的标签和属性，这个一定要加上，不然就只会检测a标签了</span></span><br><span class="line">              &#123;</span><br><span class="line">              <span class="attr">tag</span>: <span class="string">&#x27;a&#x27;</span>,</span><br><span class="line">              <span class="attr">attribute</span>: <span class="string">&#x27;href&#x27;</span>,</span><br><span class="line">              <span class="attr">tags</span>: <span class="string">&#x27;src&#x27;</span>,</span><br><span class="line">              &#125;,</span><br><span class="line">          ],</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="attr">minimize</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">  &#125;,]&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>逻辑代码</li>
</ul>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 其中 import 出来的 menu 是字符串</span></span><br><span class="line"><span class="keyword">import</span> menu <span class="keyword">from</span> <span class="string">&#x27;./menu.html&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> menuWrapper = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;menuWrapper&#x27;</span>);</span><br><span class="line">menuWrapper.<span class="property">innerHTML</span> = menu;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Here is a footnote reference,[^1] and another.[^longnote]</p>
<h3 id="调试编译打包指令"><a href="#调试编译打包指令" class="headerlink" title="调试编译打包指令"></a>调试编译打包指令</h3><ul>
<li><code>package.json</code> 可自行定义</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack serve --config ./config/webpack.dev.js --env filename=douyu.dev.user.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;webpack --watch --config ./config/webpack.dev.js --env filename=douyu.dev.user.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn lint:fix &amp;&amp; webpack --config ./config/webpack.prod.js --env filename=douyu.user.js --stats-error-details&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;builddev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn lint:fix &amp;&amp; webpack --config ./config/webpack.dev.js --env filename=douyu.dev.user.js --stats-error-details&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lint&quot;</span><span class="punctuation">:</span> <span class="string">&quot;eslint \&quot;src/**/*.&#123;ts,tsx&#125;\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lint:fix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn lint --fix&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>


<h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>[^1]: Here is the footnote.<br>[^longnote]: Here’s one with multiple blocks.</p>
]]></content>
      <tags>
        <tag>油猴</tag>
        <tag>Tampermonkey</tag>
        <tag>JavaScript</tag>
        <tag>webpack</tag>
        <tag>脚手架</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>算法笔记</title>
    <url>/2024/07/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="算法笔记"><a href="#算法笔记" class="headerlink" title="算法笔记"></a>算法笔记</h1><h2 id="游戏排名算法"><a href="#游戏排名算法" class="headerlink" title="游戏排名算法"></a>游戏排名算法</h2><ul>
<li><a href="https://itindex.net/detail/61665-%E6%B8%B8%E6%88%8F%E6%8E%92%E5%90%8D-%E7%AE%97%E6%B3%95-elo" title="游戏排名算法：Elo、Glicko、TrueSkill">Elo</a></li>
</ul>
<p>Here is a footnote reference,[^1] and another.[^longnote]</p>
<h2 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h2><ul>
<li><p><a href="https://itindex.net/detail/9511-bfprt-%E7%AE%97%E6%B3%95">bfprt</a></p>
</li>
<li><p><a href="https://itindex.net/detail/11732-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">贪心算法</a></p>
</li>
<li><p><a href="https://itindex.net/detail/46419-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">排序算法</a></p>
</li>
<li><p><a href="https://visualgo.net/zh">算法可视化网站</a></p>
</li>
<li><p><a href="https://xie.infoq.cn/article/a6612973e6e6a80134f166eba">算法可视化网站s</a></p>
</li>
<li><p>KMP算法</p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV18k4y1m7Ar/?spm_id_from=333.337.search-card.all.click&vd_source=b48342a630f5cc1a5c86649a37c0db89">bilibili搬运】油管阿三哥讲KMP查找算法，中英文字幕，人工翻译，简单易懂</a></p>
</li>
<li><p><a href="https://github.com/mission-peace/interview/blob/master/src/com/interview/string/SubstringSearch.java">https://github.com/mission-peace/interview/blob/master/src/com/interview/string/SubstringSearch.java</a></p>
</li>
<li><p><a href="https://www.bilibili.com/video/BV1AY4y157yL/?share_source=copy_web&vd_source=8481a329c330537a5873f8525ac82207">最浅显易懂的 KMP 算法讲解</a></p>
</li>
</ul>
<h2 id="实用算法"><a href="#实用算法" class="headerlink" title="实用算法"></a>实用算法</h2><ul>
<li><a href="https://itindex.net/detail/7746-%E7%BC%93%E5%AD%98-%E7%AE%97%E6%B3%95">缓存算法</a></li>
<li><a href="https://feihu.me/blog/2014/sgi-std-sort/">知无涯之std::sort源码剖析</a></li>
<li><a href="https://dirtysalt.github.io/html/programming-pearls.html">编程珠玑(The Programming Pearls)</a></li>
</ul>
<h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>[^1]: Here is the footnote.<br>[^longnote]: Here’s one with multiple blocks.</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>剪映</title>
    <url>/2023/01/11/%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h1 id="剪映"><a href="#剪映" class="headerlink" title="剪映"></a>剪映</h1><ol>
<li>片尾预计时间 </li>
<li>转场过渡的使用 会影响片尾的插入时间 先调试好视频前面的各种<strong>转场特效</strong> <strong>拼接</strong> 最后再处理 片尾 </li>
<li>片尾跟视频 声音 可以一起处理 都是留在最后 处理</li>
<li>跳舞视频 蒙太奇剪辑 关键动作 减速 没必要动作加速 或者保持原速</li>
<li>蒙太奇剪辑后 对原视频的 音频处理 剪掉 或者恢复 或者 etc.</li>
<li>特效的使用 学习一下 什么场景 使用什么特效 最优效果</li>
<li>剪辑过程中就可以选封面</li>
</ol>
]]></content>
      <tags>
        <tag>剪辑</tag>
        <tag>视频</tag>
      </tags>
  </entry>
  <entry>
    <title>世界文字系统学习：英文 日文 阿拉伯文</title>
    <url>/2024/07/06/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%8B%B1%E8%AF%AD/</url>
    <content><![CDATA[<h1 id="世界文字系统学习：英文-日文-阿拉伯文"><a href="#世界文字系统学习：英文-日文-阿拉伯文" class="headerlink" title="世界文字系统学习：英文 日文 阿拉伯文"></a>世界文字系统学习：英文 日文 阿拉伯文</h1><h2 id="英文名"><a href="#英文名" class="headerlink" title="英文名"></a>英文名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cheung zipung</span><br><span class="line">cheung zepung</span><br><span class="line">cheung zeepung</span><br><span class="line">cheung zeapung</span><br><span class="line">cheung zeapung</span><br><span class="line">チャン ゼプン</span><br><span class="line">تشيونغ زيبونغ</span><br></pre></td></tr></table></figure>

<h2 id="英语e的发音："><a href="#英语e的发音：" class="headerlink" title="英语e的发音："></a>英语e的发音：</h2><h3 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h3><ul>
<li><input disabled="" type="checkbox"> <a href="https://zhidao.baidu.com/question/505929543901517964.html">e 的发音 1</a></li>
<li><input disabled="" type="checkbox"> <a href="https://m.hujiang.com/en/p1352385/#:~:text=e%E5%9C%A8%E8%8B%B1%E8%AF%AD%E5%8D%95%E8%AF%8D%E4%B8%AD%E6%9C%89%E5%87%A0%E7%A7%8D%E5%8F%91%E9%9F%B3%20%E4%B9%9D%E7%A7%8D%EF%BC%8C%E5%88%86%E5%88%AB%E4%B8%BA%E2%88%B6%E5%9C%A8%E5%BC%80%E9%9F%B3%E8%8A%82%E4%B8%AD%EF%BC%8C%E5%8F%91%E5%AD%97%E6%AF%8D%E9%9F%B3%EF%BC%8C%E8%AF%BB%E4%BD%9C%E2%88%B6%E3%80%90%E2%88%B6%E3%80%91%3B%E5%9C%A8%E9%97%AD%E9%9F%B3%E8%8A%82%E4%B8%AD%EF%BC%8C%E8%AF%BB%E4%BD%9C%E2%88%B6%20%E3%80%90e%E3%80%91%3B%E5%9C%A8ea%E7%BB%84%E5%90%88%E7%9A%84%E4%B8%AD%EF%BC%8C%E8%AF%BB%E4%BD%9C%E2%88%B6,%E3%80%90i%E3%80%91%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%AF%BB%E4%BD%9C%E2%88%B6%20%E3%80%90e%E3%80%91%E6%88%96%E8%80%85%E3%80%90i%E3%80%91%3B%E5%9C%A8ear%E7%BB%84%E5%90%88%EF%BC%8C%E8%AF%BB%E4%BD%9C%E2%88%B6%20%E3%80%90i%E2%91%A7%E3%80%91%E7%AD%89%E3%80%82" title="泸江英语：e在英语单词中有几种发音">e 的发音 2</a></li>
</ul>
<h3 id="发音有6种，列举如下"><a href="#发音有6种，列举如下" class="headerlink" title="发音有6种，列举如下"></a>发音有6种，列举如下</h3><ol>
<li><p>在重读开音节中，e一般读做&#x2F;i:&#x2F;。单词举例：she、these。&#x2F;</p>
</li>
<li><p>在重读闭音节中，e一般读&#x2F;e&#x2F;。单词举例：set、bed。</p>
</li>
<li><p>在单字母非重读音节中，e一般读做&#x2F;i:&#x2F;或&#x2F;ə&#x2F;。在重读音节前的非重读音节里，e一般读做&#x2F;i&#x2F;, 但不完全是这样。单词举例：eleven、excuse。</p>
</li>
<li><p>在单字母非重读音节中，e一般读做&#x2F;i:&#x2F;或&#x2F;&#x2F;。在重读音节之后的非重读音节里，e一般读做&#x2F;&#x2F;，但不完全是这样。单词举例：enemy、student。</p>
</li>
<li><p>在单字母非重读音节中，e一般读&#x2F;i:&#x2F;或&#x2F;ə&#x2F;。词缀结尾发&#x2F;i&#x2F;或&#x2F;ə&#x2F;，例：business、 kindness。</p>
</li>
<li><p>相对开音节最后一个e不发音，单词举例：bike，nice。</p>
</li>
</ol>
<h2 id="音节与音节划分知识"><a href="#音节与音节划分知识" class="headerlink" title="音节与音节划分知识"></a>音节与音节划分知识</h2><h3 id="1-音节"><a href="#1-音节" class="headerlink" title="1. 音节"></a>1. 音节</h3><p>以元音为主体构成的发音单位，一般说来元音发音响亮，可以构成音节，辅音发音不响亮，不能单独构成音节([m] [n] [ ] [l]例外)。<br>从单词拼写形式上看，有几个元音字母就有几个音节。</p>
<h3 id="2-音节的划分"><a href="#2-音节的划分" class="headerlink" title="2. 音节的划分"></a>2. 音节的划分</h3><ul>
<li>在重读音节和非重读音节的相邻处有两个辅音字母时，一个辅音字母组属于前面的音节，一个属于后面的音节。</li>
</ul>
<p>例如：let-ter，mem-ber，chil-dren，daugh-ter</p>
<ul>
<li>在重读和非重读音节的相邻处只有一个辅音字母时，如果前面重读音节里的元音是长音则辅字组属于后面一个音节，如果重读音节里的元音是短音，则辅音字母属于重读音节。</li>
</ul>
<p>例如：长音 pa-per，stu-dent，fa-ther，ze-ro，mo-tor，far-ther</p>
<p>短音 sev-en，stud-y，moth-er，ver-y，mod-le ，weath-er</p>
<h3 id="3-重读音节"><a href="#3-重读音节" class="headerlink" title="3. 重读音节"></a>3. 重读音节</h3><p>单词中读音特别响亮的音节。用音标标记双音节、多音节词的读音时，应使用重读符号。单音节词多数是重读音节，标记读音时不需要使用重读符号。</p>
<h3 id="4-开音节"><a href="#4-开音节" class="headerlink" title="4. 开音节"></a>4. 开音节</h3><ul>
<li>绝对开音节：单个元音字母后面没有辅音字母的重读音节。</li>
</ul>
<p>例如：no，blue，ba-by，stu-dent，se-cret</p>
<ul>
<li>相对开音节：单个元音字母后面加单个辅音字母，再加一个不发音字母e构成的重读音节。</li>
</ul>
<p>例如：name，these，bike，home，excuse</p>
<h3 id="5-闭音节"><a href="#5-闭音节" class="headerlink" title="5. 闭音节"></a>5. 闭音节</h3><p>单个元音字母后面有辅音字母(r、w、y 除外)且以辅音字母结尾的重读音节。</p>
<p>例如：bag，egg，fish，not，cup</p>
<h3 id="6-双音节词重读规则"><a href="#6-双音节词重读规则" class="headerlink" title="6. 双音节词重读规则"></a>6. 双音节词重读规则</h3><ul>
<li>双音节词的第一个音节通常是重读音节。</li>
</ul>
<p>例如：stu-dent，Chi-na，sec-ond，au-tumn</p>
<ul>
<li>含有a- be- de- re- in- ex- 等前缀的双音节词往往是在第二个音节上重读。双音节词的重读位置不会因增加前缀或后缀而发生改变。</li>
</ul>
<p>例如：a-bout，be-fore，ex-cuse，re-pair，for-get-ful，in-ven-tor</p>
<h3 id="7-多音节词重读规则"><a href="#7-多音节词重读规则" class="headerlink" title="7. 多音节词重读规则"></a>7. 多音节词重读规则</h3><p>多音节词通常在倒数第三个音节重读。</p>
<p>例如：el-e-phant</p>
<p>词尾有-ic 或-tion,-sion 的词，在-ic或-sion,-tion前的一个音节上重读。</p>
<p>例如：scien-tific，im-pression，na-tion</p>
<h2 id="世界文字分类"><a href="#世界文字分类" class="headerlink" title="世界文字分类"></a>世界文字分类</h2><h3 id="reference-1"><a href="#reference-1" class="headerlink" title="reference"></a>reference</h3><ul>
<li><a href="https://neography.info/writing-systems/#:~:text=Writing%20Systems%201%201.%20Segmental%20Segmental%20writing%20systems,building%20blocks.%20Syllabary%20...%203%203.%20Segmental-Syllabic%20" title="书写系统">write_sys</a></li>
<li><a href="http://languagesindanger.eu/book-of-knowledge/writing/">writing</a></li>
<li><a href="https://www.worldswritingsystems.org/">世界文字系统官网</a></li>
<li><a href="https://space.bilibili.com/1931761492/video">世界文字B站up主空间</a></li>
</ul>
<p><img src="https://pic1.zhimg.com/7ae2af104a6e315229ee88527a72c8cd_r.jpg" alt="世界文字分类"><br><img src="https://p1.ssl.qhmsg.com/t01eb6714f6b8e761dd.jpg" alt="中文版"><br><img src="/../img/%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%EF%BC%9A%E8%8B%B1%E8%AF%AD/OIP-C.jpg" alt="dd"><br><img src="https://www.ielts-adviser.com/wp-content/uploads/2015/07/main-systems-of-writing.png" alt="dd2"><br><img src="https://iibawards-prod.s3.amazonaws.com/projects/images/000/002/704/large.png" alt="dd3"><br><img src="https://www.applelanguages.com/blog/wp-content/uploads/2019/04/blog-post-writing-system.png" alt="dd"></p>
<blockquote>
<p>全世界的文字都可以分为五大类&#x2F;</p>
</blockquote>
<h3 id="1-表意文字Morphographic"><a href="#1-表意文字Morphographic" class="headerlink" title="1. 表意文字Morphographic"></a>1. 表意文字Morphographic</h3><p>文字字符不直接表示文字读音</p>
<p>例：埃及象形文字、中国汉字</p>
<h3 id="2-表音文字Phonographic"><a href="#2-表音文字Phonographic" class="headerlink" title="2. 表音文字Phonographic"></a>2. 表音文字Phonographic</h3><p>可以从文字得出读音</p>
<h3 id="2-1-表音节Syllabic"><a href="#2-1-表音节Syllabic" class="headerlink" title="2.1 表音节Syllabic"></a>2.1 表音节Syllabic</h3><p>一个单独的字符代表一个音节，不能从音节字符里拆分元音字符和辅音字符</p>
<p>例：日文平、片假名</p>
<h3 id="2-2-表音素Phonemic"><a href="#2-2-表音素Phonemic" class="headerlink" title="2.2 表音素Phonemic"></a>2.2 表音素Phonemic</h3><p>音节可拆分成元音辅音</p>
<h3 id="2-2-1-不写元音Abjad"><a href="#2-2-1-不写元音Abjad" class="headerlink" title="2.2.1 不写元音Abjad"></a>2.2.1 不写元音Abjad</h3><p>不写元音，脑补元音</p>
<p>例：阿拉伯文、希伯来文</p>
<h3 id="2-2-2-写元音"><a href="#2-2-2-写元音" class="headerlink" title="2.2.2 写元音"></a>2.2.2 写元音</h3><h3 id="2-2-2-1-元音字母作为附加符号Abugida"><a href="#2-2-2-1-元音字母作为附加符号Abugida" class="headerlink" title="2.2.2.1 元音字母作为附加符号Abugida"></a>2.2.2.1 元音字母作为附加符号Abugida</h3><p>元音&#x3D;勾勾圈圈点点。在基字上添加符号表示元音（的音节）</p>
<p>例：印度天成体、中国藏文</p>
<h3 id="2-2-2-2-元音作为单独符号Alphabet"><a href="#2-2-2-2-元音作为单独符号Alphabet" class="headerlink" title="2.2.2.2 元音作为单独符号Alphabet"></a>2.2.2.2 元音作为单独符号Alphabet</h3><p>例：希腊字母、拉丁字母、西里尔字母</p>
<blockquote>
<p>总结：</p>
</blockquote>
<ul>
<li>Alphabet（单独元音，单独辅音）</li>
<li>Abgida（附着元音，单独辅音）</li>
<li>Abjad（不写元音，只写辅音）</li>
<li>Syllabic（单独音节，元音辅音合并）</li>
<li>Morphographic（表意）</li>
</ul>
<h2 id="阿拉伯文-字母表"><a href="#阿拉伯文-字母表" class="headerlink" title="阿拉伯文 字母表"></a>阿拉伯文 字母表</h2><p><a href="https://space.bilibili.com/39020403/channel/seriesdetail?sid=3930706">白野老师阿拉伯语教学视频</a><br><img src="https://ts1.cn.mm.bing.net/th/id/R-C.02947271425f5006882a4280f981f680?rik=nmwlkd0ZZsueCA&riu=http://i180.photobucket.com/albums/x47/ayoobzhao/Qr/Arabic20consonants.gif&ehk=/c9OWpS7uB2ocCx8PCwnnH0jlBXypsb4Zq0e6u5r2M0=&risl=&pid=ImgRaw&r=0" alt="dd"><br><img src="https://gss0.baidu.com/-Po3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=b9c2fe85e2fe9925cb596156049872e7/023b5bb5c9ea15ceb5380649b4003af33b87b298.jpg" alt="dd"><br><img src="https://appwk.baidu.com/naapi/doc/view?ih=1010&o=jpg_6_0_______&iw=785&ix=0&iy=0&aimw=785&rn=1&doc_id=bce77edea58da0116c1749c8&pn=1&sign=092f630f22a92d43dc202094b56f0ad5&type=1&app_ver=2.9.8.2&ua=bd_800_800_IncredibleS_2.9.8.2_2.3.7&bid=1&app_ua=IncredibleS&uid=&cuid=&fr=3&Bdi_bear=WIFI&from=3_10000&bduss=&pid=1&screen=800_800&" alt="dd"></p>
<p><a href="https://www.bilibili.com/video/BV1oL411y7qW/?spm_id_from=trigger_reload&vd_source=b48342a630f5cc1a5c86649a37c0db89">奇妙的闪语构词法</a><br><a href="https://www.bilibili.com/video/BV1wN4y1j7TJ/?spm_id_from=333.999.0.0&vd_source=b48342a630f5cc1a5c86649a37c0db89">从汉语的“尖团合流”到各语言中的“腭化”</a></p>
<p>Here is a footnote reference,[^1] and another.[^longnote]</p>
<h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>[^1]: Here is the footnote.<br>[^longnote]: Here’s one with multiple blocks.</p>
]]></content>
      <tags>
        <tag>世界文字</tag>
        <tag>阿拉伯文</tag>
        <tag>日文</tag>
        <tag>象形文字</tag>
        <tag>尖团合流</tag>
        <tag>腭化</tag>
        <tag>元音辅音</tag>
        <tag>表意文字Morphographic</tag>
        <tag>表音文字Phonographic</tag>
        <tag>世界书写系统</tag>
      </tags>
  </entry>
  <entry>
    <title>Lua 5.0 ~ 5.4 学习笔记</title>
    <url>/2019/04/06/lua-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="1-Begin"><a href="#1-Begin" class="headerlink" title="1. Begin"></a>1. Begin</h2><h3 id="1-1-chunk"><a href="#1-1-chunk" class="headerlink" title="1.1 chunk"></a>1.1 chunk</h3><p>Chunk 是一系列语句，Lua 执行的每一<strong>块</strong>语句，比如<strong>一个文件</strong>或者<strong>交互模式</strong>下的<em>每一行</em>都是一个 Chunk。<br>每个语句结尾的分号（;）是可选的，但如果同一行有多个语句最好用；分开(but valid)<br>Chunk可以很大，在 Lua 中几个 MByte 的 Chunk 是很常见的</p>
<p>交互模式下 键入文件结束符可以退出交互模式（Ctrl-D in Unix, Ctrl-Z in DOS&#x2F;Windows），或者调用 OS 库的 os.exit()函数也可以退出</p>
<blockquote>
<p>prompt&gt; lua -la -lb</p>
</blockquote>
<p>命令首先在一个 Chunk 内先运行 a 然后运行 b。（注意：-l 选项会调用 require，将会在指定的目录下搜索文件，如果环境变量没有设好，上面的命令可能不能正确运行。)</p>
<blockquote>
<p>lua -i -la -lb</p>
</blockquote>
<p>将在一个 Chunk 内先运行 a 然后运行 b，最后直接进入交互模式</p>
<p>最好不要使用下划线加大写字母的标示符，因为 Lua 的保留字也是这样的。</p>
<h3 id="1-4-lua-command-line"><a href="#1-4-lua-command-line" class="headerlink" title="1.4 lua command line"></a>1.4 lua command line</h3><ul>
<li><p>-e：直接将命令传入 Lua</p>
<blockquote>
<p>prompt&gt; lua -e “print(math.sin(12))” –&gt; -0.53657291800043</p>
</blockquote>
</li>
<li><p>-l：加载一个文件.</p>
</li>
<li><p>-i：进入交互模式.<br>  _PROMPT 内置变量作为交互模式的提示符</p>
<blockquote>
<p>prompt&gt; lua -i -e “_PROMPT&#x3D;’ lua&gt; ‘“<br>lua&gt;</p>
</blockquote>
</li>
</ul>
<p>Lua 的运行过程，在运行参数之前，Lua 会查找环境变量 <code>LUA_INIT</code> 的值，</p>
<ul>
<li>如果变量存在并且<code>值</code>为<code>@filename</code>，Lua 将<strong>加载</strong>指定文件。</li>
<li>如果变量存在但<code>不是以@开头</code>，Lua假定 filename 为 Lua 代码文件并且<strong>运行</strong>他。</li>
</ul>
<p>全局变量 <code>arg</code> 存放 Lua 的命令行参数。在运行以前，Lua 使用所有参数构造 arg 表。</p>
<ul>
<li>脚本名索引为 0，</li>
<li>脚本的参数从 1 开始增加。</li>
<li>脚本前面的参数从-1 开始减少</li>
</ul>
<blockquote>
<p>prompt&gt; lua -e “sin&#x3D;math.sin” script a b<br>arg 表如下：</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">arg</span>[<span class="number">-3</span>] = <span class="string">&quot;lua&quot;</span></span><br><span class="line"><span class="built_in">arg</span>[<span class="number">-2</span>] = <span class="string">&quot;-e&quot;</span></span><br><span class="line"><span class="built_in">arg</span>[<span class="number">-1</span>] = <span class="string">&quot;sin=math.sin&quot;</span></span><br><span class="line"><span class="built_in">arg</span>[<span class="number">0</span>] = <span class="string">&quot;script&quot;</span></span><br><span class="line"><span class="built_in">arg</span>[<span class="number">1</span>] = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="built_in">arg</span>[<span class="number">2</span>] = <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-lua-basic-type"><a href="#2-lua-basic-type" class="headerlink" title="2. lua basic type"></a>2. lua basic type</h2><p>Lua 是动态类型语言，变量不要类型定义。<br>Lua 中有8 个基本类型分别为：<code>nil、boolean、number、string、userdata、function、thread 和 table</code>。<br>函数 <code>type</code> 可以测试给定变量或者值的类型。</p>
<p>在控制结构的条件中除了 <code>false</code> 和 <code>nil</code> 为假，其他值都为真。<br>所以 Lua 认为 <code>0</code> 和<code>空串</code>都是真。</p>
<p><code>number</code>表示实数，Lua 中没有整数。</p>
<p>note: <em><strong>一般有个错误的看法 CPU 运算浮点数比整数慢。事实不是如此，用实数代替整数不会有什么误差（除非数字大于 100,000,000,000,000）。</strong></em><br>Lua的 numbers 可以处理任何长整数不用担心误差。</p>
<p>note: 你也可以在编译 <code>Lua</code> 的时候使用长整型或者<code>单精度浮点型</code>代替 numbers，在一些平台硬件<code>不支持浮点数</code>的情况下这个特性是非常有用的，具体的情况请参考 Lua 发布版所附的详细说明。</p>
<h3 id="2-4-string"><a href="#2-4-string" class="headerlink" title="2.4 string"></a>2.4 string</h3><p>字符的序列, lua 是 8 位字节，所以字符串可以包含任何数值字符，包括嵌入的 0。<br>这意味着你可以存储任意的二进制数据在一个字符串里。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="string">&quot;one string&quot;</span></span><br><span class="line">b = <span class="built_in">string</span>.<span class="built_in">gsub</span>(a, <span class="string">&quot;one&quot;</span>, <span class="string">&quot;another&quot;</span>) <span class="comment">-- change string parts</span></span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">--&gt; one string</span></span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment">--&gt; another string</span></span><br></pre></td></tr></table></figure>

<p>Lua 可以高效的处理长字符串，<code>1M</code> 的 string 在 Lua 中是很常见的。可以使用<code>单引号</code>或者<code>双引号</code>表示字符串</p>
<p>还可以在字符串中使用\ddd（ddd 为三位十进制数字）方式表示字母。</p>
<blockquote>
<p>“alo\n123&quot;“<br>‘\97lo\10\04923”‘<br>是相同的</p>
</blockquote>
<p>还可以使用<code>[[...]]</code>表示字符串。<br>这种形式的字符串可以包含<code>多行</code>也，可以嵌套且<code>不会解释转义序列</code>，如果<code>第一个字符</code>是<code>换行符</code>会被自动<strong>忽略</strong>掉。</p>
<p>种形式的字符串用来包含一段代码是非常方便的。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">page = <span class="string">[[</span></span><br><span class="line"><span class="string">&lt;HTML&gt;</span></span><br><span class="line"><span class="string">&lt;HEAD&gt;</span></span><br><span class="line"><span class="string">&lt;TITLE&gt;An HTML Page&lt;/TITLE&gt;</span></span><br><span class="line"><span class="string">&lt;/HEAD&gt;</span></span><br><span class="line"><span class="string">&lt;BODY&gt;</span></span><br><span class="line"><span class="string">Lua</span></span><br><span class="line"><span class="string">[[a text between double brackets]]</span></span><br><span class="line"><span class="string">&lt;/BODY&gt;</span></span><br><span class="line"><span class="string">&lt;/HTML&gt;</span></span><br><span class="line"><span class="string">]]</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(page)</span><br></pre></td></tr></table></figure>

<p>运行时，Lua 会自动在 string 和 numbers 之间自动进行类型转换，当一个字符串使<br>用算术操作符时，string 就会被转成数字。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10&quot;</span> + <span class="number">1</span>) <span class="comment">--&gt; 11</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;10 + 1&quot;</span>) <span class="comment">--&gt; 10 + 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;-5.3e - 10&quot;</span> * <span class="string">&quot;2&quot;</span>) <span class="comment">--&gt; -1.06e-09</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span> + <span class="number">1</span>) <span class="comment">-- ERROR (cannot convert &quot;hello&quot;)</span></span><br></pre></td></tr></table></figure>

<p><code>..</code>在 Lua 中是字符串连接符，当在一个<code>数字</code>后面写<code>..</code>时，必须<code>加上空格</code>以防止被解释错</p>
<p>显式将 string 转成数字可以使用函数 <code>tonumber()</code>，如果 string 不是正确的数字该函数将返回 <code>nil</code>。</p>
<p>可以调用<code>tostring()</code>将数字转成字符串，这种转换一直有效</p>
<h3 id="2-5-Function"><a href="#2-5-Function" class="headerlink" title="2.5 Function"></a>2.5 Function</h3><p>函数是<code>第一类值</code>（和其他变量相同），意味着</p>
<ul>
<li>函数可以存储在变量中，</li>
<li>可以作为函数的参数，</li>
<li>也可以作为函数的返回值。</li>
</ul>
<h3 id="2-6-Userdata-and-Threads"><a href="#2-6-Userdata-and-Threads" class="headerlink" title="2.6 Userdata and Threads"></a>2.6 Userdata and Threads</h3><ul>
<li>userdata 可以将 C 数据存放在 Lua 变量中，</li>
<li>userdata 在 Lua 中预定义操作<code>赋值</code>和<code>相等比较</code></li>
</ul>
<h2 id="3-expression-表达式"><a href="#3-expression-表达式" class="headerlink" title="3. expression 表达式"></a>3. expression 表达式</h2><h3 id="3-2-Relational-operators"><a href="#3-2-Relational-operators" class="headerlink" title="3.2 Relational operators"></a>3.2 Relational operators</h3><p>关系运算符</p>
<blockquote>
<p>&lt; &gt; &lt;&#x3D; &gt;&#x3D; &#x3D;&#x3D; ~&#x3D;</p>
</blockquote>
<ul>
<li>Lua 通过<code>引用</code>比较<code>tables、userdata、functions</code>。也就是说当且仅当两者表示同一个对象时相等。</li>
<li>Lua 比较数字按传统的数字大小进行，</li>
<li>比较字符串按字母的顺序进行，但是字母顺序依赖于本地环境</li>
</ul>
<h3 id="3-3-logical-operator-逻辑运算符"><a href="#3-3-logical-operator-逻辑运算符" class="headerlink" title="3.3 logical operator 逻辑运算符"></a>3.3 logical operator 逻辑运算符</h3><blockquote>
<p>and or not</p>
</blockquote>
<p>一个很实用的技巧：如果 x 为 false 或者 nil 则给 x 赋初始值 v</p>
<blockquote>
<p>x &#x3D; x or v</p>
</blockquote>
<p>C 语言中的三元运算符</p>
<blockquote>
<p>(a and b) or c &#x3D;&#x3D;&gt; a ? b : c</p>
</blockquote>
<h3 id="3-5-operator-priority-优先级"><a href="#3-5-operator-priority-优先级" class="headerlink" title="3.5 operator priority 优先级"></a>3.5 operator priority 优先级</h3><p>从高到低的顺序：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">^</span><br><span class="line"><span class="keyword">not</span> - (unary)</span><br><span class="line">* /</span><br><span class="line">+ -</span><br><span class="line">..</span><br><span class="line">&lt; &gt; &lt;= &gt;= ~= ==</span><br><span class="line"><span class="keyword">and</span></span><br><span class="line"><span class="keyword">or</span></span><br></pre></td></tr></table></figure>

<p>除了^和..外所有的二元运算符都是<code>左连接</code>的。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a+i &lt; b/<span class="number">2</span>+<span class="number">1</span> &lt;<span class="comment">--&gt; (a+i) &lt; ((b/2)+1)</span></span><br><span class="line"><span class="number">5</span>+x^<span class="number">2</span>*<span class="number">8</span> &lt;<span class="comment">--&gt; 5+((x^2)*8)</span></span><br><span class="line">a &lt; y <span class="keyword">and</span> y &lt;= z &lt;<span class="comment">--&gt; (a &lt; y) and (y &lt;= z)</span></span><br><span class="line">-x^<span class="number">2</span> &lt;<span class="comment">--&gt; -(x^2)</span></span><br><span class="line">x^y^z &lt;<span class="comment">--&gt; x^(y^z)</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-table-constructor-表的构造"><a href="#3-6-table-constructor-表的构造" class="headerlink" title="3.6 table constructor 表的构造"></a>3.6 table constructor 表的构造</h3><p>最简单的构造函数是<code>&#123;&#125;</code>，用来创建一个<code>空表</code>。</p>
<p>使用 table 构造一个 list：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">list = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line"> list = &#123;<span class="built_in">next</span>=list, value=line&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>嵌套构造函数</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">polyline = &#123;color=<span class="string">&quot;blue&quot;</span>, thickness=<span class="number">2</span>, npoints=<span class="number">4</span>,</span><br><span class="line"> &#123;x=<span class="number">0</span>, y=<span class="number">0</span>&#125;,</span><br><span class="line"> &#123;x=<span class="number">-10</span>, y=<span class="number">0</span>&#125;,</span><br><span class="line"> &#123;x=<span class="number">-10</span>, y=<span class="number">1</span>&#125;,</span><br><span class="line"> &#123;x=<span class="number">0</span>, y=<span class="number">1</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能使用负索引初始化一个表中元素，</li>
<li>字符串索引也不能被恰当的表示。</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">opnames = &#123;</span><br><span class="line">    [<span class="string">&quot;+&quot;</span>] = <span class="string">&quot;add&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;-&quot;</span>] = <span class="string">&quot;sub&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;*&quot;</span>] = <span class="string">&quot;mul&quot;</span>,</span><br><span class="line">    [<span class="string">&quot;/&quot;</span>] = <span class="string">&quot;div&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">i = <span class="number">20</span>; s = <span class="string">&quot;-&quot;</span></span><br><span class="line">a = &#123;[i+<span class="number">0</span>] = s, [i+<span class="number">1</span>] = s..s, [i+<span class="number">2</span>] = s..s..s,&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(opnames[s]) <span class="comment">--&gt; sub</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">22</span>]) <span class="comment">--&gt; ---</span></span><br></pre></td></tr></table></figure>

<ul>
<li>注意：不推荐数组下标<code>从 0 开始</code>，否则<code>很多标准库不能使用</code>。</li>
<li>在构造函数的<code>最后的</code>“,”是可选的，可以方便以后的扩展。</li>
<li>在构造函数中域分隔符逗号（”,”）可以用分号（”;”）替代，通常我们使用分号用来分割不同类型的表元素。</li>
</ul>
<p>如果真的想要数组下标从 0 开始：</p>
<blockquote>
<p>days &#x3D; {[0]&#x3D;”Sunday”, “Monday”, “Tuesday”, “Wednesday”, “Thursday”, “Friday”, “Saturday”}<br>{x&#x3D;10, y&#x3D;45; “one”, “two”, “three”}</p>
</blockquote>
<h3 id="4-basic-syntax-基本语法"><a href="#4-basic-syntax-基本语法" class="headerlink" title="4. basic syntax 基本语法"></a>4. basic syntax 基本语法</h3><blockquote>
<p>a, b &#x3D; 10, 2<em>x &lt;–&gt; a&#x3D;10; b&#x3D;2</em>x</p>
</blockquote>
<p>遇到赋值语句 Lua 会先计算右边所有的值然后再执行赋值操作，所以我们可以这样<br>进行交换变量的值：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">x, y = y, x <span class="comment">-- swap &#x27;x&#x27; for &#x27;y&#x27;</span></span><br><span class="line">a[i], a[j] = a[j], a[i] <span class="comment">-- swap &#x27;a[i]&#x27; for &#x27;a[i]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>当变量个数和值的个数不一致时，Lua 会一直以变量个数为基础采取以下策略：</p>
<ul>
<li>a. 变量个数&gt;值的个数 按变量个数补足 nil</li>
<li>b. 变量个数&lt;值的个数 多余的值会被忽略</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a, b, c = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c) <span class="comment">--&gt; 0 1 nil</span></span><br><span class="line">a, b = a+<span class="number">1</span>, b+<span class="number">1</span>, b+<span class="number">2</span> <span class="comment">-- value of b+2 is ignored</span></span><br><span class="line"><span class="built_in">print</span>(a,b) <span class="comment">--&gt; 1 2</span></span><br><span class="line">a, b, c = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(a,b,c) <span class="comment">--&gt; 0 nil nil</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-local-variable-code-block-局部变量-代码块"><a href="#4-2-local-variable-code-block-局部变量-代码块" class="headerlink" title="4.2  local variable &amp; code block 局部变量 代码块"></a>4.2  local variable &amp; code block 局部变量 代码块</h3><p>使用 <code>local</code> 创建一个局部变量，与全局变量不同，局部变量只在被声明的那个代码块内有效。代码块：指一个<code>控制结构</code>内，一个<code>函数体</code>，或者一个 <code>chunk</code>（变量被声明的那个文件或者文本串）</p>
<p>应该尽可能的使用局部变量，有两个好处：</p>
<ol>
<li>避免命名冲突</li>
<li>访问局部变量的速度比全局变量更快.</li>
</ol>
<blockquote>
<p>do … end</p>
</blockquote>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> conditions <span class="keyword">then</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">elseif</span> conditions <span class="keyword">then</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> condition <span class="keyword">do</span></span><br><span class="line">    statements</span><br><span class="line"><span class="keyword">end</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">repeat</span></span><br><span class="line">    statements;</span><br><span class="line"><span class="keyword">until</span> conditions;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数值 for 循环:</span></span><br><span class="line"><span class="keyword">for</span> var=exp1,exp2,exp3 <span class="keyword">do</span></span><br><span class="line">    loop-part</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 范型 for 循环：</span></span><br><span class="line"><span class="comment">-- print all values of array &#x27;a&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span> <span class="built_in">print</span>(v) <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(t) <span class="keyword">do</span> <span class="built_in">print</span>(k) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-break-return"><a href="#4-3-break-return" class="headerlink" title="4.3 break return"></a>4.3 break return</h3><p>有时候为了调试或者其他目的需要在 block 的中间使用 return 或者 break，可以显式的使用 do..end 来实现：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">--&lt;&lt; SYNTAX ERROR</span></span><br><span class="line">    <span class="comment">-- &#x27;return&#x27; is the last statement in the next block</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">return</span> <span class="keyword">end</span> <span class="comment">-- OK</span></span><br><span class="line">    ... <span class="comment">-- statements not reached</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="5-function"><a href="#5-function" class="headerlink" title="5. function"></a>5. function</h2><p>调用函数的时候，如果参数列表为空，必须使用()表明是函数调用。</p>
<p>当函数<code>只有一个参数</code>并且这个参数是<code>字符串</code>或者<code>表构造</code>的时候，()是可选的：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hello World&quot;</span>     <span class="comment">--&gt; print(&quot;Hello World&quot;)</span></span><br><span class="line"><span class="built_in">dofile</span> <span class="string">&#x27;a.lua&#x27;</span>          <span class="comment">--&gt; dofile (&#x27;a.lua&#x27;)</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">[[a multi-line</span></span><br><span class="line"><span class="string">    message]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">[[a multi-line</span></span><br><span class="line"><span class="string">    message]]</span>)</span><br><span class="line"></span><br><span class="line">f&#123;x=<span class="number">10</span>, y=<span class="number">20</span>&#125;   <span class="comment">--&gt; f(&#123;x=10, y=20&#125;)</span></span><br><span class="line"><span class="built_in">type</span>&#123;&#125;          <span class="comment">--&gt; type(&#123;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 面向对象方式调用函数的语法</span></span><br><span class="line">o:foo(x) <span class="comment">-- &gt; o.foo(o, x)</span></span><br></pre></td></tr></table></figure>

<p>string.find，其返回匹配串<code>“开始和结束的下标”</code>（如果不存在匹配串返回 <code>nil</code>）。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">s, e = <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;hello Lua users&quot;</span>, <span class="string">&quot;Lua&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s, e) <span class="comment">--&gt; 7 9</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-multi-result-return"><a href="#5-1-multi-result-return" class="headerlink" title="5.1 multi result return"></a>5.1 multi result return</h3><p>返回多个结果值</p>
<ul>
<li><p>作为表达式调用函数</p>
<ol>
<li>当调用<code>作为表达式最后一个参数</code>或者<code>仅有一个参数</code>时，根据变量个数函数尽可能多地返回多个值，不足补 nil，超出舍去。</li>
<li>其他情况下，函数调用<code>仅返回第一个值</code>（如果没有返回值为 nil）</li>
</ol>
  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo0</span> <span class="params">()</span></span> <span class="keyword">end</span> <span class="comment">-- returns no results</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo1</span> <span class="params">()</span></span> <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span> <span class="keyword">end</span> <span class="comment">-- returns 1 result</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span> <span class="params">()</span></span> <span class="keyword">return</span> <span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span> <span class="keyword">end</span> <span class="comment">-- returns 2 results</span></span><br><span class="line"></span><br><span class="line">x,y = foo2(), <span class="number">20</span> <span class="comment">-- x=&#x27;a&#x27;, y=20</span></span><br><span class="line">x,y = foo0(), <span class="number">20</span>, <span class="number">30</span> <span class="comment">-- x=&#x27;nil&#x27;, y=20, 30 is discarded</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作为函数参数调用</p>
  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(foo2(), <span class="number">1</span>) <span class="comment">--&gt; a 1</span></span><br><span class="line"><span class="built_in">print</span>(foo2() .. <span class="string">&quot;x&quot;</span>) <span class="comment">--&gt; ax</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在表构造函数 调用</p>
  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;foo0(), foo2(), <span class="number">4</span>&#125; <span class="comment">-- a[1] = nil, a[2] = &#x27;a&#x27;, a[3] = 4</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>return f()这种类型的返回 f()返回的<code>所有值</code></p>
</li>
<li><p>可以使用圆括号强制使调用返回一个值。</p>
  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>((foo0())) <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="built_in">print</span>((foo1())) <span class="comment">--&gt; a</span></span><br><span class="line"><span class="built_in">print</span>((foo2())) <span class="comment">--&gt; a</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>函数多值返回的特殊函数 unpack，接受一个数组作为输入参数，返回数组的所有元素。<br>unpack 被用来实现范型调用机制，在 C 语言中可以使用函数指针调用可变的函数，可以声明参数可变的函数，但不能两者同时可变。</p>
<p>在 Lua 中如果你想调用可变参数的可变函数只需要这样</p>
<blockquote>
<p>f(unpack(a))</p>
</blockquote>
<p>预定义的 unpack 函数是用 C 语言实现的，我们也可以用 Lua 来完成：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unpack</span><span class="params">(t, i)</span></span></span><br><span class="line">    i = i <span class="keyword">or</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> t[i] <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> t[i], <span class="built_in">unpack</span>(t, i + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-variable-parameter-可变参数"><a href="#5-2-variable-parameter-可变参数" class="headerlink" title="5.2 variable parameter 可变参数"></a>5.2 variable parameter 可变参数</h3><p>Lua 函数可以接受可变数目的参数，和 C 语言类似在函数参数列表中使用三点<code>（...）</code>表示函数有可变的参数。<br>Lua 将函数的参数放在一个叫 <code>arg</code> 的表中，除了参数以外，<code>arg表</code>中还有一个<code>域 n</code> 表示参数的个数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">g</span> <span class="params">(a, b, ...)</span></span> <span class="keyword">end</span></span><br><span class="line">CALL PARAMETERS</span><br><span class="line">g(<span class="number">3</span>) a=<span class="number">3</span>, b=<span class="literal">nil</span>, <span class="built_in">arg</span>=&#123;n=<span class="number">0</span>&#125;</span><br><span class="line">g(<span class="number">3</span>, <span class="number">4</span>) a=<span class="number">3</span>, b=<span class="number">4</span>, <span class="built_in">arg</span>=&#123;n=<span class="number">0</span>&#125;</span><br><span class="line">g(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>) a=<span class="number">3</span>, b=<span class="number">4</span>, <span class="built_in">arg</span>=&#123;<span class="number">5</span>, <span class="number">8</span>; n=<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>

<p>如果我们只想要 string.find 返回的第二个值：一个典型的方法是使用虚变量（下划线）</p>
<blockquote>
<p>local _, x &#x3D; string.find(s, p)</p>
</blockquote>
<h3 id="5-3-named-parameter-命名参数"><a href="#5-3-named-parameter-命名参数" class="headerlink" title="5.3 named parameter 命名参数"></a>5.3 named parameter 命名参数</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rename</span> <span class="params">(arg)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">os</span>.<span class="built_in">rename</span>(<span class="built_in">arg</span>.old, <span class="built_in">arg</span>.new)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">rename</span>&#123;old=<span class="string">&quot;temp.lua&quot;</span>, new=<span class="string">&quot;temp1.lua&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="6-function-plus-再论函数"><a href="#6-function-plus-再论函数" class="headerlink" title="6. function plus 再论函数"></a>6. function plus 再论函数</h2><p>note: <em><strong>Lua 中的函数是带有词法定界（lexical scoping）的第一类值（first-class values）。</strong></em></p>
<p>**第一类值(first-class values)**指：<em><strong>在 Lua 中函数和其他值（数值、字符串）一样，函数可以被存放在变量中，也可以存放在表中，可以作为函数的参数，还可以作为函数的返回值。</strong></em></p>
<p>**词法定界(lexical scoping)**指：<em><strong>被嵌套的函数可以访问他外部函数中的变量。这一特性给 Lua 提供了强大的编程能力。</strong></em></p>
<p>Lua 中我们经常这样写：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>这实际上是利用 Lua 提供的“语法上的甜头”（<em><strong>syntactic sugar</strong></em>）的结果，下面是原本的函数：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- why you try like that? because i dont&#x27;t like sugar</span></span><br><span class="line">foo = <span class="function"><span class="keyword">function</span> <span class="params">(x)</span></span> <span class="keyword">return</span> <span class="number">2</span>*x <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 根据学生的成绩从高到低对学生进行排序， 这里的 names, grades 作用域是这个chunk的全局</span></span><br><span class="line">names = &#123;<span class="string">&quot;Peter&quot;</span>, <span class="string">&quot;Paul&quot;</span>, <span class="string">&quot;Mary&quot;</span>&#125;</span><br><span class="line">grades = &#123;Mary = <span class="number">10</span>, Paul = <span class="number">7</span>, Peter = <span class="number">8</span>&#125;</span><br><span class="line"><span class="built_in">table</span>.<span class="built_in">sort</span>(names, <span class="function"><span class="keyword">function</span> <span class="params">(n1, n2)</span></span></span><br><span class="line"><span class="keyword">return</span> grades[n1] &gt; grades[n2] <span class="comment">-- compare the grades</span></span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure>

<p>以其他函数作为参数的函数在 Lua 中被称作<code>高级函数</code>，高级函数在 Lua 中并没有特权，只是 Lua 把函数当作<code>第一类函数</code>处理的一个简单的结果。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortbygrade</span> <span class="params">(names, grades)</span></span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">sort</span>(names, <span class="function"><span class="keyword">function</span> <span class="params">(n1, n2)</span></span></span><br><span class="line">        <span class="keyword">return</span> grades[n1] &gt; grades[n2] <span class="comment">-- compare the grades</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>包含在 sortbygrade 函数内部的 sort 中的匿名函数可以访问 sortbygrade 的参数grades，<br>在<code>匿名函数内部</code> grades 不是全局变量也不是局部变量，我们称作<code>外部的局部变量</code>（external local variable）或者 <code>upvalue</code>。</p>
<p>技术上来讲，<code>闭包</code>指值而不是指函数，函数仅仅是闭包的一个<code>原型声明</code>；</p>
<blockquote>
<p>闭包的声明周期?</p>
</blockquote>
<p>简单的说<code>闭包</code> 是 <em><strong>一个函数加上它可以正确访问的 upvalues。</strong></em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Lib = &#123;&#125;</span><br><span class="line">Lib.foo = <span class="function"><span class="keyword">function</span> <span class="params">(x,y)</span></span> <span class="keyword">return</span> x + y <span class="keyword">end</span></span><br><span class="line">Lib.goo = <span class="function"><span class="keyword">function</span> <span class="params">(x,y)</span></span> <span class="keyword">return</span> x - y <span class="keyword">end</span></span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">Lib = &#123;</span><br><span class="line">    foo = <span class="function"><span class="keyword">function</span> <span class="params">(x,y)</span></span> <span class="keyword">return</span> x + y <span class="keyword">end</span>,</span><br><span class="line">    goo = <span class="function"><span class="keyword">function</span> <span class="params">(x,y)</span></span> <span class="keyword">return</span> x - y <span class="keyword">end</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">Lib = &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lib.foo</span> <span class="params">(x,y)</span></span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Lib.goo</span> <span class="params">(x,y)</span></span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>Lua 把 <code>chunk</code> 当作<code>函数</code>处理，在 chunk 内可以声明<code>局部函数</code>（<em><strong>仅仅在 chunk 内可见</strong></em>），词法定界保证了包内的<code>其他函数</code><strong>可以调用</strong>此函数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- error usage</span></span><br><span class="line"><span class="keyword">local</span> fact = <span class="function"><span class="keyword">function</span> <span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n*fact(n<span class="number">-1</span>) <span class="comment">-- buggy</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>上面这种方式导致 Lua 编译时遇到 fact(n-1)并<em>不知道他是局部函数</em> <code>fact</code>，Lua 会去查找是否有这样的<em>全局函数</em> <code>fact</code>。<br>为了解决这个问题我们必须在<em>定义函数以前</em> 先<strong>声明</strong>:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> fact</span><br><span class="line">fact = <span class="function"><span class="keyword">function</span> <span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> n*fact(n<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>note:<em>但是 Lua 扩展了他的语法使得可以在直接递归函数定义时使用两种方式都可以。</em><br>note:<em>在定义<code>非</code>直接递归局部函数时要<strong>先声明</strong>然后定义才可以</em></p>
<h3 id="6-3-proper-tail-calls-尾调用"><a href="#6-3-proper-tail-calls-尾调用" class="headerlink" title="6.3 proper tail calls 尾调用"></a>6.3 proper tail calls 尾调用</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="keyword">return</span> g(x)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p><em>这种情况下当被调用函数 g 结束时程序<strong>不需要返回</strong>到<code>调用者 f</code>；</em><br><em>所以<strong>尾调用之后</strong>程序不需要在栈中保留关于*<em>调用者的任何信息</em></em>。*<br><em>一些编译器比如 <strong>Lua 解释器</strong>利用这种特性在处理尾调用时<strong>不使用额外的栈</strong>，我们称这种语言*<em>支持</em></em><code>正确的尾调用</code>。*</p>
<p>note:<em>由于尾调用不需要使用栈空间，那么尾调用<strong>递归的层次</strong>可以无限制的。例如下面调用不论 n 为何值*<em>不会导致栈溢出</em></em>。*</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span> <span class="keyword">then</span> <span class="keyword">return</span> foo(n - <span class="number">1</span>) <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 非尾调用</span></span><br><span class="line"><span class="keyword">return</span> g(x) + <span class="number">1</span> <span class="comment">-- must do the addition</span></span><br><span class="line"><span class="keyword">return</span> x <span class="keyword">or</span> g(x) <span class="comment">-- must adjust to 1 result</span></span><br><span class="line"><span class="keyword">return</span> (g(x)) <span class="comment">-- must adjust to 1 result</span></span><br></pre></td></tr></table></figure>

<p>可以将尾调用理解成一种 goto，在<strong>状态机的编程</strong>领域尾调用是非常有用的。<br>状态机的应用要求函数记住每一个状态，改变状态只需要 goto(or call)一个特定的函数。</p>
<p>传统模式的编译器对于尾调用的处理方式就像处理其他普通函数调用一样，总会在调用时创建一个新的栈帧（stack frame）并将其推入调用栈顶部，用于表示该次函数调用。</p>
<p>当一个函数调用发生时，计算机必须 “记住” 调用函数的位置 —— 返回位置，才可以在调用结束时带着返回值回到该位置，返回位置一般存在调用栈上。在尾调用这种特殊情形中，计算机理论上可以<em>不需要记住尾调用的位置</em>而<em>从被调用的函数直接<strong>带着返回值</strong>返回调用函数的返回位置</em>（相当于直接连续返回两次）。<br>尾调用消除即是在不改变当前调用栈（也不添加新的返回位置）的情况下跳到新函数的一种优化（完全不改变调用栈是不可能的，还是需要校正调用栈上形式参数与局部变量的信息。）</p>
<p>由于当前函数帧上包含局部变量等等大部分的东西都不需要了，当前的<em>函数帧经过适当的更动</em>以后可以<em>直接当作被尾调用的函数的帧使用</em>，然后程序即可以跳到被尾调用的函数。产生这种函数帧更动代码与 “jump”（而不是一般常规函数调用的代码）的过程称作<strong>尾调用消除(Tail Call Elimination)<strong>或</strong>尾调用优化(Tail Call Optimization, TCO)</strong>。尾调用优化让位于尾位置的函数调用跟 goto 语句性能一样高，也因此使得高效的结构编程成为现实。</p>
<p>然而，对于 <strong>C++</strong> 等语言来说，在函数最后 return g(x); 并不一定是尾递归——在返回之前很可能涉及到<strong>对象的析构函数</strong>，使得 g(x) 不是最后执行的那个。这可以通过返回值优化来解决。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(data1, data2)</span></span></span><br><span class="line">   a(data1)</span><br><span class="line">   <span class="keyword">return</span> b(data2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">汇编代码:</span><br><span class="line">```asm</span><br><span class="line">foo:</span><br><span class="line">  mov  reg,[sp+data1] ; 透过栈指针（sp）取得 data1 并放到暂用暂存器。</span><br><span class="line">  push reg            ; 将 data1 放到栈上以便 a 使用。</span><br><span class="line">  call a              ; a 使用 data1。</span><br><span class="line">  pop                 ; 把 data1 從栈上拿掉。</span><br><span class="line">  mov  reg,[sp+data2] ; 透过栈指針（sp）取得 data2 並放到暂用暂存器。</span><br><span class="line">  push reg            ; 将 data2 放到栈上以便 b 使用。</span><br><span class="line">  call b              ; b 使用 data2。</span><br><span class="line">  pop                 ; 把 data2 從栈上拿掉。</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure>

<p>优化后汇编代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">foo:</span><br><span class="line">  mov  reg,[sp+data1] ; 透过栈指针（sp）取得 data1 并放到暂用暂存器。</span><br><span class="line">  push reg            ; 将 data1 放到栈上以便 a 使用。</span><br><span class="line">  call a              ; a 使用 data1。</span><br><span class="line">  pop                 ; 把 data1 從栈上拿掉。</span><br><span class="line">  mov  reg,[sp+data2] ; 透过栈指針（sp）取得 data2 並放到暂用暂存器。  </span><br><span class="line">  mov  [sp+data1],reg ; 把 data2 放到 b 预期的位置。</span><br><span class="line">  jmp  b              ; b 使用 data2 並返回到调用 foo 的函数。</span><br></pre></td></tr></table></figure>

<h2 id="7-iterator-genericity-for-迭代器-泛型for"><a href="#7-iterator-genericity-for-迭代器-泛型for" class="headerlink" title="7. iterator &amp; genericity for 迭代器 泛型for"></a>7. iterator &amp; genericity for 迭代器 泛型for</h2><p>创建一个<code>闭包</code>必须要创建其外部局部变量。<br>所以一个典型的闭包的结构包含两个函数：一个是<code>闭包</code>自己；另一个是工厂（<code>创建闭包的函数</code>）。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list_iter</span> <span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">local</span> n = #t</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt;= n <span class="keyword">then</span> <span class="keyword">return</span> t[i] <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- usage:</span></span><br><span class="line">t = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line">iter = list_iter(t) <span class="comment">-- creates the iterator</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> element = iter() <span class="comment">-- calls the iterator</span></span><br><span class="line">    <span class="keyword">if</span> element == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 泛型 for</span></span><br><span class="line">t = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> list_iter(t) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(element)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>note:<em>这个例子中 list_iter 是一个工厂，每次调用他都会创建一个新的闭包（迭代器本身）</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allwords</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> line = <span class="built_in">io</span>.<span class="built_in">read</span>() <span class="comment">-- current line</span></span><br><span class="line">    <span class="keyword">local</span> pos = <span class="number">1</span> <span class="comment">-- current position in the line</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> <span class="comment">-- iterator function</span></span><br><span class="line">        <span class="keyword">while</span> line <span class="keyword">do</span> <span class="comment">-- repeat while there are lines</span></span><br><span class="line">            <span class="keyword">local</span> s, e = <span class="built_in">string</span>.<span class="built_in">find</span>(line, <span class="string">&quot;%w+&quot;</span>, pos)</span><br><span class="line">            <span class="keyword">if</span> s <span class="keyword">then</span> <span class="comment">-- found a word</span></span><br><span class="line">                pos = e + <span class="number">1</span> <span class="comment">-- next position is after this word</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">string</span>.<span class="built_in">sub</span>(line, s, e) <span class="comment">-- return the word</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                line = <span class="built_in">io</span>.<span class="built_in">read</span>() <span class="comment">-- word not found; try next line</span></span><br><span class="line">                pos = <span class="number">1</span> <span class="comment">-- restart from first position</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">-- no more lines: end of traversal</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- usage:</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> allwords() <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(word)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-genericity-for-泛型-for-的语义"><a href="#7-2-genericity-for-泛型-for-的语义" class="headerlink" title="7.2 genericity for 泛型 for 的语义"></a>7.2 genericity for 泛型 for 的语义</h3><p>一般式:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> var_1, ..., var_n <span class="keyword">in</span> explist <span class="keyword">do</span> block <span class="keyword">end</span></span><br><span class="line"><span class="comment">-- ==&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> _f, _s, _var = explist</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> var_1, ... , var_n = _f(_s, _var)</span><br><span class="line">        _var = var_1</span><br><span class="line">        <span class="keyword">if</span> _var == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        block</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-iterator-without-status-无状态的迭代器"><a href="#7-3-iterator-without-status-无状态的迭代器" class="headerlink" title="7.3 iterator without status 无状态的迭代器"></a>7.3 iterator without status 无状态的迭代器</h3><p>note:<em>迭代的状态包括被遍历的表（循环过程中不会改变的<code>状态常量</code>）和当前的索引下标（<code>控制变量</code>），</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">iter</span> <span class="params">(a, i)</span></span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">local</span> v = a[i]</span><br><span class="line">    <span class="keyword">if</span> v <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">return</span> i, v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ipairs</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">return</span> iter, a, <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>note:<em>当 Lua 调用 ipairs(a)开始循环时，他获取三个值:迭代函数 iter，状态常量 a 和控制变量初始值 0；然后 Lua 调用 iter(a,0)返回 1,a[1]（除非 a[1]&#x3D;nil）；直到<strong>第一个</strong>非 nil 元素</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> n</span><br><span class="line"><span class="comment">-- n = nil 全部</span></span><br><span class="line"><span class="comment">-- n = 1 打印从2 开始</span></span><br><span class="line"><span class="comment">-- n = 0 出错</span></span><br><span class="line">dd=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">next</span>, dd, n <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="7-3-multi-status-iterator-多状态的迭代器"><a href="#7-3-multi-status-iterator-多状态的迭代器" class="headerlink" title="7.3 multi status iterator 多状态的迭代器"></a>7.3 multi status iterator 多状态的迭代器</h3><h2 id="8-compile-run-debug-编译-运行-调试"><a href="#8-compile-run-debug-编译-运行-调试" class="headerlink" title="8. compile run debug 编译 运行 调试"></a>8. compile run debug 编译 运行 调试</h2><p>note: <em>解释型语言的特征不在于他们是否被编译，而是<code>编译器</code>是<code>语言运行时</code>的一部分</em></p>
<p>loadfile:<em>编译代码成中间码并且返回编译后的 chunk 作为一个函数，而不执行代码；</em></p>
<p>note:<em>在发生错误的情况下，loadfile 返回 nil 和错误信息，这样我们就可以自定义错误处理</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">f = <span class="built_in">loadstring</span>(<span class="string">&quot;i = i + 1&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>note:<em>f 将是一个函数，调用时执行 i&#x3D;i+1</em></p>
<p>Lua 把每一个 chunk 都作为一个<code>匿名函数</code>处理。<br>例如：chunk “a &#x3D; 1”，<br><code>loadstring</code> 返回与其等价的 <code>function () a = 1 end</code>与其他函数一样，<br>chunks 可以定义局部变量也可以返回值：<code>f = loadstring(&quot;local a = 10; return a + 20&quot;)</code></p>
<p>note:<em>loadfile 和 loadstring 都不会抛出错误，如果发生错误他们将返回 nil 加上错误信息：</em><br>note:<em>Lua 中的<code>函数定义</code>是发生在<code>运行时的赋值</code>而不是发生在编译时。</em></p>
<p>如果你想快捷的调用 dostring（比如加载并运行），可以这样<br><code>loadstring(s)()</code></p>
<p>如果加载的内容存在<code>语法错误</code>的话，loadstring 返回 nil 和错误信息（attempt to call a nil value）；为了返回更清楚的错误信息可以使用 assert：<br><code>assert(loadstring(s))()</code></p>
<p>note:<em>每次调用 loadstring 都会重新编译,loadstring 编译的时候不关心词法范围</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line">f = <span class="built_in">loadstring</span>(<span class="string">&quot;i = i + 1&quot;</span>)</span><br><span class="line">g = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> i = i + <span class="number">1</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>note:<em>这个例子中，和想象的一样 <code>g</code> 使用*<em>局部变量</em></em> i，然而 <code>f</code> 使用<strong>全局变量</strong> i；<code>loadstring</code> 总是在<strong>全局环境</strong>中<strong>编译</strong>他的串。*</p>
<p>note:<em>loadstring 期望一个 chunk，即语句。如果想要加载<code>表达式</code>，需要在表达式前加 <code>return</code>，那样将返回表达式的值。</em></p>
<h2 id="8-1-require"><a href="#8-1-require" class="headerlink" title="8.1 require"></a>8.1 require</h2><ul>
<li><em>会搜索目录加载文件</em></li>
<li><em>会判断是否文件已经加载避免重复加载同一文件</em></li>
<li><em>?;?.lua;c:\windows?;&#x2F;usr&#x2F;local&#x2F;lua&#x2F;?&#x2F;?.lua</em></li>
<li><em>require 和 dofile 完成同样的功能</em></li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">require</span> lili</span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">lili</span></span><br><span class="line"><span class="comment">lili.lua</span></span><br><span class="line"><span class="comment">c:\windows\lili</span></span><br><span class="line"><span class="comment">/usr/local/lua/lili/lili.lua</span></span><br><span class="line"><span class="comment">]]</span></span><br></pre></td></tr></table></figure>

<p>note:<em>表中保留加载的文件的虚名，而不是实文件名。所以如果你使用不同的虚文件名 require同一个文件两次，将会加载两次该文件。比如 require “foo”和 require “foo.lua”，将会加载 foo.lua 两次,全局变量<code>_LOADED</code> 访问文件名列表, <code>_REQUIREDNAME</code></em></p>
<h3 id="8-2-C-Packages"><a href="#8-2-C-Packages" class="headerlink" title="8.2 C Packages"></a>8.2 C Packages</h3><p>note:<em>动态连接库不是 ANSI C 的一部分，也就是说在标准 C 中实现动态连接是很困难的。</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">path</span> = <span class="string">&quot;/usr/local/lua/lib/libluasocket.so&quot;</span></span><br><span class="line"><span class="comment">-- or path = &quot;C:\\windows\\luasocket.dll&quot;</span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">loadlib</span>(<span class="built_in">path</span>, <span class="string">&quot;luaopen_socket&quot;</span>))</span><br><span class="line">f() <span class="comment">-- actually open the library</span></span><br></pre></td></tr></table></figure>

<h3 id="8-3-error-错误"><a href="#8-3-error-错误" class="headerlink" title="8.3 error 错误"></a>8.3 error 错误</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;enter a number:&quot;</span></span><br><span class="line">n = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&quot;*number&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="built_in">error</span>(<span class="string">&quot;invalid input&quot;</span>) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="8-4-exception-pcall"><a href="#8-4-exception-pcall" class="headerlink" title="8.4 exception &amp; pcall"></a>8.4 exception &amp; pcall</h3><h3 id="8-5-exception-msg-xpcall"><a href="#8-5-exception-msg-xpcall" class="headerlink" title="8.5 exception msg &amp; xpcall"></a>8.5 exception msg &amp; xpcall</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">error</span>(<span class="string">&quot;string expected&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">debug</span>.<span class="built_in">traceback</span>())</span><br></pre></td></tr></table></figure>

<h2 id="9-0-coroutine"><a href="#9-0-coroutine" class="headerlink" title="9.0 coroutine"></a>9.0 coroutine</h2><p>协同程序（coroutine）<em>与多线程情况下的线程比较类似：有自己的堆栈，自己的局部变量，有自己的指令指针，但是和其他协同程序共享全局变量等很多信息。</em></p>
<p>线程和协同程序的主要不同在于：在多处理器情况下，从概念上来讲多线程程序同时运行多个线程；而协同程序是通过协作来完成，在<strong>任一指定时刻只有一个协同程序在运行</strong>，并且这个正在运行的协同程序只有在明确的被要求挂起的时候才会被挂起。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> <span class="built_in">print</span>(<span class="string">&quot;hi&quot;</span>) <span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">print</span>(co) <span class="comment">--&gt; thread: 0x8071d98</span></span><br></pre></td></tr></table></figure>

<p>note:<em>协同有三个状态：挂起态、运行态、停止态.当我们创建一个协同程序时他开始的状态为挂起态，也就是说我们创建协同程序的时候不会自动运行，</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co)) <span class="comment">--&gt; suspended</span></span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">status</span>(co)) <span class="comment">--&gt; dead</span></span><br><span class="line"></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">10</span> <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;co&quot;</span>, i)</span><br><span class="line">        <span class="built_in">coroutine</span>.<span class="built_in">yield</span>()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 协同程序处于终止状态 激活他，resume 将返回 false 和错误信息。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)) <span class="comment">--&gt; false cannot resume dead coroutine</span></span><br></pre></td></tr></table></figure>

<p>note:<em>resume 运行在保护模式下，因此如果协同内部存在错误 Lua 并不会抛出错误而是将错误返回给 resume 函数。</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- yield 返回的额外的参数也将会传递给 resume。</span></span><br><span class="line">co = <span class="built_in">coroutine</span>.<span class="built_in">create</span> (<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;co&quot;</span>, <span class="built_in">coroutine</span>.<span class="built_in">yield</span>())</span><br><span class="line"><span class="keyword">end</span>)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line"><span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co, <span class="number">4</span>, <span class="number">5</span>) <span class="comment">--&gt; co 4 5</span></span><br></pre></td></tr></table></figure>

<ul>
<li>resume 把额外的参数传递给协同的主程序。</li>
<li>resume 返回除了 true 以外的其他部分将作为参数传递给相应的 yield, yield 返回的额外的参数也将会传递给 resume。</li>
<li>当协同代码结束时主函数返回的值都会传给相应的 resume</li>
</ul>
<p>对称协同:<em>由执行到挂起之间状态转换的函数是相同的。</em><br>不对称协同(半协同):<em>挂起一个正在执行的协同的函数与使一 个被挂起的协同再次执行的函数是不同的</em></p>
<h3 id="9-2-filter-过滤器"><a href="#9-2-filter-过滤器" class="headerlink" title="9.2 filter 过滤器"></a>9.2 filter 过滤器</h3><p>过滤器:<em>指在生产者与消费者之间，可以对数据 进行某些转换处理。过滤器在同一时间既是生产者又是消费者，他请求生产者生产值并 且转换格式后传给消费者</em></p>
<p>example:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">receive</span> <span class="params">(prod)</span></span></span><br><span class="line"><span class="keyword">local</span> <span class="built_in">status</span>, value = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(prod)</span><br><span class="line">   <span class="keyword">return</span> value</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">send</span> <span class="params">(x)</span></span></span><br><span class="line">   <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(x)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">producer</span> <span class="params">()</span></span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> x = <span class="built_in">io</span>.<span class="built_in">read</span>() <span class="comment">-- produce new value</span></span><br><span class="line">            send(x)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span> <span class="params">(prod)</span></span></span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">       <span class="keyword">local</span> line = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">            <span class="keyword">local</span> x = receive(prod) <span class="comment">-- get new value</span></span><br><span class="line">            x = <span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%5d %s&quot;</span>, line, x)</span><br><span class="line">            send(x) <span class="comment">-- send it to consumer</span></span><br><span class="line">            line = line + <span class="number">1</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consumer</span> <span class="params">(prod)</span></span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> x = receive(prod) <span class="comment">-- get new value</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(x, <span class="string">&quot;\n&quot;</span>) <span class="comment">-- consume new value</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">consumer(filter(producer()))</span><br></pre></td></tr></table></figure>

<h3 id="9-3-iterator-迭代器"><a href="#9-3-iterator-迭代器" class="headerlink" title="9.3 iterator 迭代器"></a>9.3 iterator 迭代器</h3><p>origin:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permgen</span> <span class="params">(a, n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">        printResult(a)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="comment">-- put i-th element as the last one</span></span><br><span class="line">            a[n], a[i] = a[i], a[n]</span><br><span class="line">            <span class="comment">-- generate all permutations of the other elements</span></span><br><span class="line">            permgen(a, n - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">-- restore i-th element</span></span><br><span class="line">            a[n], a[i] = a[i], a[n]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printResult</span> <span class="params">(a)</span></span></span><br><span class="line">   <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">       <span class="built_in">io</span>.<span class="built_in">write</span>(v, <span class="string">&quot; &quot;</span>)</span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line">   <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">permgen (&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>example:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">permgen</span> <span class="params">(a, n)</span></span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span></span><br><span class="line">       <span class="built_in">coroutine</span>.<span class="built_in">yield</span>(a)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span> i=<span class="number">1</span>,n <span class="keyword">do</span></span><br><span class="line">            <span class="comment">-- put i-th element as the last one</span></span><br><span class="line">            a[n], a[i] = a[i], a[n]</span><br><span class="line">            <span class="comment">-- generate all permutations of the other elements</span></span><br><span class="line">            permgen(a, n - <span class="number">1</span>)</span><br><span class="line">            <span class="comment">-- restore i-th element</span></span><br><span class="line">            a[n], a[i] = a[i], a[n]</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">perm</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">local</span> n = #a</span><br><span class="line">    <span class="keyword">local</span> co = <span class="built_in">coroutine</span>.<span class="built_in">create</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> permgen(a, n) <span class="keyword">end</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">()</span></span> <span class="comment">-- iterator</span></span><br><span class="line">        <span class="keyword">local</span> code, res = <span class="built_in">coroutine</span>.<span class="built_in">resume</span>(co)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printResult</span> <span class="params">(a)</span></span></span><br><span class="line">    <span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">        <span class="built_in">io</span>.<span class="built_in">write</span>(v, <span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> perm&#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>&#125; <span class="keyword">do</span></span><br><span class="line">   printResult(p)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>coroutine.wrap:<em>wrap 创建一个协同程序;不同的是 wrap 不返回协 同本身，而是返回一个函数，当这个函数被调用时将 resume 协同</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">perm</span> <span class="params">(a)</span></span></span><br><span class="line">   <span class="keyword">local</span> n = #a</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">coroutine</span>.<span class="built_in">wrap</span>(<span class="function"><span class="keyword">function</span> <span class="params">()</span></span> permgen(a, n) <span class="keyword">end</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="9-4-pre-emptive-multi-thread-非抢占式多线程"><a href="#9-4-pre-emptive-multi-thread-非抢占式多线程" class="headerlink" title="9.4 pre-emptive multi thread 非抢占式多线程"></a>9.4 pre-emptive multi thread 非抢占式多线程</h3><p>note:<em>协同是非抢占式的。 当一个协同正在运行时，不能在外部终止他。只能通过显示的调用 yield 挂起他的执行。</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">协同是非抢占式的。 当一个协同正在运行时，不能在外部终止他。只能通过显示的调用 <span class="built_in">yield</span> 挂起他的执行。</span><br></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>table &amp; object</p>
</blockquote>
<h2 id="11-datastruct"><a href="#11-datastruct" class="headerlink" title="11. datastruct"></a>11. datastruct</h2><h3 id="11-1-array-数组"><a href="#11-1-array-数组" class="headerlink" title="11.1 array 数组"></a>11.1 array 数组</h3><h3 id="11-2-matrix-multidimensional-array-阵-多维数组"><a href="#11-2-matrix-multidimensional-array-阵-多维数组" class="headerlink" title="11.2 matrix &amp; multidimensional array 阵 多维数组"></a>11.2 matrix &amp; multidimensional array 阵 多维数组</h3><p>稀疏矩阵:<em>指矩阵的大部分元素都为空或者 0 的矩阵。</em></p>
<h3 id="11-3-linked-list-s链表"><a href="#11-3-linked-list-s链表" class="headerlink" title="11.3 linked list s链表"></a>11.3 linked list s链表</h3><h3 id="11-4-queen-dique-s队列-双端队列"><a href="#11-4-queen-dique-s队列-双端队列" class="headerlink" title="11.4 queen &amp; dique s队列 双端队列"></a>11.4 queen &amp; dique s队列 双端队列</h3><p>note:<em>Lua 的 table 库提供的 insert 和 remove 操作来实现队列，但这种方式 实现的队列针对<strong>大数据量</strong>时效率太低</em></p>
<p>note:<em>有效的方式是使用两个索引下标，一个表示第一个元素，另一个表示最后一个元素。</em></p>
<h3 id="11-5-set-package-集合-包"><a href="#11-5-set-package-集合-包" class="headerlink" title="11.5 set &amp; package 集合 包"></a>11.5 set &amp; package 集合 包</h3><h3 id="11-6-string-buffer-字符串缓冲"><a href="#11-6-string-buffer-字符串缓冲" class="headerlink" title="11.6 string buffer 字符串缓冲"></a>11.6 string buffer 字符串缓冲</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- WARNING: bad code ahead!!</span></span><br><span class="line"><span class="keyword">local</span> buff = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">   buff = buff .. line .. <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>假定在 loop 中间，buff 已经是一个 50KB 的字符串， 每一行的大小为 20bytes，<br>当 Lua 执行 <code>buff..line..&quot;\n&quot;</code>时，她创建了一个新的字符串大小为 50,020 bytes，并且从 buff 中将 50KB 的字符串拷贝到新串中。<br>老的字符串变成了垃圾数据，两轮循环之后，将有两个老串包含超过 100KB 的垃圾 数据。这个时候 Lua 会做出正确的决定，进行他的垃圾收集并释放 100KB 的内存。问题 在于每两次循环 Lua 就要进行一次垃圾收集，读取整个文件需要进行 200 次垃圾收集。 并且它的内存使用是整个文件大小的三倍。</p>
<p>note:<em>其它的采用垃圾收集算法的并且字符串不可变的语言 也都存在这个问题。Java 专门提供 StringBuffer 来改善这种情况。</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newStack</span> <span class="params">()</span></span></span><br><span class="line">   <span class="keyword">return</span> &#123;<span class="string">&quot;&quot;</span>&#125;   <span class="comment">-- starts with an empty string</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addString</span> <span class="params">(stack, s)</span></span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(stack,s) <span class="comment">--push&#x27;s&#x27;intothethestack for i=#stack-1, 1, -1 do</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">string</span>.<span class="built_in">len</span>(stack[i]) &gt; <span class="built_in">string</span>.<span class="built_in">len</span>(stack[i+<span class="number">1</span>]) <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    stack[i] = stack[i] .. stack[i+<span class="number">1</span>]</span><br><span class="line">    stack[i+<span class="number">1</span>] = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> s = newStack()</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">   addString(s, line .. <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">s = toString(s)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">local</span> t = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> <span class="built_in">io</span>.<span class="built_in">lines</span>() <span class="keyword">do</span></span><br><span class="line">   <span class="built_in">table</span>.<span class="built_in">insert</span>(t, line)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">s = <span class="built_in">table</span>.<span class="built_in">concat</span>(t, <span class="string">&quot;\n&quot;</span>) .. <span class="string">&quot;\n&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="12-data-file-storage-Persistence-数据文件与持久化"><a href="#12-data-file-storage-Persistence-数据文件与持久化" class="headerlink" title="12. data file storage &amp; Persistence 数据文件与持久化"></a>12. data file storage &amp; Persistence 数据文件与持久化</h2><blockquote>
<p>string.format(“%q”, o)</p>
</blockquote>
<h2 id="13-metatables-metamethods"><a href="#13-metatables-metamethods" class="headerlink" title="13. metatables metamethods"></a>13. metatables metamethods</h2><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">t1 = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t, t1)</span><br><span class="line"><span class="built_in">assert</span>(<span class="built_in">getmetatable</span>(t) == t1)</span><br></pre></td></tr></table></figure>

<p>note:<em>一组相关的表可以共享一个 metatable (描述他们共同的行为)。一个表也可以是<strong>自身</strong>的 metatable(描述其私有行为)。</em></p>
<h3 id="13-1-arithmetic-operation-metamethods-算术运算的-matamethods"><a href="#13-1-arithmetic-operation-metamethods-算术运算的-matamethods" class="headerlink" title="13.1  arithmetic operation metamethods 算术运算的 matamethods"></a>13.1  arithmetic operation metamethods 算术运算的 matamethods</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Set = &#123;&#125;</span><br><span class="line">Set.mt = &#123;&#125; <span class="comment">-- metatable for sets</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.new</span> <span class="params">(t)</span></span></span><br><span class="line">   <span class="keyword">local</span> set = &#123;&#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(set, Set.mt)</span><br><span class="line">   <span class="keyword">for</span> _, l <span class="keyword">in</span> <span class="built_in">ipairs</span>(t) <span class="keyword">do</span> set[l] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">return</span> set</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.union</span> <span class="params">(a,b)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">getmetatable</span>(a) ~= Set.mt <span class="keyword">or</span> <span class="built_in">getmetatable</span>(b) ~= Set.mt <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;attempt to `add&#x27; a set with a non-set value&quot;</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">local</span> res = Set.new&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span> res[k] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(b) <span class="keyword">do</span> res[k] = <span class="literal">true</span> <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.intersection</span> <span class="params">(a,b)</span></span></span><br><span class="line">   <span class="keyword">local</span> res = Set.new&#123;&#125;</span><br><span class="line">   <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">res[k] = b[k]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">   <span class="keyword">return</span> res</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.tostring</span> <span class="params">(set)</span></span></span><br><span class="line">   <span class="keyword">local</span> s = <span class="string">&quot;&#123;&quot;</span></span><br><span class="line">   <span class="keyword">local</span> sep = <span class="string">&quot;&quot;</span></span><br><span class="line">   <span class="keyword">for</span> e <span class="keyword">in</span> <span class="built_in">pairs</span>(set) <span class="keyword">do</span></span><br><span class="line">s = s .. sep .. e</span><br><span class="line">sep = <span class="string">&quot;, &quot;</span> <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">return</span> s .. <span class="string">&quot;&#125;&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Set.print</span> <span class="params">(s)</span></span></span><br><span class="line">   <span class="built_in">print</span>(Set.<span class="built_in">tostring</span>(s))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">s1 = Set.new&#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">50</span>&#125;</span><br><span class="line">s2 = Set.new&#123;<span class="number">30</span>, <span class="number">1</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(s1))     <span class="comment">--&gt; table: 00672B60</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">getmetatable</span>(s2))     <span class="comment">--&gt; table: 00672B60</span></span><br><span class="line"></span><br><span class="line">Set.mt.<span class="built_in">__add</span> = Set.union</span><br><span class="line"></span><br><span class="line">s3 = s1 + s2</span><br><span class="line">Set.<span class="built_in">print</span>(s3) <span class="comment">--&gt; &#123;1, 10, 20, 30, 50&#125;</span></span><br><span class="line"></span><br><span class="line">Set.mt.<span class="built_in">__mul</span> = Set.intersection</span><br><span class="line">Set.<span class="built_in">print</span>((s1 + s2)*s1)     <span class="comment">--&gt; &#123;10, 20, 30, 50&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>note:<em>除了__add,__mul, 还有__sub(减),__div(除),__unm(负),__pow(幂)，我们也可以定义__concat 定义连接行为。</em></p>
<p>如果两个操作数有不同的 metatable, Lua 选择 metamethod 的原则:</p>
<ul>
<li>如果第一个参数存在带有__add 域的 metatable，Lua 使用它作为 metamethod，和第二个参数无关;</li>
<li>否则第二个参数存在带有__add 域的 metatable，Lua 使用它作为 metamethod 否则报错。</li>
</ul>
<h3 id="13-2-relational-operation-metamethods-关系运算的-metamethods"><a href="#13-2-relational-operation-metamethods-关系运算的-metamethods" class="headerlink" title="13.2 relational operation metamethods 关系运算的 metamethods"></a>13.2 relational operation metamethods 关系运算的 metamethods</h3><p>note:<em>__eq（等于），__lt（小于） ，和__le（小于等于)</em></p>
<p>note:<em><code>当我们遇到偏序（partial order）情况，也就是说，并不是所有的元素都可以正确的被排序情况。例如，在大多数机器上浮点数不能被排序，因为他的值不是一个数字（Not a Number 即 NaN）</code></em></p>
<p>note:<em>根据 IEEE 754 的标准，NaN 表示一个未定义的值，比如 0&#x2F;0 的结果。该标准指出任何涉及到 NaN 比较的结果都应为 false。也就是说，NaN &lt;&#x3D; x 总是 false，x &lt; NaN 也总是 false。这样一来，在这种情况下 a &lt;&#x3D; b 转换为 not (b &lt; a)就不再正确了。</em></p>
<p>note:<em>&lt;&#x3D;代表集合的包含：a &lt;&#x3D; b 表示集合 a 是集合 b 的子集。这种意义下，可能 a &lt;&#x3D; b 和 b &lt; a 都是 false；</em></p>
<p>note:<em>关系元算的 metamethods 不支持混合类型运算</em></p>
<p>note:<em>试图比较一个字符串和一个数字，Lua 将抛出错误.相似的，如果你试图比较两个带有不同 metamethods 的对象，Lua 也将抛出错误。</em></p>
<p>note:<em>但相等比较从来不会抛出错误，如果两个对象有不同的 metamethod，比较的结果为false，甚至可能不会调用 metamethod.</em></p>
<p>note:<em>仅当两个有共同的 metamethod 的对象进行相等比较的时候，Lua 才会调用对应的 metamethod。</em></p>
<h3 id="13-3-others-metamethods"><a href="#13-3-others-metamethods" class="headerlink" title="13.3 others metamethods"></a>13.3 others metamethods</h3><p>note:<em><code>print</code> 函数总是调用 tostring 来格式化它的输出, tostring 会首先检查对象是否存在一个带有<code>__tostring</code>域的 metatable。</em></p>
<p>假定你想保护你的集合使其使用者既看不到也不能修改 metatables。<br>如果你对 metatable 设置了__metatable 的值， getmetatable 将返回这个域的值，而调用 setmetatable将会出错：</p>
<blockquote>
<p>Set.mt.__metatable &#x3D; “not your business”</p>
</blockquote>
<h3 id="13-4-table-relative-metamethods-表相关-metamethods"><a href="#13-4-table-relative-metamethods-表相关-metamethods" class="headerlink" title="13.4 table relative metamethods 表相关 metamethods"></a>13.4 table relative metamethods 表相关 metamethods</h3><h4 id="13-4-1-The-index-Metamethod"><a href="#13-4-1-The-index-Metamethod" class="headerlink" title="13.4.1 The __index Metamethod"></a>13.4.1 The __index Metamethod</h4><p>note:<em>当我们访问一个表的不存在的域，这种访问触发 lua 解释器去查找__index metamethod</em><br>note:<em>__index metamethod 不需要非是一个函数，他也可以是一个表。</em></p>
<ul>
<li>它是一个函数的时候，Lua 将 table 和缺少的域作为参数调用这个函数；</li>
<li>他是一个表的时候，Lua 将在这个表中看是否有缺少的域。</li>
</ul>
<h4 id="13-4-2-The-newindex-Metamethod"><a href="#13-4-2-The-newindex-Metamethod" class="headerlink" title="13.4.2 The __newindex Metamethod"></a>13.4.2 The __newindex Metamethod</h4><p>note:<em>当你给表的一个缺少的域赋值，解释器就会查找__newindex metamethod,如果存在则调用这个函数而不进行赋值操作。</em></p>
<p>调用rawset(t,k,v)不掉用任何 metamethod 对表 t 的 k 域赋值为 v。</p>
<h4 id="13-4-3-table-default-value-有默认值的表"><a href="#13-4-3-table-default-value-有默认值的表" class="headerlink" title="13.4.3 table default value 有默认值的表"></a>13.4.3 table default value 有默认值的表</h4><h4 id="13-4-4-table-monitor-监控表"><a href="#13-4-4-table-monitor-监控表" class="headerlink" title="13.4.4 table monitor 监控表"></a>13.4.4 table monitor 监控表</h4><p>单表监控</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">t = &#123;&#125; <span class="comment">-- original table (created somewhere)</span></span><br><span class="line"><span class="comment">-- keep a private access to original table</span></span><br><span class="line"><span class="keyword">local</span> _t = t</span><br><span class="line"><span class="comment">-- create proxy</span></span><br><span class="line">t = &#123;&#125;</span><br><span class="line"><span class="comment">-- create metatable</span></span><br><span class="line"><span class="keyword">local</span> mt = &#123;</span><br><span class="line"><span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t,k)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*access to element &quot;</span> .. <span class="built_in">tostring</span>(k))</span><br><span class="line">    <span class="keyword">return</span> _t[k] <span class="comment">-- access the original table</span></span><br><span class="line"><span class="keyword">end</span>,</span><br><span class="line"><span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t,k,v)</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;*update of element &quot;</span> .. <span class="built_in">tostring</span>(k) ..</span><br><span class="line">    <span class="string">&quot; to &quot;</span> .. <span class="built_in">tostring</span>(v))</span><br><span class="line">    _t[k] = v <span class="comment">-- update original table</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(t, mt)</span><br></pre></td></tr></table></figure>

<p>note:<em>注意：不幸的是，这个设计不允许我们遍历表。</em></p>
<p>多表监控</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- create private index</span></span><br><span class="line"><span class="keyword">local</span> index = &#123;&#125;</span><br><span class="line"><span class="comment">-- create metatable</span></span><br><span class="line"><span class="keyword">local</span> mt = &#123;</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t,k)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*access to element &quot;</span> .. <span class="built_in">tostring</span>(k))</span><br><span class="line">        <span class="keyword">return</span> t[index][k] <span class="comment">-- access the original table</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t,k,v)</span></span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*update of element &quot;</span> .. <span class="built_in">tostring</span>(k) .. <span class="string">&quot; to &quot;</span>.. <span class="built_in">tostring</span>(v))</span><br><span class="line">        t[index][k] = v <span class="comment">-- update original table</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">track</span> <span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">local</span> proxy = &#123;&#125;</span><br><span class="line">    proxy[index] = t</span><br><span class="line">    <span class="built_in">setmetatable</span>(proxy, mt)</span><br><span class="line">    <span class="keyword">return</span> proxy</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="13-4-5-readonly-table-只读表"><a href="#13-4-5-readonly-table-只读表" class="headerlink" title="13.4.5 readonly table 只读表"></a>13.4.5 readonly table 只读表</h4><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readOnly</span> <span class="params">(t)</span></span></span><br><span class="line">    <span class="keyword">local</span> proxy = &#123;&#125;</span><br><span class="line">    <span class="keyword">local</span> mt = &#123; <span class="comment">-- create metatable</span></span><br><span class="line">        <span class="built_in">__index</span> = t,</span><br><span class="line">        <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t,k,v)</span></span></span><br><span class="line">            <span class="built_in">error</span>(<span class="string">&quot;attempt to update a read-only table&quot;</span>, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setmetatable</span>(proxy, mt)</span><br><span class="line">    <span class="keyword">return</span> proxy</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">days = readOnly&#123;<span class="string">&quot;Sunday&quot;</span>, <span class="string">&quot;Monday&quot;</span>, <span class="string">&quot;Tuesday&quot;</span>, <span class="string">&quot;Wednesday&quot;</span>,<span class="string">&quot;Thursday&quot;</span>, <span class="string">&quot;Friday&quot;</span>, <span class="string">&quot;Saturday&quot;</span>&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-environment-环境"><a href="#14-environment-环境" class="headerlink" title="14. environment 环境"></a>14. environment 环境</h2><h3 id="14-1-dynamic-access-global-value-使用动态名字访问全局变量"><a href="#14-1-dynamic-access-global-value-使用动态名字访问全局变量" class="headerlink" title="14.1 dynamic access global value 使用动态名字访问全局变量"></a>14.1 dynamic access global value 使用动态名字访问全局变量</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getfield</span> <span class="params">(f)</span></span></span><br><span class="line">    <span class="keyword">local</span> v = <span class="built_in">_G</span> <span class="comment">-- start with the table of globals</span></span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gfind</span>(f, <span class="string">&quot;[%w_]+&quot;</span>) <span class="keyword">do</span></span><br><span class="line">        v = v[w]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setfield</span> <span class="params">(f, v)</span></span></span><br><span class="line">    <span class="keyword">local</span> t = <span class="built_in">_G</span> <span class="comment">-- start with the table of globals</span></span><br><span class="line">    <span class="keyword">for</span> w, d <span class="keyword">in</span> <span class="built_in">string</span>.<span class="built_in">gfind</span>(f, <span class="string">&quot;([%w_]+)(.?)&quot;</span>) <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">if</span> d == <span class="string">&quot;.&quot;</span> <span class="keyword">then</span> <span class="comment">-- not last field?</span></span><br><span class="line">            t[w] = t[w] <span class="keyword">or</span> &#123;&#125; <span class="comment">-- create table if absent</span></span><br><span class="line">            t = t[w] <span class="comment">-- get the table</span></span><br><span class="line">        <span class="keyword">else</span> <span class="comment">-- last field</span></span><br><span class="line">            t[w] = v <span class="comment">-- do the assignment</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="14-2-delcare-global-value-声明全局变量"><a href="#14-2-delcare-global-value-声明全局变量" class="headerlink" title="14.2 delcare global value 声明全局变量"></a>14.2 delcare global value 声明全局变量</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> declaredNames = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">declare</span> <span class="params">(name, initval)</span></span></span><br><span class="line">    <span class="built_in">rawset</span>(<span class="built_in">_G</span>, name, initval)</span><br><span class="line">    declaredNames[name] = <span class="literal">true</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(<span class="built_in">_G</span>, &#123;</span><br><span class="line">    <span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t, n, v)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> declaredNames[n] <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;attempt to write to undeclared var. &quot;</span>..n, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">rawset</span>(t, n, v) <span class="comment">-- do the actual set</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">    <span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">(_, n)</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> declaredNames[n] <span class="keyword">then</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;attempt to read undeclared var. &quot;</span>..n, <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="14-3-un-global-environment-非全局的环境"><a href="#14-3-un-global-environment-非全局的环境" class="headerlink" title="14.3 un-global environment 非全局的环境"></a>14.3 un-global environment 非全局的环境</h3><p>note:<em>当你安装一个 metatable 去控制全局访问时，你的整个程序都必须遵循同一个指导方针。如果你想使用标准库，标准库中可能使用到没有声明的全局变量，你将碰到坏运。</em></p>
<p>Setfenv:<em>接受函数和新的环境作为参数。除了使用函数本身，还可以指定一个数字表示栈顶的活动函数。数字 1 代表当前函数，数字 2 代表调用当前函数的函数</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment">-- create a global variable</span></span><br><span class="line"><span class="comment">-- change current environment to a new empty table</span></span><br><span class="line"><span class="built_in">setfenv</span>(<span class="number">1</span>, &#123;&#125;)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br></pre></td></tr></table></figure>

<p>必须在单独的 chunk 内运行这段代码，如果你在交互模式逐行运行他，每一行都是一个不同的函数，调用 setfenv 只会影响他自己的那一行</p>
<p>封装: populate</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment">-- create a global variable</span></span><br><span class="line"><span class="comment">-- change current environment</span></span><br><span class="line"><span class="built_in">setfenv</span>(<span class="number">1</span>, &#123;<span class="built_in">_G</span> = <span class="built_in">_G</span>&#125;)</span><br><span class="line"><span class="built_in">_G</span>.<span class="built_in">print</span>(a) <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="built_in">_G</span>.<span class="built_in">print</span>(<span class="built_in">_G</span>.a) <span class="comment">--&gt; 1</span></span><br></pre></td></tr></table></figure>

<p>继承封装</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span> <span class="comment">-- create a global variable</span></span><br><span class="line"><span class="comment">-- change current environment</span></span><br><span class="line"><span class="built_in">setfenv</span>(<span class="number">1</span>, &#123;<span class="built_in">_G</span> = <span class="built_in">_G</span>&#125;)</span><br><span class="line"><span class="built_in">_G</span>.<span class="built_in">print</span>(a) <span class="comment">--&gt; nil</span></span><br><span class="line"><span class="built_in">_G</span>.<span class="built_in">print</span>(<span class="built_in">_G</span>.a) <span class="comment">--&gt; 1</span></span><br></pre></td></tr></table></figure>

<p>note:<em>当你创建一个新的函数时，他从创建他的函数继承了环境变量</em><br>note:<em>如果一个chunk 改变了他自己的环境，这个 chunk 所有在改变之后定义的函数都共享相同的环境，都会受到影响。这对创建<strong>命名空间</strong>是非常有用的机制</em></p>
<h2 id="15-package"><a href="#15-package" class="headerlink" title="15 package"></a>15 package</h2><p>note:<em>大多数语言中，packages 不是<strong>第一类值(first-class values)</strong>（也就是说，他们不能存储在变量里，不能作为函数参数。。。 ）</em></p>
<ul>
<li>对每一个函数定义都必须显示的在前面加上包的名称。</li>
<li>同一包内的函数<code>相互调用</code>必须在被调用函数前<strong>指定包名</strong>。</li>
</ul>
<p>缺点:</p>
<ul>
<li><em>修改函数的状态(公有变成私有或者私有变成公有)我们必须修改函数得*<em>调用方式</em></em>。*</li>
<li><em>访问同一个package 内的其他公有的实体写法冗余，必须加上前缀 P.。</em></li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">checkComplex</span> <span class="params">(c)</span></span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ((<span class="built_in">type</span>(c) == <span class="string">&quot;table&quot;</span>) <span class="keyword">and</span> <span class="built_in">tonumber</span>(c.r) <span class="keyword">and</span> <span class="built_in">tonumber</span>(c.i)) <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;bad complex number&quot;</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">new</span> <span class="params">(r, i)</span></span> <span class="keyword">return</span> &#123;r=r, i=i&#125; <span class="keyword">end</span></span><br><span class="line"><span class="keyword">local</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span> <span class="params">(c1, c2)</span></span></span><br><span class="line">    checkComplex(c1);</span><br><span class="line">    checkComplex(c2);</span><br><span class="line">    <span class="keyword">return</span> new(c1.r + c2.r, c1.i + c2.i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列表放在后面 因为必须首先定义局部函数</span></span><br><span class="line">complex = &#123;</span><br><span class="line">    new = new,</span><br><span class="line">    add = add,</span><br><span class="line">    <span class="built_in">sub</span> = <span class="built_in">sub</span>,</span><br><span class="line">    mul = mul,</span><br><span class="line">    div = div,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-3-package-file"><a href="#15-3-package-file" class="headerlink" title="15.3 package &amp; file"></a>15.3 package &amp; file</h3><pre><code>note:*当 require 加载一个文件的时候，它定义了一个变量来表示虚拟的文件名*

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 不需要 require 就可以使用 package</span></span><br><span class="line"><span class="keyword">local</span> P = &#123;&#125; <span class="comment">-- package</span></span><br><span class="line"><span class="keyword">if</span> _REQUIREDNAME == <span class="literal">nil</span> <span class="keyword">then</span></span><br><span class="line">    complex = P</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">_G</span>[_REQUIREDNAME] = P</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

note:*我们可以在同一个文件之内定义多个 packages，我们需要做的只是将每一个 package 放在一个 **do 代码块***内，这样 local 变量才能被限制在那个代码块中*

自动加载

<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> location = &#123;</span><br><span class="line">foo = <span class="string">&quot;/usr/local/lua/lib/pack1_1.lua&quot;</span>,</span><br><span class="line">goo = <span class="string">&quot;/usr/local/lua/lib/pack1_1.lua&quot;</span>,</span><br><span class="line">foo1 = <span class="string">&quot;/usr/local/lua/lib/pack1_2.lua&quot;</span>,</span><br><span class="line">goo1 = <span class="string">&quot;/usr/local/lua/lib/pack1_3.lua&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pack1 = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setmetatable</span>(pack1, &#123;<span class="built_in">__index</span> = <span class="function"><span class="keyword">function</span> <span class="params">(t, funcname)</span></span></span><br><span class="line">    <span class="keyword">local</span> file = location[funcname]</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> file <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">error</span>(<span class="string">&quot;package pack1 does not define &quot;</span> .. funcname)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">loadfile</span>(file))()    <span class="comment">-- load and run definition</span></span><br><span class="line">    <span class="keyword">return</span> t[funcname]          <span class="comment">-- return the function</span></span><br><span class="line"><span class="keyword">end</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pack1</span><br></pre></td></tr></table></figure>
</code></pre>
<h2 id="16-object-oriented-programming-面向对象程序设计"><a href="#16-object-oriented-programming-面向对象程序设计" class="headerlink" title="16 object-oriented programming 面向对象程序设计"></a>16 object-oriented programming 面向对象程序设计</h2><ul>
<li>示例代码 <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">Account = &#123;</span><br><span class="line">    balance=<span class="number">0</span>,</span><br><span class="line">    withdraw = <span class="function"><span class="keyword">function</span> <span class="params">(self, v)</span></span></span><br><span class="line">        <span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance - v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:deposit</span> <span class="params">(v)</span></span></span><br><span class="line">    <span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance + v</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Account.deposit(Account, <span class="number">200.00</span>)</span><br><span class="line">Account:withdraw(<span class="number">100.00</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Account:new</span> <span class="params">(o)</span></span></span><br><span class="line">    o = o <span class="keyword">or</span> &#123;&#125; <span class="comment">-- create object if user does not provide one</span></span><br><span class="line">    <span class="built_in">setmetatable</span>(o, <span class="built_in">self</span>)</span><br><span class="line">    <span class="built_in">self</span>.<span class="built_in">__index</span> = <span class="built_in">self</span></span><br><span class="line">    <span class="keyword">return</span> o</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">a = Account:new&#123;balance = <span class="number">0</span>&#125;</span><br><span class="line">a:deposit(<span class="number">100.00</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">getmetatable</span>(a).<span class="built_in">__index</span>.deposit(a, <span class="number">100.00</span>)</span><br><span class="line">Account.deposit(a, <span class="number">100.00</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="16-3-multiple-inheritance-多重继承"><a href="#16-3-multiple-inheritance-多重继承" class="headerlink" title="16.3 multiple inheritance 多重继承"></a>16.3 multiple inheritance 多重继承</h3><pre><code> 多重继承意味着一个类拥有多个父类
</code></pre>
<h3 id="16-4-private-私有性"><a href="#16-4-private-私有性" class="headerlink" title="16.4 private 私有性"></a>16.4 private 私有性</h3><pre><code> 通过闭包实现私有性

 <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newAccount</span> <span class="params">(initialBalance)</span></span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">self</span> = &#123;</span><br><span class="line">        balance = initialBalance,</span><br><span class="line">        LIM = <span class="number">10000.00</span>,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> withdraw = <span class="function"><span class="keyword">function</span> <span class="params">(v)</span></span></span><br><span class="line">    <span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance - v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> deposit = <span class="function"><span class="keyword">function</span> <span class="params">(v)</span></span></span><br><span class="line">    <span class="built_in">self</span>.balance = <span class="built_in">self</span>.balance + v</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> extra = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">self</span>.balance &gt; <span class="built_in">self</span>.LIM <span class="keyword">then</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">self</span>.balance*<span class="number">0.10</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">local</span> getBalance = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">self</span>.balance + <span class="built_in">self</span>.extra()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">--local getBalance = function () return self.balance end</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        withdraw = withdraw,</span><br><span class="line">        deposit = deposit,</span><br><span class="line">        getBalance = getBalance</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">acc1 = newAccount(<span class="number">100.00</span>)</span><br><span class="line">acc1.withdraw(<span class="number">40.00</span>)</span><br><span class="line"><span class="built_in">print</span>(acc1.getBalance())    <span class="comment">--&gt; 60</span></span><br></pre></td></tr></table></figure>
</code></pre>
<h3 id="16-5-Single-Method-的对象实现方法"><a href="#16-5-Single-Method-的对象实现方法" class="headerlink" title="16.5 Single-Method 的对象实现方法"></a>16.5 Single-Method 的对象实现方法</h3><pre><code> <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newObject</span> <span class="params">(value)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(action, v)</span></span></span><br><span class="line">        <span class="keyword">if</span> action == <span class="string">&quot;get&quot;</span> <span class="keyword">then</span> <span class="keyword">return</span> value</span><br><span class="line">        <span class="keyword">elseif</span> action == <span class="string">&quot;set&quot;</span> <span class="keyword">then</span> value = v</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">error</span>(<span class="string">&quot;invalid action&quot;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">d = newObject(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">print</span>(d(<span class="string">&quot;get&quot;</span>)) <span class="comment">--&gt; 0</span></span><br><span class="line">d(<span class="string">&quot;set&quot;</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(d(<span class="string">&quot;get&quot;</span>)) <span class="comment">--&gt; 10</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h2 id="17-weak-table"><a href="#17-weak-table" class="headerlink" title="17 weak table"></a>17 weak table</h2><p>一个 weak 引用是指<em>一个不被 Lua 认为是垃圾的对象的引用。</em><br>如果一个对象所有的引用指向都是weak，对象将被收集，而那些 weak 引用将会被删除。<br>如果一个对象只存在于 weak tables 中，Lua 将会最终将它收集。</p>
<p>三种类型的 weak tables：</p>
<ul>
<li><p>weak keys 组成的 tables；</p>
</li>
<li><p>weak values 组成的 tables；</p>
</li>
<li><p>以及纯 weak tables 类型，他们的 keys 和 values 都是 weak 的。</p>
<p>  表的 weak 性由他的 metatable 的__mode 域来指定的。</p>
  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line">b = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(a, b)</span><br><span class="line">b.<span class="built_in">__mode</span> = <span class="string">&quot;k&quot;</span> <span class="comment">-- now &#x27;a&#x27; has weak keys</span></span><br><span class="line">key = &#123;&#125; <span class="comment">-- creates first key</span></span><br><span class="line">a[&#123;key&#125;] = <span class="number">1</span></span><br><span class="line">key = &#123;&#125; <span class="comment">-- creates second key</span></span><br><span class="line">a[key] = <span class="number">2</span></span><br><span class="line"><span class="built_in">collectgarbage</span>() <span class="comment">-- forces a garbage collection cycle</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span> <span class="built_in">print</span>(v) <span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>  第二个赋值语句 key&#x3D;{}覆盖了第一个 key 的值。当垃圾收集器工作时，在其他地方没有指向第一个 key 的引用，所以它被收集了</p>
<p>  note:<em>只有对象才可以从一个 weak table 中被收集。比如数字和布尔值类型的值，都是不会被收集的。</em></p>
<p>  example:*如果我们在 table 中插入了一个数值型的 key（在前面那个例子中），它将永远不会被收集器从 table 中移除。当然，如果对应于这个数值型 key 的 <strong>vaule</strong>被收集，那么它的整个入口将会从 weak table 中被移除。*</p>
<p>  note:<em>一个字符串不会从 weak tables 中被移除（除非它所关联的 vaule 被收集）</em></p>
<h3 id="17-1-记忆函数"><a href="#17-1-记忆函数" class="headerlink" title="17.1 记忆函数"></a>17.1 记忆函数</h3><p>  如果这个结果表中有 weak 值，每次的垃圾收集循环都会移除当前时间内所有未被使用的结果</p>
<pre><code>  <figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> results = &#123;&#125;</span><br><span class="line"><span class="built_in">setmetatable</span>(results, &#123;<span class="built_in">__mode</span> = <span class="string">&quot;v&quot;</span>&#125;) <span class="comment">-- make values weak</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createRGB</span> <span class="params">(r, g, b)</span></span></span><br><span class="line">    <span class="keyword">local</span> key = r .. <span class="string">&quot;-&quot;</span> .. g .. <span class="string">&quot;-&quot;</span> .. b</span><br><span class="line">    <span class="keyword">if</span> results[key] <span class="keyword">then</span> <span class="keyword">return</span> results[key]</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">local</span> newcolor = &#123;red = r, green = g, blue = b&#125;</span><br><span class="line">        results[key] = newcolor</span><br><span class="line">        <span class="keyword">return</span> newcolor</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<blockquote>
<p>标准库</p>
</blockquote>
<h2 id="18-数学库"><a href="#18-数学库" class="headerlink" title="18. 数学库"></a>18. 数学库</h2><p>三角函数库（sin, cos, tan, asin, acos, etc.）<br>幂指函数（exp, log, log10），<br>舍入函数（floor, ceil）、<br>max、min，加上一个变量 pi。</p>
<p>所有的三角函数都在弧度单位下工作。<strong>（Lua4.0 以前在度数下工作。）</strong><br>你可以使用 <code>deg</code>和 <code>rad</code> 函数在度和弧度之间转换。</p>
<p>math.random 用来产生伪随机数，有三种调用方式：</p>
<ul>
<li>第一：不带参数，将产生 [0,1)范围内的随机数.</li>
<li>第二：带一个参数 n，将产生 1 &lt;&#x3D; x &lt;&#x3D; n 范围内的随机数 x.</li>
<li>第三：带两个参数 a 和 b,将产生 a &lt;&#x3D; x &lt;&#x3D; b 范围内的随机数 x.</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">math</span>.<span class="built_in">randomseed</span>(<span class="built_in">os</span>.<span class="built_in">time</span>())</span><br></pre></td></tr></table></figure>

<h2 id="19-table-lib"><a href="#19-table-lib" class="headerlink" title="19. table lib"></a>19. table lib</h2><p>table.getn table.setn 已经弃用</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="literal">nil</span>, <span class="number">1</span>, <span class="number">2</span>, key = <span class="string">&#x27;1234321&#x27;</span>, <span class="literal">nil</span>, <span class="number">15</span>, <span class="string">&#x27;sagewqgag&#x27;</span>, <span class="literal">nil</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">pairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> <span class="built_in">ipairs</span>(a) <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;ddd&#x27;</span>,k,v)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;len:&#x27;</span>,#a)</span><br></pre></td></tr></table></figure>

<p>ipairs iterate number index until first <code>nil</code><br>pairs iterate all except <code>nil</code><br>when <code>&#123;nil, 1, 2, key = &#39;1234321&#39;, nil, 15, &#39;sagewqgag&#39;, nil&#125;</code>, #a &#x3D; 6<br>when <code>&#123;1, 2, key = &#39;1234321&#39;, nil, 15, &#39;sagewqgag&#39;, nil&#125;</code>, #a &#x3D; 2<br>when <code>&#123;1, 2, key = &#39;1234321&#39;, 15, &#39;sagewqgag&#39;, nil&#125;</code>, #a &#x3D; 4<br>when <code>&#123;1, 2, key = &#39;1234321&#39;, 15, &#39;sagewqgag&#39;&#125;</code>, #a &#x3D; 4</p>
<p>table.insert 函数在 array指定位置插入一个元素，并<strong>将后面所有其他的元素后移。</strong></p>
<p>不带位置参数调用 insert，将会在 array<strong>最后位置</strong>插入元素（所以不需要元素移动）</p>
<p>note:<em>排序函数有两个参数并且如果在 array 中排序后第一个参数在第二个参数前面，排序函数必须返回 true。如果未提供排序函数，sort 使用默认的小于操作符进行比较</em></p>
<h2 id="20-string-lib"><a href="#20-string-lib" class="headerlink" title="20 string lib"></a>20 string lib</h2><p><code>string.len(s)</code>返回字符串 s 的长度；<br><code>string.rep(s,n)</code>返回重复 n 次字符串 s 的串；<br>你使用 <code>string.rep(&quot;a&quot;, 2^20)</code>可以创建一个 1M bytes 的字符串（比如，为了测试需要） ；<br><code>string.lower(s)</code>将 s 中的大写字母转换成小写（<code>string.upper</code>将小写转换成大写）<br><code>string.sub(s,i,j)</code>函数截取字符串 s 的从第 i 个字符到第 j 个字符之间的串。</p>
<p>Lua中，<em>字符串的第一个字符索引从 1 开始。你也可以使用负索引，负索引从字符串的结尾向前计数：-1 指向最后一个字符，-2 指向倒数第二个，以此类推。</em><br>note:<em>Lua 中的字符串是恒定不变的。String.sub 函数以及 Lua 中其他的字符串操作函数都不会改变字符串的值，而是返回一个新的字符串。</em><br>如果你想修改一个字符串变量的值，你必须将变量赋给一个新的字符串：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">s = <span class="built_in">string</span>.<span class="built_in">sub</span>(s, <span class="number">2</span>, <span class="number">-2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">char</span>(<span class="number">97</span>)) <span class="comment">--&gt; a</span></span><br><span class="line">i = <span class="number">99</span>; <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">char</span>(i, i+<span class="number">1</span>, i+<span class="number">2</span>)) <span class="comment">--&gt; cde</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;abc&quot;</span>)) <span class="comment">--&gt; 97</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">2</span>)) <span class="comment">--&gt; 98</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">byte</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">-1</span>)) <span class="comment">--&gt; 99</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;pi = %.4f&quot;</span>, PI)) <span class="comment">--&gt; pi = 3.1416</span></span><br><span class="line">d = <span class="number">5</span>; m = <span class="number">11</span>; y = <span class="number">1990</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;%02d/%02d/%04d&quot;</span>, d, m, y)) <span class="comment">--&gt; 05/11/1990</span></span><br><span class="line">tag, title = <span class="string">&quot;h1&quot;</span>, <span class="string">&quot;a title&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;&lt;%s&gt;%s&lt;/%s&gt;&quot;</span>, tag, title, tag)) <span class="comment">--&gt; &lt;h1&gt;a title&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="20-1-pattern-matching-模式匹配"><a href="#20-1-pattern-matching-模式匹配" class="headerlink" title="20.1 pattern matching 模式匹配"></a>20.1 pattern matching 模式匹配</h3><p>Lua并不使用POSIX规范的正则表达式（也写作<strong>regexp</strong>）来进行模式匹配。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">i, j = <span class="built_in">string</span>.<span class="built_in">find</span>(s, <span class="string">&quot;hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(i, j) <span class="comment">--&gt; 1 5</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(s, i, j)) <span class="comment">--&gt; hello</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(s, <span class="string">&quot;world&quot;</span>)) <span class="comment">--&gt; 7 11</span></span><br><span class="line">i, j = <span class="built_in">string</span>.<span class="built_in">find</span>(s, <span class="string">&quot;l&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(i, j) <span class="comment">--&gt; 3 3</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">find</span>(s, <span class="string">&quot;lll&quot;</span>)) <span class="comment">--&gt; nil</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> t = &#123;&#125; <span class="comment">-- table to store the indices</span></span><br><span class="line"><span class="keyword">local</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    i = <span class="built_in">string</span>.<span class="built_in">find</span>(s, <span class="string">&quot;\n&quot;</span>, i+<span class="number">1</span>) <span class="comment">-- find &#x27;next&#x27; newline</span></span><br><span class="line">    <span class="keyword">if</span> i == <span class="literal">nil</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">table</span>.<span class="built_in">insert</span>(t, i)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;Lua is cute&quot;</span>, <span class="string">&quot;cute&quot;</span>, <span class="string">&quot;great&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">--&gt; Lua is great</span></span><br><span class="line">s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;all lii&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;x&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">--&gt; axx xii</span></span><br><span class="line">s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;Lua is great&quot;</span>, <span class="string">&quot;perl&quot;</span>, <span class="string">&quot;tcl&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">--&gt; Lua is great</span></span><br><span class="line"></span><br><span class="line">s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;all lii&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">--&gt; axl lii</span></span><br><span class="line">s = <span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;all lii&quot;</span>, <span class="string">&quot;l&quot;</span>, <span class="string">&quot;x&quot;</span>, <span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(s) <span class="comment">--&gt; axx lii</span></span><br><span class="line">_, count = <span class="built_in">string</span>.<span class="built_in">gsub</span>(str, <span class="string">&quot; &quot;</span>, <span class="string">&quot; &quot;</span>)</span><br></pre></td></tr></table></figure>

<p>note:<em>_ 只是一个哑元变量</em></p>
<h3 id="20-2-pattern-模式"><a href="#20-2-pattern-模式" class="headerlink" title="20.2 pattern 模式"></a>20.2 pattern 模式</h3><pre><code>+ 匹配前一字符 1 次或多次
* 匹配前一字符 0 次或多次
- 匹配前一字符 0 次或多次
? 匹配前一字符 0 次或 1 次
&#39;[_%a][_%w]*&#39; 匹配 Lua 程序中的标示符：字母或者下划线开头的字母下划线数字序列。
匹配一对圆括号()或者括号之间的空白，可以使用 &#39;%(%s*%)&#39;
</code></pre>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">s = <span class="string">&quot;Deadline is 30/05/1999, firm&quot;</span></span><br><span class="line"><span class="built_in">date</span> = <span class="string">&quot;%d%d/%d%d/%d%d%d%d&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">sub</span>(s, <span class="built_in">string</span>.<span class="built_in">find</span>(s, <span class="built_in">date</span>))) <span class="comment">--&gt; 30/05/1999</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;hello, up-down!&quot;</span>, <span class="string">&quot;%A&quot;</span>, <span class="string">&quot;.&quot;</span>)) <span class="comment">--&gt; hello..up.down. 4</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="string">&quot;one, and two; and three&quot;</span>, <span class="string">&quot;%a+&quot;</span>, <span class="string">&quot;word&quot;</span>)) <span class="comment">--&gt; word, word word; word word</span></span><br><span class="line"></span><br><span class="line">i, j = <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="string">&quot;the number 1298 is even&quot;</span>, <span class="string">&quot;%d+&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(i,j) <span class="comment">--&gt; 12 15</span></span><br></pre></td></tr></table></figure>

<h3 id="20-3-matchings-捕获"><a href="#20-3-matchings-捕获" class="headerlink" title="20.3 matchings 捕获"></a>20.3 matchings 捕获</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">pair = <span class="string">&quot;name = Anna&quot;</span></span><br><span class="line">_, _, key, value = <span class="built_in">string</span>.<span class="built_in">find</span>(pair, <span class="string">&quot;(%a+)%s*=%s*(%a+)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(key, value) <span class="comment">--&gt; name Anna</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">date</span> = <span class="string">&quot;17/7/1990&quot;</span></span><br><span class="line">_, _, d, m, y = <span class="built_in">string</span>.<span class="built_in">find</span>(<span class="built_in">date</span>, <span class="string">&quot;(%d+)/(%d+)/(%d+)&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d, m, y) <span class="comment">--&gt; 17 7 1990</span></span><br><span class="line"></span><br><span class="line">s = <span class="string">[[then he said: &quot;it&#x27;s all right&quot;!]]</span></span><br><span class="line">a, b, c, quotedPart = <span class="built_in">string</span>.<span class="built_in">find</span>(s, <span class="string">&quot;([\&quot;&#x27;])(.-)%1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(quotedPart) <span class="comment">--&gt; it&#x27;s all right</span></span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment">--&gt; &quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="21-IO-lib"><a href="#21-IO-lib" class="headerlink" title="21. IO lib"></a>21. IO lib</h2><h3 id="21-1-simple-I-O-mode"><a href="#21-1-simple-I-O-mode" class="headerlink" title="21.1 simple I&#x2F;O mode"></a>21.1 simple I&#x2F;O mode</h3><p>io.input 和 io.output 函数来改变当前文件。<br>例如io.input(filename)就是打开给定文件（以读模式），并将其设置为当前输入文件。<br>接下来所有的输入都来自于该文，直到再次使用 io.input。io.output 函数。<br>一旦产生错误两个函数都会产生错误。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">&gt; <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="string">&quot;sin (3) = &quot;</span>, <span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">3</span>), <span class="string">&quot;\n&quot;</span>)</span><br><span class="line"><span class="comment">--&gt; sin (3) = 0.1411200080598672</span></span><br><span class="line">&gt; <span class="built_in">io</span>.<span class="built_in">write</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;sin (3) = %.4f\n&quot;</span>, <span class="built_in">math</span>.<span class="built_in">sin</span>(<span class="number">3</span>)))</span><br><span class="line"><span class="comment">--&gt; sin (3) = 0.1411</span></span><br></pre></td></tr></table></figure>

<p>在编写代码时应当避免像 io.write(a..b..c)；这样的书写，这同 io.write(a,b,c)的效果是一样的。但是后者因为避免了串联操作，而消耗较少的资源。</p>
<p>Write 函数与 print 函数不同在于，write 不附加任何额外的字符到输出中去，例如制表符，换行符等等。<br>write 函数是使用当前输出文件，而 print 始终使用标准输出。<br>print函数会自动调用参数的 tostring方法，所以可以显示出表（tables）函数（functions）和 nil。</p>
<p>“*all” 读取整个文件<br>“*line” 读取下一行<br>“*number” 从串中转换出一个数值<br>num 读取 num 个字符到串</p>
<p>io.read(“*all”)函数从当前位置读取整个输入文件。如果当前位置在文件末尾，或者文件为空，函数将返回空串。<br>io.read(“*line”)函数返回当前输入文件的下一行（不包含最后的换行符）。当到达文件末尾，返回值为 nil（表示没有下一行可返回）<br><em>该读取方式是 read 函数的默认方式，所以可以简写为 io.read()。</em><br>io.read(“*number”)函数从当前输入文件中读取出一个数值。只有在该参数下 read 函数才返回数值，而不是字符串。<br>如果在当前位置找不到一个数字（由于格式不对，或者是到了文件的结尾），则返回 nil 可以对每个参数设置选项，函数将返回各自的结果。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">6.0 -3.23 15e12</span></span><br><span class="line"><span class="comment">4.3 234 1000001</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> n1, n2, n3 = <span class="built_in">io</span>.<span class="built_in">read</span>(<span class="string">&quot;*number&quot;</span>, <span class="string">&quot;*number&quot;</span>, <span class="string">&quot;*number&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> n1 <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">math</span>.<span class="built_in">max</span>(n1, n2, n3))</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> size = <span class="number">2</span>^<span class="number">13</span> <span class="comment">-- good buffer size (8K)</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line"><span class="keyword">local</span> block = <span class="built_in">io</span>.<span class="built_in">read</span>(size)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> block <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">write</span>(block)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="21-2-complete-I-O-mode"><a href="#21-2-complete-I-O-mode" class="headerlink" title="21.2 complete I&#x2F;O mode"></a>21.2 complete I&#x2F;O mode</h3><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> f = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(filename, <span class="string">&quot;r&quot;</span>))</span><br><span class="line"><span class="keyword">local</span> t = f:<span class="built_in">read</span>(<span class="string">&quot;*all&quot;</span>)</span><br><span class="line">f:<span class="built_in">close</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> temp = <span class="built_in">io</span>.<span class="built_in">input</span>() <span class="comment">-- save current file</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">input</span>(<span class="string">&quot;newinput&quot;</span>) <span class="comment">-- open a new current file</span></span><br><span class="line">... <span class="comment">-- do something with new input</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">input</span>():<span class="built_in">close</span>() <span class="comment">-- close current file</span></span><br><span class="line"><span class="built_in">io</span>.<span class="built_in">input</span>(temp) <span class="comment">-- restore previous current file</span></span><br></pre></td></tr></table></figure>

<p>I&#x2F;O 优化的一个小技巧:<br>通常 Lua 中读取整个文件要比一行一行的读取一个文件快的多。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="keyword">local</span> <span class="built_in">lines</span>, rest = f:<span class="built_in">read</span>(BUFSIZE, <span class="string">&quot;*line&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> BUFSIZE = <span class="number">2</span>^<span class="number">13</span> <span class="comment">-- 8K</span></span><br><span class="line"><span class="keyword">local</span> f = <span class="built_in">io</span>.<span class="built_in">input</span>(<span class="built_in">arg</span>[<span class="number">1</span>]) <span class="comment">-- open input file</span></span><br><span class="line"><span class="keyword">local</span> cc, lc, wc = <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> <span class="comment">-- char, line, and word counts</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> <span class="built_in">lines</span>, rest = f:<span class="built_in">read</span>(BUFSIZE, <span class="string">&quot;*line&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">lines</span> <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> rest <span class="keyword">then</span> <span class="built_in">lines</span> = <span class="built_in">lines</span> .. rest .. <span class="string">&#x27;\n&#x27;</span> <span class="keyword">end</span></span><br><span class="line">    cc = cc + <span class="built_in">string</span>.<span class="built_in">len</span>(<span class="built_in">lines</span>)</span><br><span class="line">    <span class="comment">-- count words in the chunk</span></span><br><span class="line">    <span class="keyword">local</span> _,t = <span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="built_in">lines</span>, <span class="string">&quot;%S+&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    wc = wc + t</span><br><span class="line">    <span class="comment">-- count newlines in the chunk</span></span><br><span class="line">    _,t = <span class="built_in">string</span>.<span class="built_in">gsub</span>(<span class="built_in">lines</span>, <span class="string">&quot;\n&quot;</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">    lc = lc + t</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">print</span>(lc, wc, cc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> inp = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(<span class="built_in">arg</span>[<span class="number">1</span>], <span class="string">&quot;rb&quot;</span>))</span><br><span class="line"><span class="keyword">local</span> out = <span class="built_in">assert</span>(<span class="built_in">io</span>.<span class="built_in">open</span>(<span class="built_in">arg</span>[<span class="number">2</span>], <span class="string">&quot;wb&quot;</span>))</span><br><span class="line"><span class="keyword">local</span> data = inp:<span class="built_in">read</span>(<span class="string">&quot;*all&quot;</span>)</span><br><span class="line">data = <span class="built_in">string</span>.<span class="built_in">gsub</span>(data, <span class="string">&quot;\r\n&quot;</span>, <span class="string">&quot;\n&quot;</span>)</span><br><span class="line">out:<span class="built_in">write</span>(data)</span><br><span class="line"><span class="built_in">assert</span>(out:<span class="built_in">close</span>())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fsize</span> <span class="params">(file)</span></span></span><br><span class="line"><span class="keyword">local</span> current = file:seek() <span class="comment">-- get current position</span></span><br><span class="line"><span class="keyword">local</span> size = file:seek(<span class="string">&quot;end&quot;</span>) <span class="comment">-- get file size</span></span><br><span class="line">file:seek(<span class="string">&quot;set&quot;</span>, current) <span class="comment">-- restore position</span></span><br><span class="line"><span class="keyword">return</span> size</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="22-system-lib-操作系统库"><a href="#22-system-lib-操作系统库" class="headerlink" title="22 system lib 操作系统库"></a>22 system lib 操作系统库</h2><p>Lua 是以 ANSI C 写成的</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- obs: 10800 = 3*60*60 (3 hours)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">time</span>&#123;year=<span class="number">1970</span>, month=<span class="number">1</span>, day=<span class="number">1</span>, hour=<span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment">--&gt; 10800</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">time</span>&#123;year=<span class="number">1970</span>, month=<span class="number">1</span>, day=<span class="number">1</span>, hour=<span class="number">0</span>, sec=<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">--&gt; 10801</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">time</span>&#123;year=<span class="number">1970</span>, month=<span class="number">1</span>, day=<span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment">--&gt; 54000 (obs: 54000 = 10800 + 12*60*60)</span></span><br><span class="line"></span><br><span class="line">temp = <span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;*t&quot;</span>, <span class="number">906000490</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">&#123;year = 1998, month = 9, day = 16, yday = 259, wday = 4,</span></span><br><span class="line"><span class="comment">hour = 23, min = 48, sec = 10, isdst = false&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">%a abbreviated weekday name (e.g., Wed)</span></span><br><span class="line"><span class="comment">%A full weekday name (e.g., Wednesday)</span></span><br><span class="line"><span class="comment">%b abbreviated month name (e.g., Sep)</span></span><br><span class="line"><span class="comment">%B full month name (e.g., September)</span></span><br><span class="line"><span class="comment">%c date and time (e.g., 09/16/98 23:48:10)</span></span><br><span class="line"><span class="comment">%d day of the month (16) [01-31]</span></span><br><span class="line"><span class="comment">%H hour, using a 24-hour clock (23) [00-23]</span></span><br><span class="line"><span class="comment">%I hour, using a 12-hour clock (11) [01-12]</span></span><br><span class="line"><span class="comment">%M minute (48) [00-59]</span></span><br><span class="line"><span class="comment">%m month (09) [01-12]</span></span><br><span class="line"><span class="comment">%p either &quot;am&quot; or &quot;pm&quot; (pm)</span></span><br><span class="line"><span class="comment">%S second (10) [00-61]</span></span><br><span class="line"><span class="comment">%w weekday (3) [0-6 = Sunday-Saturday]</span></span><br><span class="line"><span class="comment">%x date (e.g., 09/16/98)</span></span><br><span class="line"><span class="comment">%X time (e.g., 23:48:10)</span></span><br><span class="line"><span class="comment">%Y full year (1998)</span></span><br><span class="line"><span class="comment">%y two-digit year (98) [00-99]</span></span><br><span class="line"><span class="comment">%% the character &#x27;%&#x27;</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事实上如果不使用任何参数就调用 date，就是以%c 的形式输出。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;today is %A, in %B&quot;</span>))</span><br><span class="line"><span class="comment">--&gt; today is Tuesday, in May</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">date</span>(<span class="string">&quot;%x&quot;</span>, <span class="number">906000490</span>))</span><br><span class="line"><span class="comment">--&gt; 09/16/1998</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">os</span>.<span class="built_in">getenv</span>(<span class="string">&quot;HOME&quot;</span>)) <span class="comment">--&gt; /home/lua</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDir</span> <span class="params">(dirname)</span></span></span><br><span class="line">    <span class="built_in">os</span>.<span class="built_in">execute</span>(<span class="string">&quot;mkdir &quot;</span> .. dirname)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h2 id="23-debug-lib"><a href="#23-debug-lib" class="headerlink" title="23. debug lib"></a>23. debug lib</h2><p>debug 库由两种函数组成：自省(<code>introspective</code>)函数和 <code>hooks</code>。</p>
<p>自省函数 <em>使得我们可以检查运行程序的某些方面，比如活动函数栈、当前执行代码的行号、本地变量的名和值。</em><br>Hooks <em>可以跟踪程序的执行情况。</em></p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="built_in">debug</span>.<span class="built_in">getinfo</span>(foo)</span><br></pre></td></tr></table></figure>

<p>以数字 n 调用 <code>debug.getinfo(n)</code>时，返回在 <strong>n 级栈</strong>的活动函数的信息数据。<br>比如，如果 n&#x3D;1，返回的是正在进行调用的那个函数的信息。（n&#x3D;0 表示 C 函数 getinfo 本身）<br>如果 n 比栈中活动函数的个数大的话，debug.getinfo 返回 nil。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">traceback</span> <span class="params">()</span></span></span><br><span class="line">    <span class="keyword">local</span> level = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> info = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(level, <span class="string">&quot;Sl&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> info <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> info.what == <span class="string">&quot;C&quot;</span> <span class="keyword">then</span> <span class="comment">-- is a C function?</span></span><br><span class="line">            <span class="built_in">print</span>(level, <span class="string">&quot;C function&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">-- a Lua function</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="built_in">string</span>.<span class="built_in">format</span>(<span class="string">&quot;[%s]:%d&quot;</span>,</span><br><span class="line">            info.short_src, info.currentline))</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        level = level + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--[[</span></span><br><span class="line"><span class="comment">a 10</span></span><br><span class="line"><span class="comment">b 20</span></span><br><span class="line"><span class="comment">x nil</span></span><br><span class="line"><span class="comment">a 4</span></span><br><span class="line"><span class="comment">]]</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> <span class="params">(a,b)</span></span></span><br><span class="line">    <span class="keyword">local</span> x</span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">local</span> c = a - b <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">local</span> a = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> name, value = <span class="built_in">debug</span>.<span class="built_in">getlocal</span>(<span class="number">1</span>, a)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> name <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">print</span>(name, value)</span><br><span class="line">        a = a + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">foo(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getvarvalue</span> <span class="params">(name)</span></span></span><br><span class="line">    <span class="keyword">local</span> value, found</span><br><span class="line">    <span class="comment">-- try local variables</span></span><br><span class="line">    <span class="keyword">local</span> i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> n, v = <span class="built_in">debug</span>.<span class="built_in">getlocal</span>(<span class="number">2</span>, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> n == name <span class="keyword">then</span></span><br><span class="line">        value = v</span><br><span class="line">        found = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> found <span class="keyword">then</span> <span class="keyword">return</span> value <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- try upvalues</span></span><br><span class="line">    <span class="keyword">local</span> func = <span class="built_in">debug</span>.<span class="built_in">getinfo</span>(<span class="number">2</span>).func</span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">true</span> <span class="keyword">do</span></span><br><span class="line">        <span class="keyword">local</span> n, v = <span class="built_in">debug</span>.<span class="built_in">getupvalue</span>(func, i)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n <span class="keyword">then</span> <span class="keyword">break</span> <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> n == name <span class="keyword">then</span> <span class="keyword">return</span> v <span class="keyword">end</span></span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">-- not found; get global</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getfenv</span>(func)[name]</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h3 id="23-2-hooks"><a href="#23-2-hooks" class="headerlink" title="23.2 hooks"></a>23.2 hooks</h3><p>Lua 使用单个参数调用 hooks，参数为一个描述产生调用的事件：”call”、”return”、”line” 或 “count”。</p>
<p>有四种可以触发一个 hook 的事件：</p>
<ul>
<li>当 Lua 调用一个函数的时候 call 事件发生；</li>
<li>每次函数返回的时候，return 事件发生；</li>
<li>Lua 开始执行代码的新行时候，line 事件发生；</li>
<li>运行指定数目的指令之后，count 事件发生。</li>
</ul>
<blockquote>
<p>C API</p>
</blockquote>
<h2 id="24-C-API-Overview"><a href="#24-C-API-Overview" class="headerlink" title="24. C API Overview"></a>24. C API Overview</h2><p>Lua 解释器是一个使用 Lua 标准库实现的独立的解释器，她是一个很小的应用（总共不超过 500 行的代码）。</p>
<p>解释器负责程序和使用者的接口：<em>从使用者那里获取文件或者字符串，并传给 Lua 标准库，Lua 标准库负责最终的代码运行。</em></p>
<p>第一种，C 作为应用程序语言，Lua 作为一个<strong>库</strong>使用；<br>第二种，反过来，Lua 作为程序语言，C 作为库使用。</p>
<p>C API:<br>    - 读写 Lua 全局变量的函数，<br>    - 调用 Lua 函数的函数，<br>    - 运行 Lua 代码片断的函数，<br>    - 注册 C 函数然后可以在Lua 中被调用的函数，等等。</p>
<p>压栈函数:</p>
<pre><code>- 空值（nil）用 lua_pushnil，
- 数值型（double）用 lua_pushnumber，
- 布尔型（在 C 中用整数表示）用lua_pushboolean，
- 任意的字符串（char*类型，**允许包含&#39;\0&#39;字符**）用 lua_pushlstring，C语言风格（以&#39;\0&#39;结束）的字符串（const char*）用 lua_pushstring：
</code></pre>
<p>Lua 中的字符串不是以零为结束符的；它们依赖于一个明确的长度，因此可以包含任意的二进制数据。<br>Lua 从来不保持一个指向<strong>外部字符串</strong>（或任何其它对象，除了 C 函数——它总是静态指针）的指针。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">int lua_checkstack (lua_State *L, int sz);</span><br></pre></td></tr></table></figure>

<p>lua_isnumber 和 lua_isstring 函数不检查这个值是否是指定的类型，而是看它<strong>是否能被转换成指定的那种类型</strong>。例如，任何数字类型都满足 lua_isstring</p>
<p>lua_type 函数，它返回栈中元素的类型。</p>
<p>给定的元素的类型不正确,lua_toboolean、lua_tonumber 和 lua_strlen 返回 0，其他函数返回 NULL</p>
<p>当一个 C 函数返回后，Lua 会清理他的栈</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *s = lua_tostring(L, <span class="number">-1</span>); <span class="comment">/* any Lua string */</span></span><br><span class="line"><span class="type">size_t</span> l = lua_strlen(L, <span class="number">-1</span>); <span class="comment">/* its length */</span></span><br><span class="line">assert(s[l] == <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line">assert(<span class="built_in">strlen</span>(s) &lt;= l);</span><br></pre></td></tr></table></figure>

<p>函数 lua_gettop 返回堆栈中的元素个数，它也是栈顶元素的索引</p>
<p>一个负数索引-x 对应于正数索引 gettop-x+1。</p>
<p>lua_settop 设置栈顶（也就是堆栈中的元素个数）为一个指定的值。<br>    - 如果开始的栈顶高于新的栈顶，顶部的值被丢弃。<br>    - 否则，为了得到指定的大小这个函数压入相应个数的空值（nil）到栈上。</p>
<p>lua_settop(L,0)清空堆栈。</p>
<p>函数 lua_pushvalue 压入堆栈上指定索引的一个抟贝到栈顶；<br>lua_remove 移除指定索引位置的元素，并将其上面所有的元素下移来填补这个位置的空白；<br>lua_insert 移动栈顶元素到指定索引的位置，并将这个索引位置上面的元素全部上移至栈顶被移动留下的空隔；<br>最后，lua_replace 从栈顶弹出元素值并将其设置到指定索引位置，没有任何移动操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">stackDump</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> top = lua_gettop(L);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=top;i++)&#123; <span class="comment">/*repeatforeachlevel*/</span></span><br><span class="line">        <span class="type">int</span> t = lua_type(L, i);</span><br><span class="line">        <span class="keyword">switch</span> (t) &#123;</span><br><span class="line">        <span class="keyword">case</span> LUA_TSTRING: <span class="comment">/* strings */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;`%s&#x27;&quot;</span>, lua_tostring(L, i));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LUA_TBOOLEAN: <span class="comment">/* booleans */</span></span><br><span class="line">            <span class="built_in">printf</span>(lua_toboolean(L, i) ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LUA_TNUMBER: <span class="comment">/* numbers */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%g&quot;</span>, lua_tonumber(L, i));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">/* other values */</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, lua_typename(L, t)); </span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>); <span class="comment">/* put a separator */</span> &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">/* end the listing */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span> <span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">    lua_State *L = lua_open();</span><br><span class="line">    lua_pushboolean(L, <span class="number">1</span>); lua_pushnumber(L, <span class="number">10</span>);</span><br><span class="line">    lua_pushnil(L); lua_pushstring(L, <span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    stackDump(L);</span><br><span class="line">    <span class="comment">/* true 10 nil `hello&#x27; */</span></span><br><span class="line">    lua_pushvalue(L, <span class="number">-4</span>); stackDump(L);</span><br><span class="line">    <span class="comment">/* true 10 nil `hello&#x27; true */</span></span><br><span class="line">    lua_replace(L, <span class="number">3</span>); stackDump(L);</span><br><span class="line">    <span class="comment">/* true 10 true `hello&#x27; */</span></span><br><span class="line">    lua_settop(L, <span class="number">6</span>); stackDump(L);</span><br><span class="line">    <span class="comment">/* true 10 true `hello&#x27; nil nil */</span></span><br><span class="line">    lua_remove(L, <span class="number">-3</span>); stackDump(L);</span><br><span class="line">    <span class="comment">/* true 10 true nil nil */</span></span><br><span class="line">    lua_settop(L, <span class="number">-5</span>); stackDump(L);</span><br><span class="line">    <span class="comment">/* true */</span></span><br><span class="line">    lua_close(L);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="24-3-C-API-exception-handler"><a href="#24-3-C-API-exception-handler" class="headerlink" title="24.3 C API exception handler"></a>24.3 C API exception handler</h3><p>当我们写一个库代码时（也就是被 Lua 调用的 C 函数）长跳转（long jump）的用处几乎和一个真正的异常处理一样的方便，因为 Lua 抓取了任务偶然的错误。</p>
<p>panic 函数<br>lua_pcall<br>lua_cpcall<br>luaL_error</p>
<h2 id="25-invoking-lua-function"><a href="#25-invoking-lua-function" class="headerlink" title="25. invoking lua function"></a>25. invoking lua function</h2><h2 id="26-invoking-C-function"><a href="#26-invoking-C-function" class="headerlink" title="26. invoking C function"></a>26. invoking C function</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lua_pushcfunction(l, l_sin);</span><br><span class="line">lua_setglobal(l, <span class="string">&quot;mysin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_sin</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    <span class="type">double</span> d = luaL_checknumber(L, <span class="number">1</span>);</span><br><span class="line">    lua_pushnumber(L, <span class="built_in">sin</span>(d));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* number of results */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C函数库</span></span><br><span class="line">LUAMOD_API <span class="type">int</span></span><br><span class="line"><span class="title function_">luaopen_rmq_core</span><span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    luaL_Reg l[] = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;lwrite&quot;</span>, lrmq_write &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;pack&quot;</span>, lrmq_pack &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;unpack&quot;</span>, lrmq_unpack &#125;,</span><br><span class="line">        &#123; <span class="string">&quot;bind&quot;</span>, lrmq_bind &#125;,</span><br><span class="line">        &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    luaL_checkversion(L);</span><br><span class="line">    luaL_newlib(L,l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-user-defined-types-in-C"><a href="#28-user-defined-types-in-C" class="headerlink" title="28. user-defined types in C"></a>28. user-defined types in C</h2><p>接口访问形式:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = array.new(<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">print</span>(a) <span class="comment">--&gt; userdata: 0x8064d48</span></span><br><span class="line"><span class="built_in">print</span>(array.size(a)) <span class="comment">--&gt; 1000</span></span><br><span class="line"><span class="keyword">for</span> i=<span class="number">1</span>,<span class="number">1000</span> <span class="keyword">do</span></span><br><span class="line">array.set(a, i, <span class="number">1</span>/i)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">newarray</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = luaL_checkint(L, <span class="number">1</span>);</span><br><span class="line">    <span class="type">size_t</span> nbytes = <span class="keyword">sizeof</span>(NumArray) + (n - <span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="type">double</span>);</span><br><span class="line">    NumArray *a = (NumArray *)lua_newuserdata(L, nbytes);</span><br><span class="line">    luaL_getmetatable(L, <span class="string">&quot;LuaBook.array&quot;</span>);</span><br><span class="line">    lua_setmetatable(L, <span class="number">-2</span>);</span><br><span class="line">    a-&gt;size = n;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">/* new userdatum is already on the stack */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> NumArray *<span class="title function_">checkarray</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    <span class="type">void</span> *ud = luaL_checkudata(L, <span class="number">1</span>, <span class="string">&quot;LuaBook.array&quot;</span>);</span><br><span class="line">    luaL_argcheck(L, ud != <span class="literal">NULL</span>, <span class="number">1</span>, <span class="string">&quot;`array&#x27; expected&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> (NumArray *)ud;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getsize</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    NumArray *a = checkarray(L);</span><br><span class="line">    lua_pushnumber(L, a-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">double</span> *<span class="title function_">getelem</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    NumArray *a = checkarray(L);</span><br><span class="line">    <span class="type">int</span> index = luaL_checkint(L, <span class="number">2</span>);</span><br><span class="line">    luaL_argcheck(L, <span class="number">1</span> &lt;= index &amp;&amp; index &lt;= a-&gt;size, <span class="number">2</span>,</span><br><span class="line">    <span class="string">&quot;index out of range&quot;</span>);</span><br><span class="line">    <span class="comment">/* return element address */</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a-&gt;values[index - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">setarray</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    <span class="type">double</span> newvalue = luaL_checknumber(L, <span class="number">3</span>);</span><br><span class="line">    *getelem(L) = newvalue;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">getarray</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    lua_pushnumber(L, *getelem(L));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_reg</span> <span class="title">arraylib_f</span> [] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;new&quot;</span>, newarray&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">luaL_reg</span> <span class="title">arraylib_m</span> [] =</span> &#123;</span><br><span class="line">    &#123;<span class="string">&quot;__tostring&quot;</span>, array2string&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;set&quot;</span>, setarray&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;get&quot;</span>, getarray&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;size&quot;</span>, getsize&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">array2string</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    NumArray *a = checkarray(L);</span><br><span class="line">    lua_pushfstring(L, <span class="string">&quot;array(%d)&quot;</span>, a-&gt;size);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">luaopen_array</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    luaL_newmetatable(L, <span class="string">&quot;LuaBook.array&quot;</span>);</span><br><span class="line">    lua_pushstring(L, <span class="string">&quot;__index&quot;</span>);</span><br><span class="line">    lua_pushvalue(L, <span class="number">-2</span>); <span class="comment">/* pushes the metatable */</span></span><br><span class="line">    lua_settable(L, <span class="number">-3</span>); <span class="comment">/* metatable.__index = metatable */</span></span><br><span class="line">    </span><br><span class="line">    luaL_openlib(L, <span class="literal">NULL</span>, arraylib_m, <span class="number">0</span>);</span><br><span class="line">    luaL_openlib(L, <span class="string">&quot;array&quot;</span>, arraylib_f, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>note:<em>luaL_openlib 的另一个特征，第一次调用，当我们传递一个 NULL作为库名时，luaL_openlib 并没有创建任何包含函数的表；相反，他认为封装函数的表在栈内，位于临时的 upvalues 的下面。</em></p>
<p>在这个例子中，封装函数的表是 metatable 本身，也就是 luaL_openlib 放置方法的地方。*</p>
<p>面向对象访问形式:</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">a = array.new(<span class="number">1000</span>)</span><br><span class="line"><span class="built_in">print</span>(a:size()) <span class="comment">--&gt; 1000</span></span><br><span class="line">a:set(<span class="number">10</span>, <span class="number">3.4</span>)</span><br><span class="line"><span class="built_in">print</span>(a:get(<span class="number">10</span>)) <span class="comment">--&gt; 3.4</span></span><br></pre></td></tr></table></figure>

<h2 id="29-resource-managerment-资源管理"><a href="#29-resource-managerment-资源管理" class="headerlink" title="29. resource managerment 资源管理"></a>29. resource managerment 资源管理</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="comment">/* forward declaration for the iterator function */</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dir_iter</span> <span class="params">(lua_State *L)</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">l_dir</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *path = luaL_checkstring(L, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* create a userdatum to store a DIR address */</span></span><br><span class="line">    DIR **d = (DIR **)lua_newuserdata(L, <span class="keyword">sizeof</span>(DIR *));</span><br><span class="line">    <span class="comment">/* set its metatable */</span></span><br><span class="line">    luaL_getmetatable(L, <span class="string">&quot;LuaBook.dir&quot;</span>);</span><br><span class="line">    lua_setmetatable(L, <span class="number">-2</span>);</span><br><span class="line">    <span class="comment">/* try to open the given directory */</span></span><br><span class="line">    *d = opendir(path);</span><br><span class="line">    <span class="keyword">if</span> (*d == <span class="literal">NULL</span>) <span class="comment">/* error opening the directory? */</span></span><br><span class="line">    luaL_error(L, <span class="string">&quot;cannot open %s: %s&quot;</span>, path,</span><br><span class="line">    strerror(errno));</span><br><span class="line">    <span class="comment">/* creates and returns the iterator function</span></span><br><span class="line"><span class="comment">        (its sole upvalue, the directory userdatum,</span></span><br><span class="line"><span class="comment">        is already on the stack top */</span></span><br><span class="line">    lua_pushcclosure(L, dir_iter, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dir_iter</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    DIR *d = *(DIR **)lua_touserdata(L, lua_upvalueindex(<span class="number">1</span>));</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> *<span class="title">entry</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((entry = readdir(d)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    lua_pushstring(L, entry-&gt;d_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* no more values to return */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">dir_gc</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    DIR *d = *(DIR **)lua_touserdata(L, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (d) closedir(d);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">luaopen_dir</span> <span class="params">(lua_State *L)</span> &#123;</span><br><span class="line">    luaL_newmetatable(L, <span class="string">&quot;LuaBook.dir&quot;</span>);</span><br><span class="line">    <span class="comment">/* set its __gc field */</span></span><br><span class="line">    lua_pushstring(L, <span class="string">&quot;__gc&quot;</span>);</span><br><span class="line">    lua_pushcfunction(L, dir_gc);</span><br><span class="line">    lua_settable(L, <span class="number">-3</span>);</span><br><span class="line">    <span class="comment">/* register the `dir&#x27; function */</span></span><br><span class="line">    lua_pushcfunction(L, l_dir);</span><br><span class="line">    lua_setglobal(L, <span class="string">&quot;dir&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Lua-版本更新记录"><a href="#Lua-版本更新记录" class="headerlink" title="Lua 版本更新记录"></a>Lua 版本更新记录</h2><h3 id="中文版"><a href="#中文版" class="headerlink" title="中文版"></a>中文版</h3><h4 id="自-Lua-5-3-以来的变化"><a href="#自-Lua-5-3-以来的变化" class="headerlink" title="自 Lua 5.3 以来的变化"></a>自 Lua 5.3 以来的变化</h4><p>以下是 Lua 5.4 引入的主要变化。参考手册列出了必须引入的不兼容性。</p>
<h5 id="主要变化"><a href="#主要变化" class="headerlink" title="主要变化"></a>主要变化</h5><ul>
<li>垃圾收集的新生代模式(新方法 意味着更频繁地启动较短的跟踪，仅涵盖最近创建的对象。 仅在短暂的爬网之后无法达到所需的内存消耗指标时，才执行所有对象的完全爬网。 这种方法可实现更高的性能和更低的内存消耗 在存储大量存在时间短的对象的情况下。)</li>
<li>待关闭变量</li>
<li>常量变量</li>
<li>userdata 可以有多个用户值</li>
<li>math.random 的新实现</li>
<li>警告系统</li>
<li>关于函数参数和返回值的调试信息</li>
<li>整数 ‘for’ 循环的新语义</li>
<li>可选的 ‘init’ 参数用于 ‘string.gmatch’</li>
<li>新函数 ‘lua_resetthread’ 和 ‘coroutine.close’</li>
<li>字符串到数字的强制转换移至字符串库</li>
<li>当缩小内存块时，允许分配函数失败</li>
<li>‘string.format’ 中的新格式 ‘%p’</li>
<li>utf8 库接受最多 2^31 的代码点</li>
</ul>
<h4 id="自-Lua-5-2-以来的变化"><a href="#自-Lua-5-2-以来的变化" class="headerlink" title="自 Lua 5.2 以来的变化"></a>自 Lua 5.2 以来的变化</h4><p>以下是 Lua 5.3 引入的主要变化。参考手册列出了必须引入的不兼容性。</p>
<h5 id="主要变化-1"><a href="#主要变化-1" class="headerlink" title="主要变化"></a>主要变化</h5><ul>
<li>整数（默认 64 位）</li>
<li>官方支持 32 位数字</li>
<li>位运算符</li>
<li>基本的 utf-8 支持</li>
<li>用于打包和解包值的函数</li>
<li>以下是 Lua 5.3 引入的其他变化：</li>
</ul>
<h5 id="语言"><a href="#语言" class="headerlink" title="语言"></a>语言</h5><ul>
<li>userdata 可以有任何 Lua 值作为用户值</li>
<li>向下取整除法</li>
<li>一些元方法的更灵活规则</li>
</ul>
<h5 id="库"><a href="#库" class="headerlink" title="库"></a>库</h5><ul>
<li>ipairs 和 table 库尊重元方法</li>
<li>string.dump 中的 strip 选项</li>
<li>table 库尊重元方法</li>
<li>新函数 table.move</li>
<li>新函数 string.pack</li>
<li>新函数 string.unpack</li>
<li>新函数 string.packsize</li>
</ul>
<h5 id="C-API"><a href="#C-API" class="headerlink" title="C API"></a>C API</h5><ul>
<li>更简单的 C 中的延续函数 API</li>
<li>lua_gettable 和类似函数返回结果值的类型</li>
<li>lua_dump 中的 strip 选项</li>
<li>新函数：lua_geti</li>
<li>新函数：lua_seti</li>
<li>新函数：lua_isyieldable</li>
<li>新函数：lua_numbertointeger</li>
<li>新函数：lua_rotate</li>
<li>新函数：lua_stringtonumber</li>
</ul>
<h5 id="Lua-独立解释器"><a href="#Lua-独立解释器" class="headerlink" title="Lua 独立解释器"></a>Lua 独立解释器</h5><ul>
<li>可用作计算器；无需前缀 ‘&#x3D;’</li>
<li>arg 表对所有代码可用</li>
</ul>
<h4 id="自-Lua-5-1-以来的变化"><a href="#自-Lua-5-1-以来的变化" class="headerlink" title="自 Lua 5.1 以来的变化"></a>自 Lua 5.1 以来的变化</h4><p>以下是 Lua 5.2 引入的主要变化。参考手册列出了必须引入的不兼容性。</p>
<h5 id="主要变化-2"><a href="#主要变化-2" class="headerlink" title="主要变化"></a>主要变化</h5><ul>
<li>可挂起的 pcall 和元方法</li>
<li>全局变量的新词法方案</li>
<li>短命表</li>
<li>位运算的新库</li>
<li>轻量级 C 函数</li>
<li>紧急垃圾收集器</li>
<li>goto 语句</li>
<li>表的终结器<br>以下是 Lua 5.2 引入的其他变化：</li>
</ul>
<h5 id="语言-1"><a href="#语言-1" class="headerlink" title="语言"></a>语言</h5><ul>
<li>线程或函数不再有 fenv</li>
<li>表尊重 __len 元方法</li>
<li>字符串中的十六进制和 \z 转义</li>
<li>支持十六进制浮点数</li>
<li>不同类型的顺序元方法</li>
<li>不再验证操作码一致性</li>
<li>钩子事件 “tail return” 被 “tail call” 取代</li>
<li>空语句</li>
<li>break 语句可以出现在块的中间</li>
</ul>
<h5 id="库-1"><a href="#库-1" class="headerlink" title="库"></a>库</h5><ul>
<li>通过 xpcall 调用的函数的参数</li>
<li>load 和 loadfile 的可选 ‘mode’ 参数（控制二进制 x 文本）</li>
<li>load 和 loadfile 的可选 ‘env’ 参数（加载块的环境）</li>
<li>loadlib 可以加载具有全局名称的库（RTLD_GLOBAL）</li>
<li>新函数 package.searchpath</li>
<li>模块加载时接收它们的路径</li>
<li>math.log 中的可选基数</li>
<li>string.rep 中的可选分隔符</li>
<li>file:write 返回文件</li>
<li>关闭管道返回退出状态</li>
<li>os.exit 可以关闭状态</li>
<li>新元方法 __pairs 和 __ipairs</li>
<li>collectgarbage 和 lua_gc 的新选项 ‘isrunning’</li>
<li>边界模式</li>
<li>模式中的 \0</li>
<li>io.read 的新选项 *L</li>
<li>io.lines 的选项</li>
<li>debug.getlocal 可以访问函数的可变参数</li>
</ul>
<h5 id="C-API-1"><a href="#C-API-1" class="headerlink" title="C API"></a>C API</h5><ul>
<li>注册表中预定义的主线程</li>
<li>新函数 lua_absindex, lua_arith, lua_compare, lua_copy, lua_len, lua_rawgetp, lua_rawsetp, lua_upvalueid, lua_upvaluejoin, lua_version.</li>
<li>新函数 luaL_checkversion, luaL_setmetatable, luaL_testudata, luaL_tolstring.</li>
<li>lua_pushstring 和 pushlstring 返回字符串</li>
<li>debug API 中可用的 nparams 和 isvararg</li>
<li>新的 lua_Unsigned</li>
</ul>
<h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><ul>
<li>每个函数的最大常量提高到 226</li>
<li>垃圾收集的代际模式（实验性）</li>
<li>NaN 技巧（实验性）</li>
<li>ctypes 的内部（不可变）版本</li>
<li>字符串缓冲区的更简单实现</li>
<li>解析器使用更少的 C 栈空间（不再有自动数组）</li>
</ul>
<h5 id="Lua-独立解释器-1"><a href="#Lua-独立解释器-1" class="headerlink" title="Lua 独立解释器"></a>Lua 独立解释器</h5><ul>
<li>新的 -E 选项以避免环境变量</li>
<li>处理非字符串错误消息</li>
</ul>
<h3 id="英文原版"><a href="#英文原版" class="headerlink" title="英文原版"></a>英文原版</h3><h4 id="Changes-since-Lua-5-3"><a href="#Changes-since-Lua-5-3" class="headerlink" title="Changes since Lua 5.3"></a>Changes since Lua 5.3</h4><p>Here are the main changes introduced in Lua 5.4. The reference manual lists the incompatibilities that had to be introduced.</p>
<h5 id="Main-changes"><a href="#Main-changes" class="headerlink" title="Main changes"></a>Main changes</h5><ul>
<li>new generational mode for garbage collection</li>
<li>to-be-closed variables</li>
<li>const variables</li>
<li>userdata can have multiple user values</li>
<li>new implementation for math.random</li>
<li>warning system</li>
<li>debug information about function arguments and returns</li>
<li>new semantics for the integer ‘for’ loop</li>
<li>optional ‘init’ argument to ‘string.gmatch’</li>
<li>new functions ‘lua_resetthread’ and ‘coroutine.close’</li>
<li>string-to-number coercions moved to the string library</li>
<li>allocation function allowed to fail when shrinking a memory block</li>
<li>new format ‘%p’ in ‘string.format’</li>
<li>utf8 library accepts codepoints up to 2^31</li>
</ul>
<h4 id="Changes-since-Lua-5-2"><a href="#Changes-since-Lua-5-2" class="headerlink" title="Changes since Lua 5.2"></a>Changes since Lua 5.2</h4><p>Here are the main changes introduced in Lua 5.3. The reference manual lists the incompatibilities that had to be introduced.</p>
<h5 id="Main-changes-1"><a href="#Main-changes-1" class="headerlink" title="Main changes"></a>Main changes</h5><ul>
<li>integers (64-bit by default)</li>
<li>official support for 32-bit numbers</li>
<li>bitwise operators</li>
<li>basic utf-8 support</li>
<li>functions for packing and unpacking values</li>
<li>Here are the other changes introduced in Lua 5.3:</li>
</ul>
<h5 id="Language"><a href="#Language" class="headerlink" title="Language"></a>Language</h5><ul>
<li>userdata can have any Lua value as uservalue</li>
<li>floor division</li>
<li>more flexible rules for some metamethods</li>
</ul>
<h5 id="Libraries"><a href="#Libraries" class="headerlink" title="Libraries"></a>Libraries</h5><ul>
<li>ipairs and the table library respect metamethods</li>
<li>strip option in string.dump</li>
<li>table library respects metamethods</li>
<li>new function table.move</li>
<li>new function string.pack</li>
<li>new function string.unpack</li>
<li>new function string.packsize</li>
</ul>
<h5 id="C-API-2"><a href="#C-API-2" class="headerlink" title="C API"></a>C API</h5><ul>
<li>simpler API for continuation functions in C</li>
<li>lua_gettable and similar functions return type of resulted value</li>
<li>strip option in lua_dump</li>
<li>new function: lua_geti</li>
<li>new function: lua_seti</li>
<li>new function: lua_isyieldable</li>
<li>new function: lua_numbertointeger</li>
<li>new function: lua_rotate</li>
<li>new function: lua_stringtonumber</li>
</ul>
<h5 id="Lua-standalone-interpreter"><a href="#Lua-standalone-interpreter" class="headerlink" title="Lua standalone interpreter"></a>Lua standalone interpreter</h5><ul>
<li>can be used as calculator; no need to prefix with ‘&#x3D;’</li>
<li>arg table available to all code</li>
</ul>
<h4 id="Changes-since-Lua-5-1"><a href="#Changes-since-Lua-5-1" class="headerlink" title="Changes since Lua 5.1"></a>Changes since Lua 5.1</h4><p>Here are the main changes introduced in Lua 5.2. The reference manual lists the incompatibilities that had to be introduced.</p>
<h5 id="Main-changes-2"><a href="#Main-changes-2" class="headerlink" title="Main changes"></a>Main changes</h5><ul>
<li>yieldable pcall and metamethods</li>
<li>new lexical scheme for globals</li>
<li>ephemeron tables</li>
<li>new library for bitwise operations</li>
<li>light C functions</li>
<li>emergency garbage collector</li>
<li>goto statement</li>
<li>finalizers for tables<br>Here are the other changes introduced in Lua 5.2:</li>
</ul>
<h5 id="Language-1"><a href="#Language-1" class="headerlink" title="Language"></a>Language</h5><ul>
<li>no more fenv for threads or functions</li>
<li>tables honor the __len metamethod</li>
<li>hex and \z escapes in strings</li>
<li>support for hexadecimal floats</li>
<li>order metamethods work for different types</li>
<li>no more verification of opcode consistency</li>
<li>hook event “tail return” replaced by “tail call”</li>
<li>empty statement</li>
<li>break statement may appear in the middle of a block</li>
</ul>
<h5 id="Libraries-1"><a href="#Libraries-1" class="headerlink" title="Libraries"></a>Libraries</h5><ul>
<li>arguments for function called through xpcall</li>
<li>optional ‘mode’ argument to load and loadfile (to control binary x text)</li>
<li>optional ‘env’ argument to load and loadfile (environment for loaded chunk)</li>
<li>loadlib may load libraries with global names (RTLD_GLOBAL)</li>
<li>new function package.searchpath</li>
<li>modules receive their paths when loaded</li>
<li>optional base in math.log</li>
<li>optional separator in string.rep</li>
<li>file:write returns file</li>
<li>closing a pipe returns exit status</li>
<li>os.exit may close state</li>
<li>new metamethods __pairs and __ipairs</li>
<li>new option ‘isrunning’ for collectgarbage and lua_gc</li>
<li>frontier patterns</li>
<li>\0 in patterns</li>
<li>new option *L for io.read</li>
<li>options for io.lines</li>
<li>debug.getlocal can access function varargs</li>
</ul>
<h5 id="C-API-3"><a href="#C-API-3" class="headerlink" title="C API"></a>C API</h5><ul>
<li>main thread predefined in the registry</li>
<li>new functions lua_absindex, lua_arith, lua_compare, lua_copy, lua_len, lua_rawgetp, lua_rawsetp, lua_upvalueid, lua_upvaluejoin, lua_version.</li>
<li>new functions luaL_checkversion, luaL_setmetatable, luaL_testudata, luaL_tolstring.</li>
<li>lua_pushstring and pushlstring return string</li>
<li>nparams and isvararg available in debug API</li>
<li>new lua_Unsigned</li>
</ul>
<h5 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h5><ul>
<li>max constants per function raised to 226</li>
<li>generational mode for garbage collection (experimental)</li>
<li>NaN trick (experimental)</li>
<li>internal (immutable) version of ctypes</li>
<li>simpler implementation for string buffers</li>
<li>parser uses much less C-stack space (no more auto arrays)</li>
</ul>
<h5 id="Lua-standalone-interpreter-1"><a href="#Lua-standalone-interpreter-1" class="headerlink" title="Lua standalone interpreter"></a>Lua standalone interpreter</h5><ul>
<li>new -E option to avoid environment variables</li>
<li>handling of non-string error messages</li>
</ul>
<h2 id="Lua-5-4-版本更新"><a href="#Lua-5-4-版本更新" class="headerlink" title="Lua 5.4 版本更新"></a>Lua 5.4 版本更新</h2><p>Lua5.4已经进入rc(Release Candidate)状态，相信很快就会发布正式版。这个版本在语言层面上修改的东西并不多，但是默认的GC被换成了“分代式GC”，这对于那些经常产生短期对象的程序应该会有很明显的性能提升。GC带来的负担永远是自动内存管理语言的一大痛点，如果能在这一点上取得突破，那肯定比提供更多语法糖来得有价值。</p>
<p>此外5.4可以指定局部变量的属性，用这样的语法：</p>
<p>local a <NAME> &#x3D; 3<br>NAME可以是const或close，为const时表示const变量(const variables)，const变量可以帮助编译器作一些优化，比如下面的代码：</p>
<p>local a <const> &#x3D; 4<br>local b &#x3D; a + 7<br>print(b)<br>编译器会把a消除掉，直接给b赋11。这种优化是有限的，对于基本类型和字符串，能够有效减少寄存器的访问，但对于table貌似益处不大。代码文件如果需要一些数值常量，可以写成const变量，比如：</p>
<p>local MAX_LEN <const> &#x3D; 20<br>function check_name(name)<br>    return #name &lt;&#x3D; MAX_LEN<br>end<br>在check_name中就没有upvalue的访问，而是直接转换成和20的比较。</p>
<p>close变量(To-be-closed Variables)需要和close元方法结合使用，在变量超出作用域时，会调用变量的close元方法，这听起来是不是有点像C++的RAII用法。下面是一个例子：</p>
<p>local function newlock()<br>    local lock &#x3D; {<br>        acquire &#x3D; function()<br>            print(“acquire lock”)<br>        end,<br>        release &#x3D; function()<br>            print(“release lock”)<br>        end,<br>    }<br>    return lock<br>end</p>
<p>local function lockguard(lock)<br>    local wrap &#x3D; {<br>        lock &#x3D; lock<br>    }<br>    lock.acquire()<br>    return setmetatable(wrap, {__close &#x3D; function(t, err)<br>        t.lock.release()<br>    end})<br>end</p>
<p>local lock &#x3D; newlock()<br>do<br>    for i &#x3D; 1, 3 do<br>        local l <close> &#x3D; lockguard(lock)<br>        print(i)<br>        error(“err”)<br>    end<br>end<br>定义local l <close>后，无论是否有错误，release都能得到调用；从这个例子也可以看出，close变量一般用于需要及时释放资源的情况；否则Lua的GC可以应付大多数情况。</p>
<p>除了上面提到的特性，还有一些新的修改罗列如下：</p>
<p>userdata现在可以关联多个user值，C的API也有相应的修改，如果我们新建的userdata没有关联值，则尽量使用lua_newuserdatauv，这样更高效，lua_newuserdata仅仅为了兼容，且默认会关联1个值。<br>math.random使用了新的算法。<br>协程库提供了新的APIcoroutine.close和lua_resetthread，coroutine.close只能在挂起或死亡状态下调用，挂起状态下会使用协程进入死亡状态，并且关闭所有的close变量。</p>
]]></content>
      <tags>
        <tag>lua</tag>
      </tags>
  </entry>
  <entry>
    <title>大话数据结构 读书笔记</title>
    <url>/2025/03/17/%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="大话数据结构-读书笔记"><a href="#大话数据结构-读书笔记" class="headerlink" title="大话数据结构 读书笔记"></a>大话数据结构 读书笔记</h1><h2 id="1-绪论"><a href="#1-绪论" class="headerlink" title="1. 绪论"></a>1. 绪论</h2><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><ul>
<li>集合结构</li>
<li>线性结构</li>
<li>树形结构</li>
<li>图形结构</li>
</ul>
<h3 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h3><ul>
<li>顺序存储结构</li>
<li>链接存储结构</li>
</ul>
<h2 id="2-算法"><a href="#2-算法" class="headerlink" title="2. 算法"></a>2. 算法</h2><h3 id="算法特征"><a href="#算法特征" class="headerlink" title="算法特征"></a>算法特征</h3><ul>
<li>输入输出</li>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
</ul>
<h3 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h3><h4 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶 O(1)"></a>常数阶 O(1)</h4><h4 id="线性阶-O-n"><a href="#线性阶-O-n" class="headerlink" title="线性阶 O(n)"></a>线性阶 O(n)</h4><h4 id="对数阶-O-logn"><a href="#对数阶-O-logn" class="headerlink" title="对数阶 O(logn)"></a>对数阶 O(logn)</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> count =<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(count &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">    count = count * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>${2^x} &#x3D; n &#x3D;&gt; x &#x3D; log_2n$</p>
<h4 id="平方阶-O-n-2"><a href="#平方阶-O-n-2" class="headerlink" title="平方阶 $O({n^2})$"></a>平方阶 $O({n^2})$</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (j= <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="comment">/* 时 间 复 杂 度 为 0(1) 的 程序 步骤 序 列 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> i,j;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt;n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (j =i; j &lt;n; j++) <span class="comment">/* 注意j = i 而不 是0 */</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 时间 复 杂 度为0(1) HBRP RAR */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>$n+(n-1)+(n-2)+{\cdots}+1 &#x3D;\frac{n(n+1)}{2}&#x3D;\frac{n^2}{2}+\frac{n}{2}$</p>
<p>$O(n^2)$</p>
<h4 id="常见时间复杂度"><a href="#常见时间复杂度" class="headerlink" title="常见时间复杂度"></a>常见时间复杂度</h4><p>$O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n)&lt; O(n!) &lt; O(n^n)$</p>
<h2 id="3-线性表"><a href="#3-线性表" class="headerlink" title="3. 线性表"></a>3. 线性表</h2><hr>
<p>Here is a footnote reference,[^1] and another.[^longnote]</p>
<h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>[^1]: Here is the footnote.<br>[^longnote]: Here’s one with multiple blocks.</p>
]]></content>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>加密货币学习</title>
    <url>/2025/03/18/%E5%8A%A0%E5%AF%86%E8%B4%A7%E5%B8%81%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a>加密货币学习</h1><h2 id="交易所手续费"><a href="#交易所手续费" class="headerlink" title="交易所手续费"></a><a href="https://www.528btc.com/tk/1688961172104610.html">交易所手续费</a></h2><p>泰达币手续费最低的交易所<br>在当前市场上，有许多交易所提供泰达币的交易服务。然而，手续费率因交易所而异。根据我们的调研，以下是一些手续费较低的泰达币交易所：</p>
<ol>
<li>Binance：作为全球最大的加密货币交易所之一，Binance提供了低手续费的交易环境。该交易所在泰达币交易中收取每笔交易0.1%的手续费。此外，Binance还为持有其平台原生代币BNB的用户提供了更低的交易手续费。 </li>
<li>Huobi：Huobi是另一家知名的加密货币交易所，在泰达币交易中手续费较低。该交易所收取每笔交易0.2%的手续费，并可提供更低的费率给持有其平台代币HT的用户。 </li>
<li>OKEx：OKEx是全球领先的数字资产交易平台之一，手续费相对较低。该交易所在泰达币交易中收取每笔交易0.1%的手续费，并可提供更低的费率给持有其平台代币OKB的用户。 </li>
<li>Kraken：Kraken是一家总部位于美国的知名加密货币交易所，手续费相对较低。该交易所在泰达币交易中收取每笔交易0.16%~0.26%的手续费，费率根据交易量的不同而有所差异。</li>
</ol>
<h2 id="交易所"><a href="#交易所" class="headerlink" title="交易所"></a>交易所</h2><h3 id="bitkan"><a href="#bitkan" class="headerlink" title="bitkan"></a><a href="https://bitkan.com/zh">bitkan</a></h3><h3 id="火币"><a href="#火币" class="headerlink" title="火币"></a><a href="https://www.htx.com.pk/zh-cn/">火币</a></h3><h3 id="币安"><a href="#币安" class="headerlink" title="币安"></a><a href="https://www.binance.com/">币安</a></h3><h3 id="gate-io-学习文档"><a href="#gate-io-学习文档" class="headerlink" title="gate.io 学习文档"></a><a href="https://www.gate.io/zh/futures/trading-guide-for-beginners">gate.io 学习文档</a></h3><h4 id="什么是加密货币合约"><a href="#什么是加密货币合约" class="headerlink" title="什么是加密货币合约"></a><a href="https://www.gate.io/zh/learn/course/gateio-contracts-trading-guide-a-must-read-for-newbies">什么是加密货币合约</a></h4><h3 id="bitget"><a href="#bitget" class="headerlink" title="bitget"></a><a href="https://www.bitget.com/zh-TC/">bitget</a></h3><h3 id="欧易"><a href="#欧易" class="headerlink" title="欧易"></a><a href="https://www.okx.com/zh-hans">欧易</a></h3><h4 id="欧易合约指南"><a href="#欧易合约指南" class="headerlink" title="欧易合约指南"></a><a href="https://www.okx.com/zh-hans/learn">欧易合约指南</a></h4><h3 id="cryptomus"><a href="#cryptomus" class="headerlink" title="cryptomus"></a><a href="https://cryptomus.com/zh">cryptomus</a></h3><h3 id="gemwallet"><a href="#gemwallet" class="headerlink" title="gemwallet"></a><a href="https://gemwallet.com/zh-cn/usdt-wallet/">gemwallet</a></h3><h3 id="kraken"><a href="#kraken" class="headerlink" title="kraken"></a><a href="https://www.kraken.com/zh-cn">kraken</a></h3><h3 id="BNB-chain"><a href="#BNB-chain" class="headerlink" title="BNB chain"></a><a href="https://www.bnbchain.org/zh-CN/what-is-bnb">BNB chain</a></h3><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><a href="https://www.120btc.com/baike/qukuai/378511109.html"></a></h4><h2 id="电竞竞猜-可以用加密货币吗"><a href="#电竞竞猜-可以用加密货币吗" class="headerlink" title="电竞竞猜 可以用加密货币吗"></a>电竞竞猜 可以用加密货币吗</h2><p>Here is a footnote reference,[^1] and another.[^longnote]</p>
<h2 id="Endnotes"><a href="#Endnotes" class="headerlink" title="Endnotes"></a>Endnotes</h2><p>[^1]: Here is the footnote.<br>[^longnote]: Here’s one with multiple blocks.</p>
]]></content>
  </entry>
</search>
