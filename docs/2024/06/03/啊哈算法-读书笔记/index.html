<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>啊哈算法 读书笔记 | Zepung🐉Blog</title><meta name="author" content="チャン ゼプン"><meta name="copyright" content="チャン ゼプン"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="啊哈算法 读书笔记  《啊哈算法》源码 &gt; 啊哈算法》第八章源码       [{&quot;url&quot;:&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;Fze9jchtnyJXMHN.jpg&quot;,&quot;alt&quot;:&quot;&quot;,&quot;title&quot;:&quot;&quot;},{&quot;url&quot;:&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;ryLVePaqkYm4TEK.jpg&quot;,&quot;alt&quot;:&quot;&quot;,&quot;title&quot;:&quot;">
<meta property="og:type" content="article">
<meta property="og:title" content="啊哈算法 读书笔记">
<meta property="og:url" content="https://zirpon.github.io/2024/06/03/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Zepung🐉Blog">
<meta property="og:description" content="啊哈算法 读书笔记  《啊哈算法》源码 &gt; 啊哈算法》第八章源码       [{&quot;url&quot;:&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;Fze9jchtnyJXMHN.jpg&quot;,&quot;alt&quot;:&quot;&quot;,&quot;title&quot;:&quot;&quot;},{&quot;url&quot;:&quot;https:&#x2F;&#x2F;i.loli.net&#x2F;2019&#x2F;12&#x2F;25&#x2F;ryLVePaqkYm4TEK.jpg&quot;,&quot;alt&quot;:&quot;&quot;,&quot;title&quot;:&quot;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zirpon.github.io/img/header_img/th%20(3).jpg">
<meta property="article:published_time" content="2024-06-03T09:18:12.000Z">
<meta property="article:modified_time" content="2025-06-01T06:48:07.740Z">
<meta property="article:author" content="チャン ゼプン">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="读书">
<meta property="article:tag" content="排序">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zirpon.github.io/img/header_img/th%20(3).jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "啊哈算法 读书笔记",
  "url": "https://zirpon.github.io/2024/06/03/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/",
  "image": "https://zirpon.github.io/img/header_img/th%20(3).jpg",
  "datePublished": "2024-06-03T09:18:12.000Z",
  "dateModified": "2025-06-01T06:48:07.740Z",
  "author": [
    {
      "@type": "Person",
      "name": "チャン ゼプン",
      "url": "https://zirpon.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/timg.jpeg"><link rel="canonical" href="https://zirpon.github.io/2024/06/03/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '啊哈算法 读书笔记',
  isHighlightShrink: true,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="web_bg" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/IMG_5015.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">27</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">70</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/header_img/th (3).jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/timg.jpeg" alt="Logo"><span class="site-name">Zepung🐉Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">啊哈算法 读书笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">啊哈算法 读书笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-03T09:18:12.000Z" title="发表于 2024-06-03 17:18:12">2024-06-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-01T06:48:07.740Z" title="更新于 2025-06-01 14:48:07">2025-06-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>64分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>啊哈算法 读书笔记</h1>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/chenchen-cs/Aha-algorithm/">《啊哈算法》源码</a> &gt; <a target="_blank" rel="noopener" href="https://github.com/OctopusLian/AhaAlgorithms/">啊哈算法》第八章源码</a></p>
</blockquote>
<div class="gallery-container" data-type="data" data-button data-limit="10" data-first="10">
    <div class="gallery-items">[{"url":"https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg","alt":"","title":""},{"url":"https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg","alt":"","title":""}]</div>
  </div>
<h2 id="第-1-章-一大波数正在靠近-排序-1"><a class="header-anchor" href="#第-1-章-一大波数正在靠近-排序-1">🌳</a>第 1 章 一大波数正在靠近——排序 1</h2>
<h3 id="第-1-节-最帛最简单的排序-桶排序-2"><a class="header-anchor" href="#第-1-节-最帛最简单的排序-桶排序-2">🌳</a>第 1 节 最帛最简单的排序——桶排序 2</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bucketSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">            max = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> bucket[max + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        bucket[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        bucket[arr[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt;= max; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (bucket[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            arr[j++] = i;</span><br><span class="line">            bucket[i]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    bucketSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-2-节-邻居好说话-冒泡排序-7"><a class="header-anchor" href="#第-2-节-邻居好说话-冒泡排序-7">🌳</a>第 2 节 邻居好说话——冒泡排序 7</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, temp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="comment">// 交换 arr[j] 和 arr[j + 1]</span></span><br><span class="line">                temp = arr[j];</span><br><span class="line">                arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> n = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    bubbleSort(arr, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-3-节-最常用的排序-快速排序"><a class="header-anchor" href="#第-3-节-最常用的排序-快速排序">🌳</a>第 3 节 最常用的排序——快速排序</h3>
<p>|基准-&gt;   mid   &lt;-|<br>
|mid-&gt;   基准|   &lt;-|</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">101</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j, t, temp;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span>;</span><br><span class="line">    temp = a[left];</span><br><span class="line">    i = left;</span><br><span class="line">    j = right;</span><br><span class="line">    <span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (a[j] &gt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            j--;</span><br><span class="line">        <span class="keyword">while</span> (a[i] &lt;= temp &amp;&amp; i &lt; j)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            t = a[i];</span><br><span class="line">            a[i] = a[j];</span><br><span class="line">            a[j] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[left] = a[i];</span><br><span class="line">    a[i] = temp;</span><br><span class="line"></span><br><span class="line">    quicksort(left, i - <span class="number">1</span>);</span><br><span class="line">    quicksort(i + <span class="number">1</span>, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组的大小：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入数组元素：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quicksort(<span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;排序后的数组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-4-节-小哼买书-20"><a class="header-anchor" href="#第-4-节-小哼买书-20">🌳</a>第 4 节 小哼买书 20</h3>
<blockquote>
<p>在粗略计算时间复杂度的时候，我们通常认为计算机每秒钟大约运行 10 亿次（当然实际情况要更快）。<br>
桶排序是昀快的，它的时间复杂度是 O(N+M)；冒泡排序是 O(N 2 )；快速排序是 O(NlogN)</p>
</blockquote>
<h2 id="第-2-章-栈-队列-链表"><a class="header-anchor" href="#第-2-章-栈-队列-链表">🌳</a>第 2 章 栈、队列、链表</h2>
<h3 id="第-1-节-解密-qq-号-队列"><a class="header-anchor" href="#第-1-节-解密-qq-号-队列">🌳</a>第 1 节 解密 QQ 号——队列</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data[<span class="number">100</span>]; <span class="comment">// 队列的主体，用来存储内容</span></span><br><span class="line">    <span class="type">int</span> head;      <span class="comment">// 队首</span></span><br><span class="line">    <span class="type">int</span> tail;      <span class="comment">// 队尾</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">queue</span> <span class="title">q</span>;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 初始刖队列</span></span><br><span class="line">    q.head = <span class="number">1</span>;</span><br><span class="line">    q.tail = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 依次向队列插入9个数</span></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q.data[q.tail]);</span><br><span class="line">        q.tail++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (q.head &lt; q.tail) <span class="comment">// 当队列不为空的时候执行循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打印队首并将队首出队</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, q.data[q.head]);</span><br><span class="line">        q.head++;</span><br><span class="line">        <span class="comment">// 先将新队首的数添加到队尾</span></span><br><span class="line">        q.data[q.tail] = q.data[q.head];</span><br><span class="line">        q.tail++;</span><br><span class="line">        <span class="comment">// 再将队首出队</span></span><br><span class="line">        q.head++;</span><br><span class="line">    &#125;</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-2-节-解密回文-栈"><a class="header-anchor" href="#第-2-节-解密回文-栈">🌳</a>第 2 节 解密回文——栈</h3>
<h3 id="第-3-节-纸牌游戏-小猫钓鱼-35"><a class="header-anchor" href="#第-3-节-纸牌游戏-小猫钓鱼-35">🌳</a>第 3 节 纸牌游戏——小猫钓鱼 35</h3>
<h3 id="第-4-节-链表"><a class="header-anchor" href="#第-4-节-链表">🌳</a>第 4 节 链表</h3>
<h3 id="第-5-节-模拟链表-54"><a class="header-anchor" href="#第-5-节-模拟链表-54">🌳</a>第 5 节 模拟链表 54</h3>
<h2 id="第-3-章-枚举-廱暴力-57"><a class="header-anchor" href="#第-3-章-枚举-廱暴力-57">🌳</a>第 3 章 枚举！廱暴力 57</h2>
<h3 id="第-1-节-坑爹的奥数-58"><a class="header-anchor" href="#第-1-节-坑爹的奥数-58">🌳</a>第 1 节 坑爹的奥数 58</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>];</span><br><span class="line">book[<span class="number">10</span>], total = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 定义深度优先搜索函数，用于生成符合加法运算规则的数字组合</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> step)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果递归到了第10步，即生成了一个完整的数字序列</span></span><br><span class="line">    <span class="keyword">if</span> (step == <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断前六个数字组成的数加上第七个数字是否等于后三个数字组成的数</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">1</span>] * <span class="number">100</span> + a[<span class="number">2</span>] * <span class="number">10</span> + a[<span class="number">3</span>] + a[<span class="number">4</span>] * <span class="number">100</span> + a[<span class="number">5</span>] * <span class="number">10</span> + a[<span class="number">6</span>] == a[<span class="number">7</span>] * <span class="number">100</span> + a[<span class="number">8</span>] * <span class="number">10</span> + a[<span class="number">9</span>]) &#123;</span><br><span class="line">            total++; <span class="comment">// 满足条件的组合数加一</span></span><br><span class="line">            <span class="comment">// 输出当前满足条件的组合</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d%d%d+%d%d%d=%d%d%d\n&quot;</span>, a[<span class="number">1</span>], a[<span class="number">2</span>], a[<span class="number">3</span>], a[<span class="number">4</span>], a[<span class="number">5</span>], a[<span class="number">6</span>], a[<span class="number">7</span>], a[<span class="number">8</span>], a[<span class="number">9</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 返回上一层递归</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有数字（1-9）</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (book[i] == <span class="number">0</span>) &#123; <span class="comment">// 判断当前数字是否可用</span></span><br><span class="line">            a[step] = i; <span class="comment">// 将当前数字放入数组的当前位置</span></span><br><span class="line">            book[i] = <span class="number">1</span>; <span class="comment">// 标记当前数字已使用</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 进入下一层递归，生成下一个数字序列</span></span><br><span class="line">            dfs(step + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            book[i] = <span class="number">0</span>; <span class="comment">// 回溯：重置当前数字状态，以便下次使用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 返回上一层递归</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;total=%d&quot;</span>, total / <span class="number">2</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-2-节-炸廐人"><a class="header-anchor" href="#第-2-节-炸廐人">🌳</a>第 2 节 炸廐人</h3>
<h3 id="第-3-节-火柴棍等庿-67"><a class="header-anchor" href="#第-3-节-火柴棍等庿-67">🌳</a>第 3 节 火柴棍等庿 67</h3>
<h3 id="第-4-节-数的全排列-70"><a class="header-anchor" href="#第-4-节-数的全排列-70">🌳</a>第 4 节 数的全排列 70</h3>
<h2 id="第-4-章-万能的搜索"><a class="header-anchor" href="#第-4-章-万能的搜索">🌳</a>第 4 章 万能的搜索</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>], book[<span class="number">10</span>], n;</span><br><span class="line"><span class="comment">// 定义dfs函数，用于递归地生成序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> step)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">// 如果已经递归到第n+1步，意味着生成了一个完整的序列</span></span><br><span class="line">    <span class="keyword">if</span> (step == n + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 打印序列中的每个元素</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 打印换行符</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 返回上一层递归</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历1到n个数</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前数未被使用过</span></span><br><span class="line">        <span class="keyword">if</span> (book[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 将当前数放入序列中</span></span><br><span class="line">            a[step] = i;</span><br><span class="line">            <span class="comment">// 标记当前数已被使用</span></span><br><span class="line">            book[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 递归进入下一层，继续生成序列</span></span><br><span class="line">            dfs(step + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 重置当前数的使用标记，以用于生成其他序列</span></span><br><span class="line">            book[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回上一层递归</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    dfs(<span class="number">1</span>);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-1-节-不撞南墙不回头-深庞优先搜索-73"><a class="header-anchor" href="#第-1-节-不撞南墙不回头-深庞优先搜索-73">🌳</a>第 1 节 不撞南墙不回头——深庞优先搜索 73</h3>
<blockquote>
<p><a href="#%E7%AC%AC-1-%E8%8A%82-%E5%9D%91%E7%88%B9%E7%9A%84%E5%A5%A5%E6%95%B0-58">编 号 为 1-9 的 九 张 扑 克 牌 , 然 后 将 这 九 张 扑 克牌 放 到 九 个 盒 子 中 ,并 使 得 口 口 口 + 口 口 口 = 口 口 口 成 立</a></p>
</blockquote>
<h3 id="第-2-节-解救小哈-81"><a class="header-anchor" href="#第-2-节-解救小哈-81">🌳</a>第 2 节 解救小哈 81</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">/*	算法：深度优先搜索(DFS)</span></span><br><span class="line"><span class="comment">	时间：2021.10.28</span></span><br><span class="line"><span class="comment">	目的：找出小哼解救小哈的最短路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> n, m, p, q, min = <span class="number">99999999</span>;</span><br><span class="line"><span class="type">int</span> a[<span class="number">51</span>][<span class="number">51</span>], book[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> step)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> tx, ty, k;</span><br><span class="line">	<span class="comment">//判断是否到达小哈的位置</span></span><br><span class="line">	<span class="keyword">if</span> (x == p &amp;&amp; y == q)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//更新最小值</span></span><br><span class="line">		<span class="keyword">if</span> (step &lt; min)</span><br><span class="line">			min = step;</span><br><span class="line">		<span class="keyword">return</span>;<span class="comment">//请注意这里的返回很重要</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//枚举4种走法</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//计算下一个点坐标</span></span><br><span class="line">		tx = x + next[k][<span class="number">0</span>];</span><br><span class="line">		ty = y + next[k][<span class="number">1</span>];</span><br><span class="line">		<span class="comment">//判断是否越界</span></span><br><span class="line">		<span class="keyword">if</span> (tx&lt;<span class="number">1</span> || tx&gt;n || ty&lt;<span class="number">1</span> || ty&gt;m)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//判断该点是否为障碍物或者已经在路径里</span></span><br><span class="line">		<span class="keyword">if</span> (a[tx][ty] == <span class="number">0</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			book[tx][ty] = <span class="number">1</span>;<span class="comment">//标记这个点已经被走过</span></span><br><span class="line">			dfs(tx, ty, step + <span class="number">1</span>);</span><br><span class="line">			book[tx][ty] = <span class="number">0</span>;<span class="comment">//尝试结束，取消这个点的标记</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, startx, starty;</span><br><span class="line">	<span class="comment">//读入n和m，n为行m为列</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//读入迷宫</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入起点和终点坐标</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;startx, &amp;starty, &amp;p, &amp;q);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从起点开始搜索</span></span><br><span class="line">	book[startx][startx] = <span class="number">1</span>;<span class="comment">//标记起点已经在路径中，防止后面重复走</span></span><br><span class="line">	<span class="comment">//第一个参数是起点的x坐标，第二个参数是起点的y坐标，第三个参数是初始步数为0</span></span><br><span class="line">	dfs(startx, starty, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出最短步数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, min);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-3-节-层层递进-广庞优先搜索"><a class="header-anchor" href="#第-3-节-层层递进-广庞优先搜索">🌳</a>第 3 节 层层递进——广庞优先搜索</h3>
<blockquote>
<p>广 度 优 先 搜 索 (Breadth First Search,BFS), 也 称 为 宽 度 优 先 搜 索</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">/*	算法：广度优先搜索（BFS)</span></span><br><span class="line"><span class="comment">	时间：2021.10.28</span></span><br><span class="line"><span class="comment">	目的：找出小哼解救小哈的最短路径</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> x;<span class="comment">//横坐标</span></span><br><span class="line">	<span class="type">int</span> y;<span class="comment">//纵坐标</span></span><br><span class="line">	<span class="type">int</span> f;<span class="comment">//父亲在队列中的编号，本题不要求输出路径，可以不需要f</span></span><br><span class="line">	<span class="type">int</span> s;<span class="comment">//步数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">note</span> <span class="title">que</span>[2501];</span><span class="comment">//因为地图大小不超过50*50，因此队列扩展不会超过2500个</span></span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> a[<span class="number">51</span>][<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;, book[<span class="number">51</span>][<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="comment">//定义一个用于表示走的方向的数组</span></span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> head, tail;</span><br><span class="line">	<span class="type">int</span> i, j, k, n, m, startx, starty, p, q, tx, ty, flag;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (i =<span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;startx, &amp;starty, &amp;p, &amp;q);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//队列初始化</span></span><br><span class="line">	head = <span class="number">1</span>;</span><br><span class="line">	tail = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//往队列输入迷宫入口坐标</span></span><br><span class="line">	que[tail].x = startx;</span><br><span class="line">	que[tail].y = starty;</span><br><span class="line">	que[tail].f = <span class="number">0</span>;</span><br><span class="line">	que[tail].s = <span class="number">0</span>;</span><br><span class="line">	tail++;</span><br><span class="line">	book[startx][starty]=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	flag = <span class="number">0</span>;<span class="comment">//用来标记是否到达目标点，0表示暂时还没有到达，1表示到达</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//枚举四个方向</span></span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//计算下一个点的坐标</span></span><br><span class="line">			tx = que[head].x + next[k][<span class="number">0</span>];</span><br><span class="line">			ty = que[head].y + next[k][<span class="number">1</span>];</span><br><span class="line">			<span class="comment">//判断是否越界</span></span><br><span class="line">			<span class="keyword">if</span> (tx&lt;<span class="number">1</span> || tx&gt;n || ty&lt;<span class="number">1</span> || ty&gt;m)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//判断是否是障碍物或者已经在路径中</span></span><br><span class="line">			<span class="keyword">if</span> (a[tx][ty] == <span class="number">0</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//把这个点标记为已经走过</span></span><br><span class="line">				<span class="comment">//注意宽搜每个点只入队一次，所以和深搜不同，不需要将book数组还原</span></span><br><span class="line">				book[tx][ty] = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//插入新的点到队列中</span></span><br><span class="line">				que[tail].x = tx;</span><br><span class="line">				que[tail].y = ty;</span><br><span class="line">				que[tail].f = head;<span class="comment">//因为这个点是从head扩展出来的，所以他的父亲是</span></span><br><span class="line">				<span class="comment">//head，本题目不需要求路径，因此本句可省略</span></span><br><span class="line">				que[tail].s = que[head].s + <span class="number">1</span>;<span class="comment">//步数是父亲的步数+1</span></span><br><span class="line">				tail++;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果到目标点了，停止扩展，任务结束，退出循环</span></span><br><span class="line">			<span class="keyword">if</span> (tx == p &amp;&amp; ty == q)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//注意下面两句话的位置千万不要写反了</span></span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		head++;<span class="comment">//注意这地方千万不要忘记，当一个点扩展结束后，head++才能对后面的点在进行扩展</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打印队列中末尾最后一个点（目标点）的步数</span></span><br><span class="line">	<span class="comment">//注意tail是指向队列队尾（即最后一位）的下一个位置，所以这需要-1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, que[tail - <span class="number">1</span>].s);</span><br><span class="line"></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-4-节-再解炸廐人-95"><a class="header-anchor" href="#第-4-节-再解炸廐人-95">🌳</a>第 4 节 再解炸廐人 95</h3>
<h4 id="广度优先搜索-解法"><a class="header-anchor" href="#广度优先搜索-解法">🌳</a>广度优先搜索 解法</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">/*	算法：广度优先搜索（BFS)</span></span><br><span class="line"><span class="comment">	时间：2021.10.28</span></span><br><span class="line"><span class="comment">	目的：优化3.2炸弹人的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> x;<span class="comment">//横坐标</span></span><br><span class="line">	<span class="type">int</span> y;<span class="comment">//纵坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> a[<span class="number">20</span>][<span class="number">21</span>];<span class="comment">//用来存储地图</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getnum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum, x, y;</span><br><span class="line">	sum = <span class="number">0</span>;<span class="comment">//sum用来计数（可以消灭的敌人数），所以初始化为0</span></span><br><span class="line">	<span class="comment">//将坐标i,j复制到两个新变量x,y中，以便以后向上下左右四个方向统计可以消灭的敌人数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//向上统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)<span class="comment">//判断的点不是墙，如果不是墙就继续</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果当前的点是敌人，则进行计数</span></span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//x--的作用是继续向上统计</span></span><br><span class="line">		x--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向下统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//x++的作用是继续向下统计</span></span><br><span class="line">		x++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向左统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//y--的作用是继续向左统计</span></span><br><span class="line">		y--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向右统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//y++的作用是继续向右统计</span></span><br><span class="line">		y++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">que</span>[401];</span><span class="comment">//假设地图大小不超过20*20，因此队列扩展不会超过400个</span></span><br><span class="line">	<span class="type">int</span> head, tail;</span><br><span class="line">	<span class="type">int</span> book[<span class="number">20</span>][<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//定义一个标记数组并全部初始化为0</span></span><br><span class="line">	<span class="type">int</span> i, j, k, sum, max = <span class="number">0</span>, mx, my, n, m, startx, starty, tx, ty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//定义一个用于表达走的方向的数组</span></span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入n和m,n表示有多少行字符，m表示每行有多少列</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;startx, &amp;starty);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入n行字符</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//队列初始化</span></span><br><span class="line">	head = <span class="number">1</span>;</span><br><span class="line">	tail = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//往队列插入小人的起始坐标</span></span><br><span class="line">	que[tail].x = startx;</span><br><span class="line">	que[tail].y = starty;</span><br><span class="line">	tail++;</span><br><span class="line">	book[startx][starty] = <span class="number">1</span>;</span><br><span class="line">	max = getnum(startx, starty);</span><br><span class="line">	mx = startx;</span><br><span class="line">	my = starty;</span><br><span class="line">	<span class="comment">//当队列不为空的时候循环</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//枚举4个方向</span></span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//尝试走的下一个点的坐标</span></span><br><span class="line">			tx = que[head].x + next[k][<span class="number">0</span>];</span><br><span class="line">			ty = que[head].y + next[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">//判断是否越界</span></span><br><span class="line">			<span class="keyword">if</span> (tx&lt;<span class="number">0</span> || tx&gt;n - <span class="number">1</span> || ty&lt;<span class="number">0</span> || ty&gt;m - <span class="number">1</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//判断是否为平地或者曾经走过</span></span><br><span class="line">			<span class="keyword">if</span> (a[tx][ty] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//每个点只入队一次，所以需要标记这个点已经走过</span></span><br><span class="line">				book[tx][ty] = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//插入新扩展的点到队列中</span></span><br><span class="line">				que[tail].x = tx;</span><br><span class="line">				que[tail].y = ty;</span><br><span class="line">				tail++;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//统计当前新扩展的点可以消灭的敌人总数</span></span><br><span class="line">				sum = getnum(tx, ty);</span><br><span class="line">				<span class="comment">//更新max的值</span></span><br><span class="line">				<span class="keyword">if</span> (sum &gt; max)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//如果当前统计出的所能消灭敌人数大于max,则更新max</span></span><br><span class="line">					<span class="comment">//并用mx和my记录该点坐标</span></span><br><span class="line">					max = sum;</span><br><span class="line">					mx = tx;</span><br><span class="line">					my = ty;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		head++;<span class="comment">//注意这地方千万不要忘记，当一个点扩展结束后，必须要head++才能对后面的点进行扩展</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后输出这个点和最多可以消灭的敌人数</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;将炸弹放置在（%d,%d)处，可以消灭%d个敌人\n&quot;</span>, mx, my, max);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深度优先搜索-解法"><a class="header-anchor" href="#深度优先搜索-解法">🌳</a>深度优先搜索 解法</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">/*	算法：深度优先搜索（DFS)</span></span><br><span class="line"><span class="comment">	时间：2021.10.29</span></span><br><span class="line"><span class="comment">	目的：优化3.2炸弹人的代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> a[<span class="number">20</span>][<span class="number">21</span>];</span><br><span class="line"><span class="type">int</span> book[<span class="number">20</span>][<span class="number">20</span>], max, mx, my, n, m;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getnum</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> sum, x, y;</span><br><span class="line">	sum = <span class="number">0</span>;<span class="comment">//sum用来计数（可以消灭的敌人数），所以初始化为0</span></span><br><span class="line">	<span class="comment">//将坐标i,j复制到两个新变量x,y中，以便以后向上下左右四个方向统计可以消灭的敌人数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//向上统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)<span class="comment">//判断的点不是墙，如果不是墙就继续</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果当前的点是敌人，则进行计数</span></span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//x--的作用是继续向上统计</span></span><br><span class="line">		x--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向下统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//x++的作用是继续向下统计</span></span><br><span class="line">		x++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向左统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//y--的作用是继续向左统计</span></span><br><span class="line">		y--;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//向右统计可以消灭的敌人数</span></span><br><span class="line">	x = i; y = j;</span><br><span class="line">	<span class="keyword">while</span> (a[x][y] != <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (a[x][y] == <span class="string">&#x27;G&#x27;</span>)</span><br><span class="line">			sum++;</span><br><span class="line">		<span class="comment">//y++的作用是继续向上统计</span></span><br><span class="line">		y++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//定义一个用于表示走的方向的数组</span></span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> k, sum, tx, ty;</span><br><span class="line">	<span class="comment">//计算这个点当前可以消灭的敌人总数</span></span><br><span class="line">	sum = getnum(x, y);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//更新max的值</span></span><br><span class="line">	<span class="keyword">if</span> (sum &gt; max)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//如果当前的点统计出的所能消灭的敌人数大于max,</span></span><br><span class="line">		<span class="comment">//则更新max，并用mx和my记录当前点的坐标</span></span><br><span class="line">		max = sum;</span><br><span class="line">		mx = x;</span><br><span class="line">		my = y;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//枚举四个方向</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//下个点的坐标</span></span><br><span class="line">		tx = x + next[k][<span class="number">0</span>];</span><br><span class="line">		ty = y + next[k][<span class="number">1</span>];</span><br><span class="line">		<span class="comment">//判断是否越界</span></span><br><span class="line">		<span class="keyword">if</span> (tx&lt;<span class="number">0</span> || tx&gt;n - <span class="number">1</span> || ty&lt;<span class="number">0</span> || ty&gt;m - <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//判断是否围墙或者已经走过</span></span><br><span class="line">		<span class="keyword">if</span> (a[tx][ty] == <span class="string">&#x27;.&#x27;</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			book[tx][ty] = <span class="number">1</span>;<span class="comment">//标记这个点已走过</span></span><br><span class="line">			dfs(tx, ty);<span class="comment">//开始尝试下一个点</span></span><br><span class="line">			<span class="comment">//book[tx][ty]=0</span></span><br><span class="line"><span class="comment">//此处不用收回，与路径或者步数有关的深搜，需要收回标记，无关则不需要回收</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, startx, starty;</span><br><span class="line">	<span class="comment">//读入n和m，n表示有多少行字符，m表示每行有多少字符</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;startx, &amp;starty);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入n行字符</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, a[i]);</span><br><span class="line">	<span class="comment">//从小人站的位置开始尝试</span></span><br><span class="line">	book[startx][starty] = <span class="number">1</span>;</span><br><span class="line">	max = getnum(startx, starty);</span><br><span class="line">	mx = startx;</span><br><span class="line">	my = starty;</span><br><span class="line">	dfs(startx, starty);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;将炸弹放置在（%d %d),最多可以下消灭%d个敌人\n&quot;</span>, mx, my, max);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-5-节-宝岛探险"><a class="header-anchor" href="#第-5-节-宝岛探险">🌳</a>第 5 节 宝岛探险</h3>
<h4 id="广度搜索"><a class="header-anchor" href="#广度搜索">🌳</a>广度搜索</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：BFS</span></span><br><span class="line"><span class="comment">//	时间：2021.10.29</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> x;<span class="comment">//横坐标</span></span><br><span class="line">	<span class="type">int</span> y;<span class="comment">//纵坐标</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">que</span>[2501];</span></span><br><span class="line">	<span class="type">int</span> head, tail;</span><br><span class="line">	<span class="type">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line">	<span class="type">int</span> book[<span class="number">51</span>][<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> i, j, k, sum, max = <span class="number">0</span>, mx, my, n, m, startx, starty, tx, ty;</span><br><span class="line">	<span class="comment">//定义一个方向数组</span></span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="comment">//读入n行m列以及小哼降落的坐标</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;startx, &amp;starty);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入地图</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line">	<span class="comment">//队列初始化</span></span><br><span class="line">	head = <span class="number">1</span>;</span><br><span class="line">	tail = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//往队列插入降落的起始坐标</span></span><br><span class="line">	que[tail].x = startx;</span><br><span class="line">	que[tail].y = starty;</span><br><span class="line">	tail++;</span><br><span class="line">	book[startx][starty] = <span class="number">1</span>;</span><br><span class="line">	sum = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//当队列不为空的时候循环</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//枚举4个方向</span></span><br><span class="line">		<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//计算下一步的坐标</span></span><br><span class="line">			tx = que[head].x + next[k][<span class="number">0</span>];</span><br><span class="line">			ty = que[head].y + next[k][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">			<span class="comment">//判断是否越界</span></span><br><span class="line">			<span class="keyword">if</span> (tx&lt;<span class="number">1</span> || tx&gt;n || ty&lt;<span class="number">1</span> || ty&gt;m)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//判断是否是陆地或者曾经是否走过</span></span><br><span class="line">			<span class="keyword">if</span> (a[tx][ty] &gt; <span class="number">0</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				sum++;</span><br><span class="line">				<span class="comment">//每个点只入队一次，所以需要标记这个点已经走过</span></span><br><span class="line">				book[tx][ty] = <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//将新扩展的点加入队列</span></span><br><span class="line">				que[tail].x = tx;</span><br><span class="line">				que[tail].y = ty;</span><br><span class="line">				tail++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		head++;<span class="comment">//注意这地方千万不能忘记</span></span><br><span class="line">		<span class="comment">//当一个点扩展结束后，head++才能继续往下扩展</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后输出岛屿的大小</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="深度探索"><a class="header-anchor" href="#深度探索">🌳</a>深度探索</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：DFS</span></span><br><span class="line"><span class="comment">//	时间：2021.10.29</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="type">int</span> book[<span class="number">51</span>][<span class="number">51</span>], n, m, sum;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//定义一个方向数组</span></span><br><span class="line">	<span class="type">int</span> next[<span class="number">4</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,<span class="comment">//向右走</span></span><br><span class="line">		&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,<span class="comment">//向下走</span></span><br><span class="line">		&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,<span class="comment">//向左走</span></span><br><span class="line">		&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;<span class="comment">//向上走</span></span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="type">int</span> k, tx, ty;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//枚举4个方向</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">0</span>; k &lt;= <span class="number">3</span>; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//计算下一步坐标</span></span><br><span class="line">		tx = x + next[k][<span class="number">0</span>];</span><br><span class="line">		ty = y + next[k][<span class="number">1</span>];</span><br><span class="line">		<span class="comment">//判断是否越界</span></span><br><span class="line">		<span class="keyword">if</span> (tx&lt;<span class="number">1</span> || tx&gt;n || ty&lt;<span class="number">1</span> || ty&gt;m)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//判断是否是陆地</span></span><br><span class="line">		<span class="keyword">if</span> (a[tx][ty] &gt; <span class="number">0</span> &amp;&amp; book[tx][ty] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			sum++;</span><br><span class="line">			book[tx][ty] = <span class="number">1</span>;<span class="comment">//标记这个点已走过</span></span><br><span class="line">			dfs(tx, ty);<span class="comment">//开始尝试下一个点</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, startx, starty;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;startx, &amp;starty);</span><br><span class="line">	<span class="comment">//读入地图</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i][j]);</span><br><span class="line"></span><br><span class="line">	book[startx][starty] = <span class="number">1</span>;</span><br><span class="line">	sum = <span class="number">1</span>;</span><br><span class="line">	<span class="comment">//从降落的位置开始</span></span><br><span class="line">	dfs(startx, starty);</span><br><span class="line">	<span class="comment">//最后输出岛屿的大小</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其 实 这 就 是 求 一 个 图 中 独 立 子 图 的 个 数 . 这 个 算 法 就 是 鼎 鼎 大 名 的 Floodfill 漫水填 充 法<br>
( 也 称 种 子 填 充 法 ),Floodfill 在 计 算 昺 图 形 学 中 昉 着 非 常 广 泛 的 运 用 , 比 如 图 像 分 割 、 物 体<br>
识 别 等 等 。 古 外 我 们 熟 知 的 Windows 下 “ 画 图“ 软 件 的 油 漆 桶 工 具 就 是 基 于 这 个 算 法 的 。<br>
当 你 需 要 给 棠 个 密 闭 区 域 涂 色 或 者 更 改 标 个 密 闭 区 域的 颜 色 时 , 程 序 自 动 选 中 与 种 子 点 ( 鼠<br>
标 左 键 单 击 的 位 置 ) 周 边 颜 色 相 同 的 区 域 , 拳 着 将 该 区 域 替 扢 成 戇 定 的 颜 色 。Photoshop 的<br>
魔 是 桐 选 择 工 具 也 可 以 基 于 这 个 算 法 实 现 。 具 体 的 算 法 是 : 曥 找 种 子 点 周 边 的 点 , 将 与 种 子<br>
点 颜 色 相 近 的 点 ( 可 以 设 置 一 个 闹 值 ) 入 队 作 为 新 种 子 , 并 对 新 入 队 的 种 子 也 迹 行 同 样 的 扩<br>
展 操 作 , 这 样 就 选 取 了 和 昀 初 种 子 相 近 颜 色 的 区 域</p>
<h3 id="第-6-节-水管工游戏-117"><a class="header-anchor" href="#第-6-节-水管工游戏-117">🌳</a>第 6 节 水管工游戏 117</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/0joe1/algorithm/">github 0joe1 水管工游戏 源码</a></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">51</span>][<span class="number">51</span>];</span><br><span class="line"><span class="type">int</span> book[<span class="number">51</span>][<span class="number">51</span>],n,m,flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pos</span>&#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;s[<span class="number">100</span>];</span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">_Bool</span> <span class="title function_">isvalid</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x&gt;=<span class="number">0</span> &amp;&amp; x&lt;n &amp;&amp; y&gt;=<span class="number">0</span> &amp;&amp; y&lt;m &amp;&amp; a[x][y])&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> front)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (x==n<span class="number">-1</span> &amp;&amp; y==m)&#123;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;top;i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d) &quot;</span>,s[i].x,s[i].y);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isvalid(x,y) || book[x][y])&#123;</span><br><span class="line">       <span class="comment">// printf(&quot;(%d,%d)&quot;,x,y);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    book[x][y]=<span class="number">1</span>;</span><br><span class="line">    s[top].x=x;</span><br><span class="line">    s[top].y=y;</span><br><span class="line">    top++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a[x][y]&gt;<span class="number">0</span> &amp;&amp; a[x][y]&lt;=<span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (front)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            dfs(x<span class="number">-1</span>,y,<span class="number">4</span>);</span><br><span class="line">            dfs(x+<span class="number">1</span>,y,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            dfs(x,y<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">            dfs(x,y+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            dfs(x<span class="number">-1</span>,y,<span class="number">4</span>);</span><br><span class="line">            dfs(x+<span class="number">1</span>,y,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            dfs(x,y<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">            dfs(x,y+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[x][y]&gt;<span class="number">4</span> &amp;&amp; a[x][y]&lt;=<span class="number">6</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (front)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            dfs(x,y+<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            dfs(x+<span class="number">1</span>,y,<span class="number">2</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            dfs(x,y<span class="number">-1</span>,<span class="number">3</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            dfs(x<span class="number">-1</span>,y,<span class="number">4</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    book[x][y]=<span class="number">0</span>;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,num=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a[i][j]);</span><br><span class="line">    dfs(<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到铺设方案&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;impossible\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*5 4</span></span><br><span class="line"><span class="comment">5 3 5 3</span></span><br><span class="line"><span class="comment">1 5 3 0</span></span><br><span class="line"><span class="comment">2 3 5 1</span></span><br><span class="line"><span class="comment">6 1 1 5</span></span><br><span class="line"><span class="comment">1 5 5 4*/</span></span><br></pre></td></tr></table></figure>
<h2 id="第-5-章-图的遍历-128"><a class="header-anchor" href="#第-5-章-图的遍历-128">🌳</a>第 5 章 图的遍历 128</h2>
<h3 id="第-1-节-深庞和广庞优先究竟是指啥-129"><a class="header-anchor" href="#第-1-节-深庞和广庞优先究竟是指啥-129">🌳</a>第 1 节 深庞和广庞优先究竟是指啥 129</h3>
<h4 id="深度优先搜索遍历图"><a class="header-anchor" href="#深度优先搜索遍历图">🌳</a>深度优先搜索遍历图</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.10.30</span></span><br><span class="line"><span class="comment">//  目的：用深度优先搜索遍历图（无向）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> book[<span class="number">101</span>], sum, n, e[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line"><span class="comment">//这里的图是用一个二维数组e来存储，二维数组中第i行第j列表示的就是顶点i到&#x27;</span></span><br><span class="line"><span class="comment">//顶点j是否有边，1表示有边，无穷表示没有边。这里我们将自己到自己（即i等于j)</span></span><br><span class="line"><span class="comment">//设为0.我们将这种存储图的方法称为图的邻接矩阵存储法。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur)</span><span class="comment">//cur是当前所在的顶点编号</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, cur);</span><br><span class="line">	sum++;<span class="comment">//每访问一个顶点，sum就加1</span></span><br><span class="line">	<span class="keyword">if</span> (sum == n)   <span class="keyword">return</span>;<span class="comment">//所有的顶点都已经访问过则直接退出</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//从1号顶点到n号顶点依次尝试，看哪些顶点与当前顶点cur有边相连</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//判断当前顶点cur到顶点i是否有边，并判断顶点i是否已访问过</span></span><br><span class="line">		<span class="keyword">if</span> (e[cur][i] == <span class="number">1</span> &amp;&amp; book[i] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			book[i] = <span class="number">1</span>;</span><br><span class="line">			dfs(i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, m, a, b;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//初始化二维矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j) e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> e[i][j] = <span class="number">99999999</span>;<span class="comment">//我们这里假设99999999为正无穷</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入顶点之间的边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		e[a][b] = <span class="number">1</span>;</span><br><span class="line">		e[b][a] = <span class="number">1</span>;<span class="comment">//这里是无向图，所以需要将e[b][a]也赋为1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从1号城市出发</span></span><br><span class="line">	book[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//标记1号顶点已访问</span></span><br><span class="line">	dfs(<span class="number">1</span>);<span class="comment">//从1号顶点开始遍历</span></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="广度优先搜索遍历图"><a class="header-anchor" href="#广度优先搜索遍历图">🌳</a>广度优先搜索遍历图</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.10.30</span></span><br><span class="line"><span class="comment">//  目的：用广度优先搜索遍历图(无向）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, n, m, a, b, cur, book[<span class="number">101</span>] = &#123; <span class="number">0</span> &#125;, e[<span class="number">101</span>][<span class="number">101</span>];</span><br><span class="line">	<span class="type">int</span> que[<span class="number">10001</span>], head, tail;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//初始化二维矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j) e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> e[i][j] = <span class="number">99999999</span>;<span class="comment">//假设99999999为无穷大</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入顶点之间的边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		e[a][b] = <span class="number">1</span>;</span><br><span class="line">		e[b][a] = <span class="number">1</span>;<span class="comment">//因为这里是无向图</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//队列初始化</span></span><br><span class="line">	head = <span class="number">1</span>;</span><br><span class="line">	tail = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从1号顶点出发，将1号顶点加入队列</span></span><br><span class="line">	que[tail] = <span class="number">1</span>;</span><br><span class="line">	tail++;</span><br><span class="line">	book[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//标记1号顶点已访问</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//当队列不为空的时候循环</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		cur = que[head];<span class="comment">//当前正在访问的顶点编号</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//从1-n依次尝试</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//判断从顶点cur到顶点i是否有边，并判断顶点i是否已经访问过</span></span><br><span class="line">			<span class="keyword">if</span> (e[cur][i] == <span class="number">1</span> &amp;&amp; book[i] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//如果从顶点cur到顶点i有边，并且顶点i没有被访问过，则将顶点i入队</span></span><br><span class="line">				que[tail] = i;</span><br><span class="line">				tail++;</span><br><span class="line">				book[i] = <span class="number">1</span>;<span class="comment">//标记顶点i已访问</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果tail大于n，则表明所有顶点都已经被访问过了</span></span><br><span class="line">			<span class="keyword">if</span> (tail &gt; n)</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		head++;<span class="comment">//注意这个地方，千万不要忘记当一个顶点扩展结束后，head++，然后才能继续向下扩展</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; tail; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, que[i]);</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-2-节-城市地图-图的深庞优先遍历"><a class="header-anchor" href="#第-2-节-城市地图-图的深庞优先遍历">🌳</a>第 2 节 城市地图——图的深庞优先遍历</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.11.1</span></span><br><span class="line"><span class="comment">//	算法：用深度优先搜索遍历图（有向）</span></span><br><span class="line"><span class="comment">//	目的：找出两个地点的最短路径</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> min = <span class="number">99999999</span>, book[<span class="number">101</span>], n, e[<span class="number">101</span>][<span class="number">101</span>];<span class="comment">//我们这里假设99999999为正无穷</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//cur是当前所在的城市编号，dis是当前已经走过的路程</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> dis)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> j;</span><br><span class="line">	<span class="comment">//如果当前走过的路程已经大于之前找到的最短路，则没有必要再往下尝试了，立即返回</span></span><br><span class="line">	<span class="keyword">if</span> (dis &gt; min) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">if</span> (cur == n)<span class="comment">//判断是否到达了目标城市</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (dis &lt; min) min = dis;<span class="comment">//更新最小值</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//从1号城市到n号城市依次尝试</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//判断当前城市cur到城市j是否有路，并判断城市j是否在已走过的路径中</span></span><br><span class="line">		<span class="keyword">if</span> (e[cur][j] != <span class="number">99999999</span> &amp;&amp; book[j] == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			book[j] = <span class="number">1</span>;<span class="comment">//标记城市j已经在路径中</span></span><br><span class="line">			dfs(j, dis + e[cur][j]);<span class="comment">//从城市j再出发，继续寻找目标城市</span></span><br><span class="line">			book[j] = <span class="number">0</span>;<span class="comment">//之前一步探索完毕之后，取消对城市j的标记</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j, m, a, b, c;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//初始化二维矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j) e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span>   e[i][j] = <span class="number">99999999</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入城市之间的道路</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">		e[a][b] = c;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从1号城市出发</span></span><br><span class="line">	book[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//标记1号城市已经在路径中</span></span><br><span class="line">	dfs(<span class="number">1</span>, <span class="number">0</span>);<span class="comment">//1表示当前所在的城市编号，0表示当前已经走过的路程</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, min);<span class="comment">//打印1号城市到5号城市的最短路径</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-3-节-最少转机-图的广庞优先遍历"><a class="header-anchor" href="#第-3-节-最少转机-图的广庞优先遍历">🌳</a>第 3 节 最少转机——图的广庞优先遍历</h3>
<p>广 度 优 先 搜 索 更加 适 用 于 所 有边的权 值 相 同的 情 况<br>
图 的 邻接 矩 阵 存 傅 法 。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//   时间：2021.11.3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> x;<span class="comment">//城市编号</span></span><br><span class="line">	<span class="type">int</span> s;<span class="comment">//转机次数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node</span> <span class="title">que</span>[2501];</span></span><br><span class="line">	<span class="type">int</span> e[<span class="number">51</span>][<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;, book[<span class="number">51</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">	<span class="type">int</span> head, tail;</span><br><span class="line">	<span class="type">int</span> i, j, n, m, a, b, cur, start, end, flag = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;start, &amp;end);</span><br><span class="line">	<span class="comment">//初始化二维矩阵</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j)  e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span>  e[i][j] = <span class="number">99999999</span>;</span><br><span class="line">	<span class="comment">//读入城市之间的航班</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">		<span class="comment">//注意这里是无向图</span></span><br><span class="line">		e[a][b] = <span class="number">1</span>;</span><br><span class="line">		e[b][a] = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//队列初始化</span></span><br><span class="line">	head = <span class="number">1</span>;</span><br><span class="line">	tail = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//从start号城市出发，将start号城市加入队列</span></span><br><span class="line">	que[tail].x = start;</span><br><span class="line">	que[tail].s = <span class="number">0</span>;</span><br><span class="line">	tail++;</span><br><span class="line">	book[<span class="number">1</span>] = start;<span class="comment">//标记start号城市已在队列中</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//当队列不为空的时候循环</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)</span><br><span class="line">	&#123;</span><br><span class="line">		cur = que[head].x;<span class="comment">//当前队列中首城市的编号</span></span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)<span class="comment">//从1到n依次尝试</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//从城市cur到城市j是否有航班并且判断城市j是否已经在队列中</span></span><br><span class="line">			<span class="keyword">if</span> (e[cur][j] != <span class="number">99999999</span> &amp;&amp; book[j] == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//如果从城市cur到城市j有航班并且城市j不在队列中，则将j号城市入队</span></span><br><span class="line">				que[tail].x = j;</span><br><span class="line">				que[tail].s = que[head].s + <span class="number">1</span>;<span class="comment">//转机次数+1</span></span><br><span class="line">				tail++;</span><br><span class="line">				<span class="comment">//标记城市j已经在队列中</span></span><br><span class="line">				book[j] = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//如果到达目标城市，停止扩展，任务结束，退出循环</span></span><br><span class="line">			<span class="keyword">if</span> (que[tail].x == end)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//注意下面两句话的位置千万不要写颠倒了</span></span><br><span class="line">				flag = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		head++;<span class="comment">//注意这地方，千万不要忘记当一个点扩展结束后，head++才能继续扩展</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//打印队列中末尾最后一个（目标城市）的转机次数</span></span><br><span class="line">	<span class="comment">//注意tail是指向队列队尾（即最后一位）的下一个位置，所以需要-1</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, que[tail - <span class="number">1</span>].s);</span><br><span class="line"></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="第-6-章-最短路廮"><a class="header-anchor" href="#第-6-章-最短路廮">🌳</a>第 6 章 最短路廮</h2>
<h3 id="第-1-节-只有五行的算法-floyd-warshall"><a class="header-anchor" href="#第-1-节-只有五行的算法-floyd-warshall">🌳</a>第 1 节 只有五行的算法——Floyd-Warshall</h3>
<p>多 源 最 短 路 径</p>
<p>如果要让任意两点(例如从顶点 a 到顶点 b)之间的路程变短，<br>
只能引入第三个点(顶点 k)，并通过这个顶点 k 中转即 a→k→b，才可能缩短原来从顶点 a 到顶点 b 的路程。那么这个中转的顶点 k 是 1~n 中的哪个点呢?<br>
甚至有时候不只通过一个点，而是经过两个点或者更多点中转会更短，<br>
即 a→k1→k2→b 或者 a→k1→k2→…ki…→b。</p>
<p>比如上图中<br>
从 4 号城市到 3 号城市(4-3)的路程 e[4][3]原本是 12,<br>
如果只通过 1 号城市中转(4→1→3)，路程将缩短为 11(e[4][1]+e[1][3]=5+6=11)。<br>
其实 1 号城市到 3 号城市也可以通过 2 号城市中转,使得 1 号到 3 号城市的路程缩短为 5<br>
(e[1][2]+e[2][3]=2+3=5)。<br>
所以如果同时经过 1 号和 2 号两个城市中转的话，从 4 号城市到 3 号城市的路程会进一步缩短为 10。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：Floyd-Warshall</span></span><br><span class="line"><span class="comment">//	时间：2021.11.3 22点41分</span></span><br><span class="line"><span class="comment">//  目的：求解多源路最短路径问题（任意两个点之间的最短路径）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> e[<span class="number">10</span>][<span class="number">10</span>], k, i, j, n, m, t1, t2, t3;</span><br><span class="line">	<span class="type">int</span> inf = <span class="number">99999999</span>;<span class="comment">//用inf(infinity的缩写)存储一个我们认为的正无穷值</span></span><br><span class="line">	<span class="comment">//读入n和m,n表示顶点个数，m表示边的条数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j) e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> e[i][j] = inf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;t1, &amp;t2, &amp;t3);</span><br><span class="line">		e[t1][t2] = t3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Floyd-Warshall算法核心语句</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">				<span class="keyword">if</span> (e[i][j] &gt; e[i][k] + e[k][j])</span><br><span class="line">					e[i][j] = e[i][k] + e[k][j];</span><br><span class="line">	<span class="comment">//输出最终的结果</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%10d&quot;</span>, e[i][j]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-2-节-dijkstra-算法-通过边实现松廅-155"><a class="header-anchor" href="#第-2-节-dijkstra-算法-通过边实现松廅-155">🌳</a>第 2 节 Dijkstra 算法——通过边实现松廅 155</h3>
<p>单 源 最 短 路 径 迪杰斯特拉</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.11.3 23点11分</span></span><br><span class="line"><span class="comment">//	算法：Dijkstra算法</span></span><br><span class="line"><span class="comment">//	目的：求解单源最短路径（指定一个点（源点）到其余各个顶点的最短路径）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> e[<span class="number">10</span>][<span class="number">10</span>], dis[<span class="number">10</span>], book[<span class="number">10</span>], i, j, n, m, t1, t2, t3, u, v, min;</span><br><span class="line">	<span class="type">int</span> inf = <span class="number">99999999</span>;<span class="comment">//用inf(infinity的缩写)存储一个我们认为的正无穷值</span></span><br><span class="line">	<span class="comment">//读入n和m,n表示顶点个数，m表示边的条数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			<span class="keyword">if</span> (i == j) e[i][j] = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">else</span> e[i][j] = inf;</span><br><span class="line">	<span class="comment">//读入边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;t1, &amp;t2, &amp;t3);</span><br><span class="line">		e[t1][t2] = t3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化dis数组</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		dis[i] = e[<span class="number">1</span>][i];</span><br><span class="line"></span><br><span class="line">	<span class="comment">//book数组初始化</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		book[i] = <span class="number">0</span>;</span><br><span class="line">	book[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Dijkstra算法核心语句</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)<span class="comment">//一共n个顶点，1号本身已经在p集合里面了，所以</span></span><br><span class="line">	&#123;						<span class="comment">//只需要循环n-1次即可</span></span><br><span class="line">		<span class="comment">//找到离1号顶点最近的顶点</span></span><br><span class="line">		min = inf;</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (book[j] == <span class="number">0</span> &amp;&amp; dis[j] &lt; min)</span><br><span class="line">			&#123;</span><br><span class="line">				min = dis[j];</span><br><span class="line">				u = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		book[u] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (v = <span class="number">1</span>; v &lt;= n; v++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (e[u][v] &lt; inf)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (dis[v] &gt; dis[u] + e[u][v])</span><br><span class="line">					dis[v] = dis[u] + e[u][v];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出最后的结果</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line"></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通 过 上 面 的 代 码 我 们 可 以 看 出 , 这 个 算 法 的 时 间 复 時 度 是 O 吉 。 其 中 每 次 找 到 离 1 号<br>
项 点 昀 近 的 顶 点 的 时 间 复 時 度 是 O (9J, 这 里 我 们 可 以 用 “ 堆 “( 将 在 下 一 章 学 到 〕 晥 优 化 ,<br>
使 得 这一部分的时 间 复 時 度 降 低 到 O(logW。 另 外 对 于 边 数 M 少 于 A 的 稀 疏 图 晥 说 ( 我 们<br>
把 M 远 小 于 F 的 图 称 为 稀 疏 图 , 而 M 相 对 较 大 的 图 称 为 稠 密 图 ), 我 们 可以 用 邰 接 表 ( 这<br>
是 个 神 马 东 西 ? 不 要 着 急 , 待 会 再 仔 细 讲 解) 晥 代 替 邻 接 矩 阵 , 使 得 整 个 时 间 复 時 度 优 化 到<br>
O(M+N)logN. 请 注 意 ! 在 昀 坏 的 情 况 下 M 就 是 , 这 朷 的 话 (M+WilogW 要 比 P 还 要 大 。<br>
但 是 大 多 数 情 况 下 并 不 会 昉 那 么 多 边 , 因 此 (M+WiogN 要 比 F 小 很 多 。<br>
这 里 我 们 主 要 晥 讲 解 如 何 使 用 邻 接 表 晥 存 储 一 个 图 , 先 上 数</p>
<p>不 过 朹 据<br>
这 个 原 理 , 用 昬 算 法 求 昀 短 路 径 的 囹 是 不 能 昉 负 晃 边 的 , 因 为 扩 展 到 负 晃 边 的 时 候 会 产 生 更<br>
短 的 路 程 , 昉 可 能 就 破 坏 了 已 经 更 新 的 点 路 程 不 会 改 变 的 性 质</p>
<h4 id="数据结构：邻接矩阵"><a class="header-anchor" href="#数据结构：邻接矩阵">🌳</a>数据结构：邻接矩阵</h4>
<p><img src="/2024/06/03/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt="邻接矩阵"></p>
<h4 id="数据结构：邻接表"><a class="header-anchor" href="#数据结构：邻接表">🌳</a>数据结构：邻接表</h4>
<p><img src="/2024/06/03/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt="邻接表"></p>
<h3 id="第-3-节-bellman-ford-解决负权边"><a class="header-anchor" href="#第-3-节-bellman-ford-解决负权边">🌳</a>第 3 节 Bellman-Ford——解决负权边</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.11.14  22点08分</span></span><br><span class="line"><span class="comment">//	算法：Bellman-Ford</span></span><br><span class="line"><span class="comment">//	目的：解决负权边得问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> dis[<span class="number">10</span>], bak[<span class="number">10</span>], i, k, n, m, u[<span class="number">10</span>], v[<span class="number">10</span>], w[<span class="number">10</span>], check, flag;</span><br><span class="line">	<span class="type">int</span> inf = <span class="number">99999999</span>;<span class="comment">//用inf存储一个我们认为得正无穷值</span></span><br><span class="line">	<span class="comment">//读入n和m，n表示顶点个数，m表示边的个数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//读入边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u[i], &amp;v[i], &amp;w[i]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化dis数组，这里是1号顶点到其余各个顶点得初始路程</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		dis[i] = inf;</span><br><span class="line">	dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//Bellman-Ford算法核心语句</span></span><br><span class="line">	<span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= n - <span class="number">1</span>; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//将dis数组备份到bak数组中</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) bak[i] = dis[i];</span><br><span class="line">		<span class="comment">//进行一轮松弛</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">			<span class="keyword">if</span> (dis[v[i]] &gt; dis[u[i]] + w[i])</span><br><span class="line">				dis[v[i]] = dis[u[i]] + w[i];</span><br><span class="line">		<span class="comment">//松弛完毕后检测dis是否有更新</span></span><br><span class="line">		check = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) <span class="keyword">if</span> (bak[i] != dis[i]) &#123; check = <span class="number">1</span>; <span class="keyword">break</span>; &#125;</span><br><span class="line">		<span class="keyword">if</span> (check == <span class="number">0</span>) <span class="keyword">break</span>;<span class="comment">//如果dis数组没有更新，提前退出循环结束算法</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//检测负权回路</span></span><br><span class="line">	flag = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="keyword">if</span> (dis[v[i]] &gt; dis[u[i]] + w[i]) flag = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;此图含有负权回路&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输出最终的结果</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-4-节-bellman-ford-的队列优化"><a class="header-anchor" href="#第-4-节-bellman-ford-的队列优化">🌳</a>第 4 节 Bellman-Ford 的队列优化</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	时间：2021.11.14  22点44分</span></span><br><span class="line"><span class="comment">//	算法：Bellman-Ford 算法队列优化</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n, m, i, j, k;</span><br><span class="line">	<span class="comment">//u,v和w的数组大小要根据实际情况来设置，要比m的最大值要大一</span></span><br><span class="line">	<span class="type">int</span> u[<span class="number">8</span>], v[<span class="number">8</span>], w[<span class="number">8</span>];</span><br><span class="line">	<span class="comment">//first要比n的最大值大1，next要比m的最大值要大一</span></span><br><span class="line">	<span class="type">int</span> first[<span class="number">6</span>], next[<span class="number">8</span>];</span><br><span class="line">	<span class="type">int</span> dis[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;, book[<span class="number">6</span>] = &#123; <span class="number">0</span> &#125;;<span class="comment">//book数组用来记录那些顶点已经在队列中了</span></span><br><span class="line">	<span class="type">int</span> que[<span class="number">101</span>] = &#123; <span class="number">0</span> &#125;, head = <span class="number">1</span>, tail = <span class="number">1</span>;<span class="comment">//定义一个队列，并初始化队列</span></span><br><span class="line">	<span class="type">int</span> inf = <span class="number">99999999</span>;<span class="comment">//用inf来存储一个我们认为的正无穷值</span></span><br><span class="line">	<span class="comment">//读入n,m</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化dis数组，这里是1号顶点到其余各个顶点的初始化路程</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		dis[i] = inf;</span><br><span class="line">	dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化book数组，初始化为0，刚开始都不在队列中</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) book[i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化first数组下标1~n的值为-1，表示1~n顶点暂时都没有边</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++) first[i] = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//读入每一条边</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u[i], &amp;v[i], &amp;w[i]);</span><br><span class="line">		<span class="comment">//下面两句是建立邻接表的关键</span></span><br><span class="line">		next[i] = first[u[i]];</span><br><span class="line">		first[u[i]] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//1号顶点入队</span></span><br><span class="line">	que[tail] = <span class="number">1</span>; tail++;</span><br><span class="line">	book[<span class="number">1</span>] = <span class="number">1</span>;<span class="comment">//标记1号顶点已经入队</span></span><br><span class="line">	<span class="keyword">while</span> (head &lt; tail)<span class="comment">//队列不为空的时候循环</span></span><br><span class="line">	&#123;</span><br><span class="line">		k = first[que[head]];<span class="comment">//当前需要处理的队首顶点</span></span><br><span class="line">		<span class="keyword">while</span> (k != <span class="number">-1</span>)<span class="comment">//扫描当前顶点所有的边</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dis[v[k]] &gt; dis[u[k]] + w[k])<span class="comment">//判断是否松弛成功</span></span><br><span class="line">			&#123;</span><br><span class="line">				dis[v[k]] = dis[u[k]] + w[k];<span class="comment">//更新顶点1到顶点v[k]的路程</span></span><br><span class="line">				<span class="comment">//这里的book数组用来判断顶点v[k]是否在队列中</span></span><br><span class="line">				<span class="comment">//如果不使用一个数组来标记的话，判断一个顶点是否在队列中每次都需要</span></span><br><span class="line">				<span class="comment">//从队列的head到tail扫一遍，很浪费时间</span></span><br><span class="line">				<span class="keyword">if</span> (book[v[k]] == <span class="number">0</span>)<span class="comment">//0表示不在队列中，将顶点v[k]加入队列中</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">//下面两句是入队操作</span></span><br><span class="line">					que[tail] = v[k];</span><br><span class="line">					tail++;</span><br><span class="line">					book[v[k]] = <span class="number">1</span>;<span class="comment">//同时标记顶点v[k]已经入队</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			k = next[k];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//出队</span></span><br><span class="line">		book[que[head]] = <span class="number">0</span>;</span><br><span class="line">		head++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出1号顶点到其余各点的最短路径</span></span><br><span class="line">	<span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, dis[i]);</span><br><span class="line"></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-5-节-最短路廮算法对比分析"><a class="header-anchor" href="#第-5-节-最短路廮算法对比分析">🌳</a>第 5 节 最短路廮算法对比分析</h3>
<p><img src="/2024/06/03/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BB%AE%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90.png" alt="最短路廮算法对比分析"></p>
<p>如 暜 要 求 的 是 所 昉 点 对 间 的 昀 短 路 径 , 或 者 如 暜 数 据 范 围 较 小 , 则 Floyd 算 法 比 较 适 合 。<br>
Dijkstra 算 法 昀 大 的 弊 端 是 它 无 法 适 应 昉 负 晃 边 的 图 . 但 是 Dijkstra 具 昉 良 好的 可 扩 展 性 , 扩展 后 可以 适 应 很 多 问 顾 。 古 外 用 堆 优 化 的 Dijkstra 算 法 的 时 间 复 時 度 可 以 达 到 O(MlogN).<br>
当边 昉负 晃 时 , 需 要 使 用 Bellman-Ford 算 法 或 者 队 列 优 化 的 Bellman-Ford 算 法 .</p>
<h2 id="第-7-章-神奇的树"><a class="header-anchor" href="#第-7-章-神奇的树">🌳</a>第 7 章 神奇的树</h2>
<h3 id="第-1-节-康启-树-之旅"><a class="header-anchor" href="#第-1-节-康启-树-之旅">🌳</a>第 1 节 康启“树”之旅</h3>
<p><img src="/2024/06/03/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%A0%91%E4%B8%8E%E5%9B%BE.png" alt="树与图"></p>
<h3 id="第-2-节-二叉树"><a class="header-anchor" href="#第-2-节-二叉树">🌳</a>第 2 节 二叉树</h3>
<h3 id="第-3-节-堆-神奇的优先队列"><a class="header-anchor" href="#第-3-节-堆-神奇的优先队列">🌳</a>第 3 节 堆——神奇的优先队列</h3>
<h4 id="最小堆"><a class="header-anchor" href="#最小堆">🌳</a>最小堆</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：堆排序（建立最小堆实现从小到大排序）</span></span><br><span class="line"><span class="comment">//	时间：2021.11.15 16点02分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> h[<span class="number">101</span>];<span class="comment">//用来存放堆的数组</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//用来存放堆中元素的个数，也就是堆的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换函数，用来交换队中两个元素的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	t = h[x];</span><br><span class="line">	h[x] = h[y];</span><br><span class="line">	h[y] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向下调整的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftdown</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//传入一个需要向下调整的结点编号i,即从堆的顶点开始向下调整</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t, flag = <span class="number">0</span>;<span class="comment">//flag用来标记是否需要继续向下调整</span></span><br><span class="line">	<span class="comment">//当i结点有儿子（其实是至少有左儿子）并且有需要继续调整的时候循环就执行</span></span><br><span class="line">	<span class="keyword">while</span> (i * <span class="number">2</span> &lt;= n &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//首先判断它和左儿子的关系，并用t记录值较小的结点编号</span></span><br><span class="line">		<span class="keyword">if</span> (h[i] &gt; h[i * <span class="number">2</span>])</span><br><span class="line">			t = i * <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t = i;</span><br><span class="line">		<span class="comment">//如果它有右儿子，再对右儿子进行讨论</span></span><br><span class="line">		<span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果右儿子的值更小，更新较小的结点编号</span></span><br><span class="line">			<span class="keyword">if</span> (h[t] &gt; h[i * <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">				t = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果发现最小的结点编号不是自己，说明子结点中有比父结点更小的</span></span><br><span class="line">		<span class="keyword">if</span> (t != i)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(t, i);<span class="comment">//交换它们</span></span><br><span class="line">			i = t;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			flag = <span class="number">1</span>;<span class="comment">//否则说明当前的父结点已经比两个子结点都要小了，不需要在进行调整</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立堆的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">//从最后一个非叶结点到第一个结点依次进行向上调整</span></span><br><span class="line">	<span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		siftdown(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除最大的元素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">deletemax</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	t = h[<span class="number">1</span>];<span class="comment">//用一个临时变量记录堆顶点的值</span></span><br><span class="line">	h[<span class="number">1</span>] = h[n];<span class="comment">//将堆的最后一个点赋值到堆顶</span></span><br><span class="line">	n--;<span class="comment">//堆的元素减少1</span></span><br><span class="line">	siftdown(<span class="number">1</span>);<span class="comment">//向下调整</span></span><br><span class="line">	<span class="keyword">return</span> t;<span class="comment">//返回之前记录的堆的顶点的最大值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, num;</span><br><span class="line">	<span class="comment">//读入要排序的数字个数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">	n = num;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//建堆</span></span><br><span class="line">	creat();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//删除顶部元素,连续删除n次，其实也就是从大到小把数输出出来</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, deletemax());</span><br><span class="line"></span><br><span class="line">	getchar(); getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大堆"><a class="header-anchor" href="#最大堆">🌳</a>最大堆</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：堆排序（建立最大堆实现从小到大排序）</span></span><br><span class="line"><span class="comment">//	时间：2021.11.15 16点44分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> h[<span class="number">101</span>];<span class="comment">//用来存放堆的数组</span></span><br><span class="line"><span class="type">int</span> n;<span class="comment">//用来存储堆中元素的个数，也就是堆的大小</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换函数，用来交换堆中的两个元素的值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	t = h[x];</span><br><span class="line">	h[x] = h[y];</span><br><span class="line">	h[y] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//向下调整函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftdown</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//传入一个需要向下调整的结点编号i，这里传入1，即从堆的顶点开始向下调整</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t, flag = <span class="number">0</span>;<span class="comment">//flag用来标记是否需要继续向下调整</span></span><br><span class="line">	<span class="comment">//当结点有儿子（其实是至少有左儿子）并且有需要继续调整的时候循环就执行</span></span><br><span class="line">	<span class="keyword">while</span> (i * <span class="number">2</span> &lt;= n &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//首先判断它和左儿子的关系，并且用t记录较大的结点编号</span></span><br><span class="line">		<span class="keyword">if</span> (h[i] &lt; h[i * <span class="number">2</span>])</span><br><span class="line">			t = i * <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			t = i;</span><br><span class="line">		<span class="comment">//如果它有右儿子，再对右儿子进行讨论</span></span><br><span class="line">		<span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果右儿子的值更大，更新较小的结点编号</span></span><br><span class="line">			<span class="keyword">if</span> (h[t] &lt; h[i * <span class="number">2</span> + <span class="number">1</span>])</span><br><span class="line">				t = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果发现最大的结点编号不是自己，说明子结点有比父结点更大的</span></span><br><span class="line">		<span class="keyword">if</span> (t != i)</span><br><span class="line">		&#123;</span><br><span class="line">			swap(t, i);<span class="comment">//交换它们</span></span><br><span class="line">			i = t;<span class="comment">//更新i为刚才与它交换的儿子结点的编号，便于接下来继续向下调整</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			flag = <span class="number">1</span>;<span class="comment">//否则说明当前的父结点已经比两个子结点都要大了，不需要再进行调整了</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立堆的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">creat</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">//从最后一个非叶结点到第一个结点依次进行向上调整</span></span><br><span class="line">	<span class="keyword">for</span> (i = n / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		siftdown(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">heapsort</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span> (n &gt; <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		swap(<span class="number">1</span>, n);</span><br><span class="line">		n--;</span><br><span class="line">		siftdown(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, num;</span><br><span class="line">	<span class="comment">//读入n个数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;num);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;h[i]);</span><br><span class="line">	n = num;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//建堆</span></span><br><span class="line">	creat();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//堆排序</span></span><br><span class="line">	heapsort();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//输出</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= num; i++)</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, h[i]);</span><br><span class="line"></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>支 持 插 入 元 素 和 寻 找 昀 大 〔 小 ) 值 元 素 的 数 据 结 暄称 为 优 先 队 列</p>
<p>使 用 普 通 队 列 晥 实 现 这 两 个 功 能 , 那 么 寻 找 昀 大 元 素 需 要 暚 举 整 个 队 列 ,这 朷 的 时 间 复 時 度 比 较高<br>
如 暜 是 已 排 序 好 的 数 组 , 那 么 插 入 一 个 元 素 则 需 要 移 动 很 多 元 素 ,时 间 复 時 度 依 旧 很 高 。<br>
而 堆 就 是 一 种 优 先 队 列 的 实 现 , 可 以 很 好 地 解 冯 这 两 种 操 作 。</p>
<p>堆 还 经 常 被 用 晥 求 一 个 数 列 中 第 K 大 的 数 ,<br>
只 需 要 建 立 一 个 大 小为 人 的 昀 小 堆 , 堆 项 就 是 第 人 大的 数 。<br>
假 设 昉 10 个 数 , 要 求 第 3 大 的 数 。<br>
第一 步 选 取 任 意 3 个 数 , 比 如 说 是 前 3 个 , 将 这 3 个 数 建 成 昀 小 堆 ,<br>
然 后 从 第 4 个 数 开 始 ,与堆 顶 的 数 比 较 , 如 暜 比 堆 顺 的 数 要 小 , 那 么 这 个 数 就 不 要 , 如 暜 比 堆 项 的 数 要 大 , 则 史 弃<br>
当前 堆 顶 而 将 这 个 数 做 为 新 的 堆 顶 , 并 再 去 维 护 堆 , 用 同 朷 的 方 法 去 处理 第 5-~10</p>
<h3 id="第-4-节-擒贼先擒王-并查集"><a class="header-anchor" href="#第-4-节-擒贼先擒王-并查集">🌳</a>第 4 节 擒贼先擒王——并查集</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：并查集</span></span><br><span class="line"><span class="comment">//	时间：2021.11.15 19点30分</span></span><br><span class="line"><span class="comment">//  目的：找出一共多少个犯罪团伙，其实就是找出多少个“祖宗”</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> f[<span class="number">1000</span>] = &#123; <span class="number">0</span> &#125;, n, m, k, sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//这里初始化，非常的重要，数组里面存的是自己数组下标的编号就好了</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		f[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这是找爹的递归函数，不停地去找爹，直到找到祖宗为止，其实就是去找犯罪团伙的最高领导人</span></span><br><span class="line"><span class="comment">//“擒贼先擒王”原则</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getf</span><span class="params">(<span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[v] == v)</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这里是路径压缩，每次在函数返回的时候，顺带把路上遇到的人的“BOSS”</span></span><br><span class="line">		<span class="comment">//改为最后找到的祖宗编号，也就是犯罪团伙的最高领导人编号。这样可以提高</span></span><br><span class="line">		<span class="comment">//今后找到犯罪团伙的最高领导人（其实是数的祖先）的速度</span></span><br><span class="line">		f[v] = getf(f[v]);</span><br><span class="line">		<span class="keyword">return</span> f[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里是合并两集合的函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t1, t2;</span><br><span class="line">	t1 = getf(v);</span><br><span class="line">	t2 = getf(u);</span><br><span class="line">	<span class="keyword">if</span> (t1 != t2)<span class="comment">//判断两个结点是否在一个集合中，即是否为一个祖先</span></span><br><span class="line">	&#123;</span><br><span class="line">		f[t2] = t1;</span><br><span class="line">		<span class="comment">//靠左原则，左边变成右边的BOSS，即把右边的集合，作为左边集合的子集合</span></span><br><span class="line">		<span class="comment">//经过路径压缩以后，将f[u]的根的值也赋值为v的祖先f[t1]</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, x, y;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//初始化是必须的</span></span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//开始合并犯罪团伙</span></span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">		merge(x, y);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最后扫描有多少个独立的犯罪团伙</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[i] == i)</span><br><span class="line">			sum++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, sum);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>实 树还昉 很 多 神 奇的 用 法 , 比 如 :</p>
<ul>
<li>线 段 树、</li>
<li>数 状数 组、</li>
<li>Trie 树( 字 典 树)、</li>
<li>二 叉 搜 索 树、</li>
<li>红 黑 树( 是一 种 平 衡 二 叉 搜 索 树) 等 等</li>
</ul>
<h2 id="第-8-章-更多精廠算法"><a class="header-anchor" href="#第-8-章-更多精廠算法">🌳</a>第 8 章 更多精廠算法</h2>
<h3 id="第-1-节-镖局运镖-图的最小生成树"><a class="header-anchor" href="#第-1-节-镖局运镖-图的最小生成树">🌳</a>第 1 节 镖局运镖——图的最小生成树</h3>
<h4 id="kruskal-最小生成树-并查集连通运用"><a class="header-anchor" href="#kruskal-最小生成树-并查集连通运用">🌳</a>kruskal 最小生成树 并查集连通运用</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="comment">//	算法：图的最小生成树</span></span><br><span class="line"><span class="comment">//	时间：2021.11.15 20点23分</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">int</span> u;</span><br><span class="line">	<span class="type">int</span> v;</span><br><span class="line">	<span class="type">int</span> w;</span><br><span class="line">&#125;;<span class="comment">//为了方便排序，这里创建了一个结构体用来存储边的关系</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> <span class="title">e</span>[10];</span><span class="comment">//数组大小根据实际情况来设置，要比m的最大值大1</span></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> f[<span class="number">7</span>] = &#123; <span class="number">0</span> &#125;, sum = <span class="number">0</span>, count = <span class="number">0</span>;<span class="comment">//并查集需要用到的一些变量</span></span><br><span class="line"><span class="comment">//f数组大小根据实际情况来设置，要比n的最大值大1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">quicksort</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i, j;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">edge</span> <span class="title">t</span>;</span></span><br><span class="line">	<span class="keyword">if</span> (left &gt; right)</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	i = left;</span><br><span class="line">	j = right;</span><br><span class="line">	<span class="keyword">while</span> (i != j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//顺序很重要，要从右边开始找</span></span><br><span class="line">		<span class="keyword">while</span> (e[j].w &gt;= e[left].w &amp;&amp; i &lt; j)</span><br><span class="line">			j--;</span><br><span class="line">		<span class="comment">//再从左边开始找</span></span><br><span class="line">		<span class="keyword">while</span> (e[i].w &lt;= e[left].w &amp;&amp; i &lt; j)</span><br><span class="line">			i++;</span><br><span class="line">		<span class="comment">//交换</span></span><br><span class="line">		<span class="keyword">if</span> (i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			t = e[i];</span><br><span class="line">			e[i] = e[j];</span><br><span class="line">			e[j] = t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//最终将基准数归位，将left和i互换</span></span><br><span class="line">	t = e[left];</span><br><span class="line">	e[left] = e[i];</span><br><span class="line">	e[i] = t;</span><br><span class="line"></span><br><span class="line">	quicksort(left, i - <span class="number">1</span>);<span class="comment">//继续处理左边的，这里是一个递归的过程</span></span><br><span class="line">	quicksort(i+<span class="number">1</span>, right);<span class="comment">//继续处理右边的，这里是一个递归的过程</span></span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//并查集寻找祖先的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getf</span><span class="params">(<span class="type">int</span> v)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (f[v] == v)</span><br><span class="line">		<span class="keyword">return</span> v;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//这里是路径压缩</span></span><br><span class="line">		f[v] = getf(f[v]);</span><br><span class="line">		<span class="keyword">return</span> f[v];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//并查集合并两子集合的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t1, t2;</span><br><span class="line">	t1 = getf(v);</span><br><span class="line">	t2 = getf(u);</span><br><span class="line">	<span class="keyword">if</span> (t1 != t2)<span class="comment">//判断两个点是否在同一个集合中</span></span><br><span class="line">	&#123;</span><br><span class="line">		f[t2] = t1;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="comment">//读入n和m，n表示顶点个数，m表示边的条数</span></span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="comment">//读入边，这里用一个结构体来存储边的关系</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;e[i].u, &amp;e[i].v, &amp;e[i].w);</span><br><span class="line"></span><br><span class="line">	quicksort(<span class="number">1</span>, m);<span class="comment">//按照权值从小到大对边进行快速排序</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//并查集初始化</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		f[i] = i;</span><br><span class="line">	<span class="comment">//Kruskal算法核心部分</span></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)<span class="comment">//开始从小到大枚举每一条边</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//判断一条边的两个顶点是否已经联通，即判断是否在一个集合中</span></span><br><span class="line">		<span class="keyword">if</span> (merge(e[i].u, e[i].v))<span class="comment">//如果目前尚未不连通，则选用这条边</span></span><br><span class="line">		&#123;</span><br><span class="line">			count++;</span><br><span class="line">			sum = sum + e[i].w;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (count == n - <span class="number">1</span>)<span class="comment">//直到选用了n-1条边之后退出循环</span></span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);<span class="comment">//打印结果</span></span><br><span class="line">	getchar();</span><br><span class="line">	getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="第-2-节-再谈最小生成树"><a class="header-anchor" href="#第-2-节-再谈最小生成树">🌳</a>第 2 节 再谈最小生成树</h3>
<p><a target="_blank" rel="noopener" href="https://www.cs.usfca.edu/~galles/visualization/Prim.html">Prim 最小生成树 可视化算法(Prim Minimum Cost Spanning Treeh)</a><br>
<a target="_blank" rel="noopener" href="https://algorithm-visualizer.org/greedy/prims-minimum-spanning-tree">Prim Minimum Cost Spanning Treeh</a></p>
<h4 id="prim-最小生成树-距离树最短路径的顶点搜索-时间复杂度-o-n²"><a class="header-anchor" href="#prim-最小生成树-距离树最短路径的顶点搜索-时间复杂度-o-n²">🌳</a>Prim 最小生成树 距离树最短路径的顶点搜索 时间复杂度 <em>O(N²)</em></h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> n,m,i,j,k,min,t1,t2,t3;</span><br><span class="line">	<span class="type">int</span> e[<span class="number">7</span>][<span class="number">7</span>],dis[<span class="number">7</span>],book[<span class="number">7</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="type">int</span> inf=<span class="number">99999999</span>;</span><br><span class="line">	<span class="type">int</span> count=<span class="number">0</span>,sum=<span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="keyword">if</span>(i==j) e[i][j]=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">else</span> e[i][j]=inf;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//开始读入边</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>,&amp;t1,&amp;t2,&amp;t3);</span><br><span class="line">		e[t1][t2]=t3;</span><br><span class="line">		e[t2][t1]=t3;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//初始化dis数组</span></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		dis[i]=e[<span class="number">1</span>][i];</span><br><span class="line"></span><br><span class="line">	book[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	count++;</span><br><span class="line">	<span class="keyword">while</span>(count&lt;n)</span><br><span class="line">	&#123;</span><br><span class="line">		min=inf;</span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(book[i]==<span class="number">0</span> &amp;&amp; dis[i]&lt;min)</span><br><span class="line">			&#123;</span><br><span class="line">				min=dis[i];</span><br><span class="line">				j=i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		book[j]=<span class="number">1</span>;</span><br><span class="line">		count++;</span><br><span class="line">		sum=sum+dis[j];</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(book[k]==<span class="number">0</span> &amp;&amp; dis[k]&gt;e[j][k])</span><br><span class="line">				dis[k]=e[j][k];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,sum);</span><br><span class="line"></span><br><span class="line">	getchar();getchar();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h4 id="prim-最小生成树-堆优化-邻接表-o-mlogn"><a class="header-anchor" href="#prim-最小生成树-堆优化-邻接表-o-mlogn">🌳</a>prim 最小生成树 堆优化+邻接表 <em>O</em>(<em>M</em>log<em>N</em>)</h4>
<p>把6个点放进堆中 扫描一个点的 边邻接表以后 就pop出直到所有点pop出</p>
<p>稀疏图：边的数量远小于顶点数量的平方（|E| &lt;&lt; |V|^2）的图称为稀疏图。这里的“远小于”是一个相对的概念，没有绝对的数值界限。</p>
<p>稠密图：边的数量接近顶点数量的平方（|E| ≈ |V|^2）的图称为稠密图。<br>
<img src="http://www.aiug.cn/wp-content/uploads/2024/09/%E7%A8%80%E7%96%8F%E5%9B%BE%E5%92%8C%E7%A8%A0%E5%AF%86%E5%9B%BE.png" alt="稀疏图&amp;稠密图"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> dis[<span class="number">7</span>], book[<span class="number">7</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// bookB A aR MET BA BOA RAE</span></span><br><span class="line"><span class="type">int</span> h[<span class="number">7</span>], pos[<span class="number">7</span>], size;    <span class="comment">// b 用 晥 保 存 堆 ,pos 用 晥 存 傅 每 个 顶 点 在 堆 中 的 位 繮 ,size 为 堆 的 大 小</span></span><br><span class="line"><span class="comment">// 交 换函数 , 用 米 交 换 堆 中 的 两 个 元 素 的 值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    t = h[x];</span><br><span class="line">    h[x] = h[y];</span><br><span class="line">    h[y] = t;</span><br><span class="line">    <span class="comment">// 同 步 更 新 pos</span></span><br><span class="line">    t = pos[h[x]];</span><br><span class="line">    pos[h[x]] = pos[h[y]];</span><br><span class="line">    pos[h[y]] = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向 下 调 整 函 数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">siftdown</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">// 优 入 一 个 霁 要 向 下 调 整 的 结 点 縖 号</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t, flag = <span class="number">0</span>; <span class="comment">// 5lag 用 晥 朇 记 是 否 需 要 继 续 向 下 调 整</span></span><br><span class="line">    <span class="keyword">while</span> (i * <span class="number">2</span> &lt;= size &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 比 较 i 和 它 左 儿 于 i42 在 ais 中 的 值 , 干 用 t 记 录 值 轼 小 的 结 点 縖 号</span></span><br><span class="line">        <span class="keyword">if</span> (dis[h[i]] &gt; dis[h[[i * <span class="number">2</span>]]])</span><br><span class="line">            t = i * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            t = i;</span><br><span class="line">        <span class="comment">// 加 暜 它 昉 右 儿 子 , 再 对 昉 儿 二 进 行 讨 论</span></span><br><span class="line">        <span class="keyword">if</span> (i * <span class="number">2</span> + <span class="number">1</span> &lt;= size)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 加 昨 昉 儿 子 的 值 更 小 , 更 新 较 小 的 结 点 縖号</span></span><br><span class="line">            <span class="keyword">if</span> (dis[h[[t]]] &gt; dis[h[i * <span class="number">2</span> + <span class="number">1</span>]])</span><br><span class="line">                t = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如 概 发 现 昀 小 的 结 点 縖 号 不 是 自 己 , 说 明 子 结 点 中 昉 比 父 结 点 更 尔 的</span></span><br><span class="line">        <span class="keyword">if</span> (t != i)</span><br><span class="line">        &#123;</span><br><span class="line">            swap(t, i) <span class="comment">// 交 换 它 们</span></span><br><span class="line">                i = t; <span class="comment">// 更 新 ; 为 刚 才 与 它 交 换 的 儿 孔 结 点 的 縖 号 , 便 于 接 下 米 继 续 向 下 调 整</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag = <span class="number">1</span>; <span class="comment">// 则 说 明 当 前 的 文 结 点 已 经 比 两 个 孔 结 点 都 要 小 了 , 不 霜 要 彷 进 行 调 孤 了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">siftup</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">// 传 入 一 个 需 要 向 上 调 整 的 结 点 縖 号</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>; <span class="comment">// 用 江朇 记 是 否 需 要 继 续 吊 上 调 整</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 如 暜 是 堆 顶 , 就 返 回 , 不 霜 要 调 驹 了</span></span><br><span class="line">    <span class="comment">// 不 在 堆 顶 , 并 东 当 前 结 点 3 的 值 比 文 结 点 小 的 时 候 继 续 向 上 调 整</span></span><br><span class="line">    <span class="keyword">while</span> (i != <span class="number">1</span> &amp;&amp; flag == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判 断 是 否 比 父 结 点 的 小</span></span><br><span class="line">        <span class="keyword">if</span> (dis[h[i]] &lt; dis[h[i / <span class="number">2</span>]])</span><br><span class="line">            swap(i, i / <span class="number">2</span>); <span class="comment">// RREME EEE</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            flag = <span class="number">1</span>; <span class="comment">// RAGA Hi SRE TAYE SC EEK</span></span><br><span class="line">        i = i / <span class="number">2</span>;    <span class="comment">// 这 句 话 很 重 要 , 更 新 縖 号 &#123; 为 它 父 结 点 的 縖 号 , 从 而 便 于 下 一 次 继 续 吊 上 调 整</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 从 堆 顶 取 出 一 个 元 素</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    t = h[<span class="number">1</span>];       <span class="comment">// 用 一 个 临 时 变 量 记 录 堆 顶 点 的 值</span></span><br><span class="line">    pos[t] = <span class="number">0</span>;     <span class="comment">// 其 实 这 句 要 不 要 无 所 谓</span></span><br><span class="line">    h[<span class="number">1</span>] = h[size]; <span class="comment">// 将 堆 的 昀 后 一 个 点 赔 值 到 绳 项</span></span><br><span class="line">    pos[h[<span class="number">1</span>]] = <span class="number">1</span>;</span><br><span class="line">    size--;      <span class="comment">// 堆 的 元 素 凑 少 1</span></span><br><span class="line">    siftdown(<span class="number">1</span>); <span class="comment">// 向 下 调 整</span></span><br><span class="line">    <span class="keyword">return</span> t;    <span class="comment">// 返 回 之 前 记 录 的 蜡 项 点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, m, i, j, k;</span><br><span class="line">    <span class="comment">// Vs w 和 next 的 数 组 大 小 要 朹 据 实 际 情 况 晥 设 繮 , 此 图 是 无 向 图 , 要 比 2 *m 的 昀 大 值 要 大 1</span></span><br><span class="line">    <span class="comment">// #izst 要 比 n 的 昀 大 值 要 大 1, 要 比 24m 的 昀 大 值 要 大 1</span></span><br><span class="line">    <span class="type">int</span> u[<span class="number">19</span>] v[<span class="number">19</span>], w[<span class="number">19</span>], sizet[<span class="number">7</span>], next[<span class="number">19</span>];</span><br><span class="line">    <span class="type">int</span> inf = <span class="number">99999999</span>;     <span class="comment">// 用 inf 《infini y 的 縩 冗 》 存 傅 一 个 我 们 认 为 的 正 无 穷 值</span></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>, sum = <span class="number">0</span>; <span class="comment">// count 用 朗 记 录 生 成 朑 中 顶 点 的 个 数 ,sum 用 晥 存 借 路 往 之 和</span></span><br><span class="line">    <span class="comment">// 读 入 nm,n 表 示 顶 店 个 数 ,m 表 示 边 的 晡 数</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读 入 边</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;u[i], &amp;v[i], &amp;w[i]);</span><br><span class="line">    <span class="comment">// 这 里 是 无 向 图 , 所 以 需 要 将 所 昉 的 边 再 反 向 存 倩 一 次</span></span><br><span class="line">    <span class="keyword">for</span> (i = m + <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        u[i] = v[i - m];</span><br><span class="line">        v[i] = u[i - m];</span><br><span class="line">        w[i] = w[i - m];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开 始使 用 邻 接 表 存 傅 边</span></span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= n; i++)</span><br><span class="line">        first[i] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        next[i] = first[u[i]];</span><br><span class="line">        first[u[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2rim 朸 心部分 开 始</span></span><br><span class="line">    <span class="comment">//  将 2 号 顶 点 加 入 生 或 朑</span></span><br><span class="line">    book[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 这 里 用 book 暗 朇 记 一 个 项 点 已 经 加 入 生 成 朑</span></span><br><span class="line">    count++;</span><br><span class="line">    <span class="comment">// 初 始 化 ais 数 组 , 这 里 是 1 号 顶 点 到 其 余 各 个 顶 点 的 初 始 跌 高</span></span><br><span class="line">    dis[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        dis[i] = inf;</span><br><span class="line">    k = first[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (k != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dis[v[k]] = w[k];</span><br><span class="line">        k = next[k];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初 始 化 堆</span></span><br><span class="line">    size = n;</span><br><span class="line">    <span class="keyword">for</span> (i = l; i &lt;= size; i++)</span><br><span class="line">        &#123;h[i] = i; pos[i]=i&#125;</span><br><span class="line">    <span class="keyword">for</span> (i = size / <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">        siftdown(i);</span><br><span class="line"></span><br><span class="line">    pop(); <span class="comment">// 先 弹 出 一 个 堆 顶 元 素 , 因 为 此 时 堆 顶 是 1 号 顶 点</span></span><br><span class="line">    <span class="keyword">while</span> (count &lt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        j = pop();</span><br><span class="line">        book[j] = <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">        sum = sum + dis[j];</span><br><span class="line">        k = first[j];</span><br><span class="line">        <span class="keyword">while</span> (k != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (book[v[k]] == <span class="number">0</span> &amp;&amp; dis[v[k]] &gt; w[k])</span><br><span class="line">            &#123;</span><br><span class="line">                dis[v[k]] = w[k];</span><br><span class="line">                siftup(pos[v[k]]);</span><br><span class="line">            &#125;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum);</span><br><span class="line">    getchar();</span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-3-节-重要城市-图的割点"><a class="header-anchor" href="#第-3-节-重要城市-图的割点">🌳</a>第 3 节 重要城市——图的割点</h3>
<iframe src="https://player.bilibili.com/player.html?isOutside=true&aid=883492649&bvid=BV1ZK4y1x7dm&cid=198468710&p=1&autoplay=0" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> graph[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], parent[MAXN];</span><br><span class="line"><span class="type">int</span> isCut[MAXN];</span><br><span class="line"><span class="type">int</span> timeCounter;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    dfn[u] = low[u] = ++timeCounter;</span><br><span class="line">    <span class="type">int</span> children = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[u][v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                children++;</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                tarjan(v, n);</span><br><span class="line">                low[u] = (low[u] &lt; low[v]) ? low[u] : low[v];</span><br><span class="line">                <span class="keyword">if</span> (parent[u] == <span class="number">-1</span> &amp;&amp; children &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                    isCut[u] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (parent[u] != <span class="number">-1</span> &amp;&amp; low[v] &gt;= dfn[u]) &#123;</span><br><span class="line">                    isCut[u] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v != parent[u]) &#123;</span><br><span class="line">                low[u] = (low[u] &lt; dfn[v]) ? low[u] : dfn[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph));</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">    <span class="built_in">memset</span>(parent, <span class="number">-1</span>, <span class="keyword">sizeof</span>(parent));</span><br><span class="line">    <span class="built_in">memset</span>(isCut, <span class="number">0</span>, <span class="keyword">sizeof</span>(isCut));</span><br><span class="line">    timeCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        graph[u][v] = <span class="number">1</span>;</span><br><span class="line">        graph[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">            tarjan(i, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCut[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Cut vertex: %d\n&quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-4-节-关键道路-图的割边"><a class="header-anchor" href="#第-4-节-关键道路-图的割边">🌳</a>第 4 节 关键道路——图的割边</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 1000</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> graph[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dfn[MAXN], low[MAXN], parent[MAXN];</span><br><span class="line"><span class="type">int</span> timeCounter;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tarjan</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    dfn[u] = low[u] = ++timeCounter;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">0</span>; v &lt; n; v++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (graph[u][v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">                parent[v] = u;</span><br><span class="line">                tarjan(v, n);</span><br><span class="line">                low[u] = (low[u] &lt; low[v]) ? low[u] : low[v];</span><br><span class="line">                <span class="keyword">if</span> (low[v] &gt; dfn[u]) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;Bridge: %d - %d\n&quot;</span>, u, v);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v != parent[u]) &#123;</span><br><span class="line">                low[u] = (low[u] &lt; dfn[v]) ? low[u] : dfn[v];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="built_in">memset</span>(graph, <span class="number">0</span>, <span class="keyword">sizeof</span>(graph));</span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="keyword">sizeof</span>(dfn));</span><br><span class="line">    <span class="built_in">memset</span>(low, <span class="number">0</span>, <span class="keyword">sizeof</span>(low));</span><br><span class="line">    <span class="built_in">memset</span>(parent, <span class="number">-1</span>, <span class="keyword">sizeof</span>(parent));</span><br><span class="line">    timeCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        graph[u][v] = <span class="number">1</span>;</span><br><span class="line">        graph[v][u] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[i]) &#123;</span><br><span class="line">            tarjan(i, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="第-5-节-我要做月老-二分图最大匹配"><a class="header-anchor" href="#第-5-节-我要做月老-二分图最大匹配">🌳</a>第 5 节 我要做月老——二分图最大匹配</h3>
<h4 id="概念性的东西-二分图-匈牙利算法-增广路算法"><a class="header-anchor" href="#概念性的东西-二分图-匈牙利算法-增广路算法">🌳</a>概念性的东西 二分图 匈牙利算法 增广路算法</h4>
<h2 id="第-9-章-还能更好吗-币软亚洲研究院面试"><a class="header-anchor" href="#第-9-章-还能更好吗-币软亚洲研究院面试">🌳</a>第 9 章 还能更好吗——币软亚洲研究院面试</h2>
<h4 id="我的第一本算法书"><a class="header-anchor" href="#我的第一本算法书">🌳</a>我的第一本算法书</h4>
<p>序章算法的基本知识001<br>
0-1什么是算法002<br>
0-2运行时间的计算方法007<br>
第1章数据结构009<br>
1-1什么是数据结构010<br>
1-2链表013<br>
1-3数组016<br>
1-4栈020<br>
1-5队列022<br>
1-6哈希表024<br>
1-7堆032<br>
1-8二叉查找树036<br>
第2章排序043<br>
2-1什么是排序044<br>
2-2冒泡排序046<br>
2-3选择排序050<br>
2-4插入排序052<br>
2-5堆排序056<br>
2-6归并排序060<br>
2-7快速排序064<br>
第3章数组的查找071<br>
3-1线性查找072<br>
3-2二分查找074<br>
第4章图的搜索077<br>
4-1什么是图078<br>
4-2广度优先搜索082<br>
4-3深度优先搜索086<br>
4-4贝尔曼-福特算法090<br>
4-5狄克斯特拉算法096<br>
4-6A算法103<br>
第5章安全算法107<br>
5-1安全和算法108<br>
5-2加密的基础知识112<br>
5-3哈希函数116<br>
5-4共享密钥加密120<br>
5-5公开密钥加密124<br>
5-6混合加密132<br>
5-7迪菲-赫尔曼密钥交换136<br>
5-8消息认证码144<br>
5-9数字签名152<br>
5-10数字证书158<br>
第6章聚类165<br>
6-1什么是聚类166<br>
6-2k-means算法168<br>
第7章其他算法173<br>
7-1欧几里得算法174<br>
7-2素性测试178<br>
7-3网页排名182<br>
7-4汉诺塔190</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zirpon.github.io">チャン ゼプン</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zirpon.github.io/2024/06/03/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">https://zirpon.github.io/2024/06/03/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://zirpon.github.io" target="_blank">Zepung🐉Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E4%B9%A6/">读书</a><a class="post-meta__tags" href="/tags/%E6%8E%92%E5%BA%8F/">排序</a></div><div class="post-share"><div class="social-share" data-image="/img/header_img/th%20(3).jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2024/06/03/%E5%85%8D%E8%B4%B9-%E9%9B%B6%E5%9F%BA%E7%A1%80%E8%87%AA%E8%A1%8C%E5%8A%A8%E6%89%8B-pdf%E8%BD%AC%E6%96%87%E5%AD%97/" title="免费 零基础自行动手 pdf转文字"><img class="cover" src="/img/header_img/th%20(9).jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">免费 零基础自行动手 pdf转文字</div></div><div class="info-2"><div class="info-item-1">免费 零基础自行动手 pdf转文字 🌳工具 ocrmypdf 文档 ocrmypdf 文档 官网具体下载教程 Ghostscript 下载地址  Python 64-bit Tesseract 64-bit Ghostscript 64-bit  123winget install -e --id Python.Python.3.11winget install -e --id UB-Mannheim.TesseractOCRpython3 -m pip install ocrmypdf 🌳当前目录 批量转化pdf为可复制文字的图片 执行代码 代码文件 1python ./batch.py &#x27;.&#x27; 🌳batch.py 源码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env python3from __future__ import annotationsimport...</div></div></div></a><a class="pagination-related" href="/2024/06/20/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC/" title="油猴脚本"><img class="cover" src="/img/header_img/th.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">油猴脚本</div></div><div class="info-2"><div class="info-item-1">斗鱼开播提醒 🌳🌎使用方法  打开斗鱼关注页面(https://www.douyu.com/directory/myFollow) 并放置在后台 有主播开播/更改标题时自动发送通知提醒  🌳💼Plus功能  [x] 下播提醒 [x] 每次提醒重新刷新 关注页面 [x] 最近10条历史通知 弹窗查看 [x] 彩虹旋转边框环绕带牌子直播间  [x] 视频轮播 单元格窗口 置灰 （鼠标移至视频轮播单元格仍然可以预览视频轮播内容）  [x] 粤语/国语 语音播报 改标题/下播/开播 提醒   🌳🚀版本更新  3.4.10   [x] 关闭历史通知 不再弹窗提示刷新网页 [x] 把 我的关注 里 视频轮播 的单元格置灰 [x] 增加主页/更新按钮 [x] 开播下播历史通知逆时排序 先看最近的 [x] 只保留最近10条历史通知   3.3.6   [x] 关闭系统通知时 用页面常驻弹窗通知   3.3.5   [x] 3.3.5 油猴脚本工程化项目 版本更新   3.3.4   [x] 增加通知提醒开关按钮   3.3.3   [x]...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2024/07/07/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/" title="算法笔记"><img class="cover" src="/img/header_img/th%20(1).jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-07</div><div class="info-item-2">算法笔记</div></div><div class="info-2"><div class="info-item-1">算法笔记 🌳游戏排名算法  Elo  Here is a footnote reference,[^1] and another.[^longnote] 🌳经典算法  bfprt 贪心算法 排序算法 算法可视化网站 算法可视化网站s  🌳KMP算法 Knuth-Morris-Pratt 🌳引用资料  bilibili搬运】油管阿三哥讲KMP查找算法，中英文字幕，人工翻译，简单易懂 视频github源码地址 已下载源码文件 SubstringSearch 最浅显易懂的 KMP 算法讲解 绝对能看懂的kmp算法，超清晰多图，一步步详解！ next-&gt;nextval，kmp算法的改良理解 真正把kmp算法中的next数组含义和求法讲明白   🌳KMP算法中的前缀和后缀  前缀是指以串第一个字符开头且不包含最后一个元素的连续的子串 后缀是指以串最后一个字符结尾且不包含第一个元素的连续的子串  在KMP算法中，前缀和后缀的概念被用来构建部分匹配表（Partial Match Table），以提高字符串匹配的效率 🌳部分匹配表的构建...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-text">啊哈算法 读书笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-1-%E7%AB%A0-%E4%B8%80%E5%A4%A7%E6%B3%A2%E6%95%B0%E6%AD%A3%E5%9C%A8%E9%9D%A0%E8%BF%91-%E6%8E%92%E5%BA%8F-1"><span class="toc-text">🌳第 1 章 一大波数正在靠近——排序 1</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E8%8A%82-%E6%9C%80%E5%B8%9B%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E6%8E%92%E5%BA%8F-%E6%A1%B6%E6%8E%92%E5%BA%8F-2"><span class="toc-text">🌳第 1 节 最帛最简单的排序——桶排序 2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E8%8A%82-%E9%82%BB%E5%B1%85%E5%A5%BD%E8%AF%B4%E8%AF%9D-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-7"><span class="toc-text">🌳第 2 节 邻居好说话——冒泡排序 7</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E8%8A%82-%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">🌳第 3 节 最常用的排序——快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E8%8A%82-%E5%B0%8F%E5%93%BC%E4%B9%B0%E4%B9%A6-20"><span class="toc-text">🌳第 4 节 小哼买书 20</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-2-%E7%AB%A0-%E6%A0%88-%E9%98%9F%E5%88%97-%E9%93%BE%E8%A1%A8"><span class="toc-text">🌳第 2 章 栈、队列、链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E8%8A%82-%E8%A7%A3%E5%AF%86-qq-%E5%8F%B7-%E9%98%9F%E5%88%97"><span class="toc-text">🌳第 1 节 解密 QQ 号——队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E8%8A%82-%E8%A7%A3%E5%AF%86%E5%9B%9E%E6%96%87-%E6%A0%88"><span class="toc-text">🌳第 2 节 解密回文——栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E8%8A%82-%E7%BA%B8%E7%89%8C%E6%B8%B8%E6%88%8F-%E5%B0%8F%E7%8C%AB%E9%92%93%E9%B1%BC-35"><span class="toc-text">🌳第 3 节 纸牌游戏——小猫钓鱼 35</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E8%8A%82-%E9%93%BE%E8%A1%A8"><span class="toc-text">🌳第 4 节 链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-5-%E8%8A%82-%E6%A8%A1%E6%8B%9F%E9%93%BE%E8%A1%A8-54"><span class="toc-text">🌳第 5 节 模拟链表 54</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-3-%E7%AB%A0-%E6%9E%9A%E4%B8%BE-%E5%BB%B1%E6%9A%B4%E5%8A%9B-57"><span class="toc-text">🌳第 3 章 枚举！廱暴力 57</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E8%8A%82-%E5%9D%91%E7%88%B9%E7%9A%84%E5%A5%A5%E6%95%B0-58"><span class="toc-text">🌳第 1 节 坑爹的奥数 58</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E8%8A%82-%E7%82%B8%E5%BB%90%E4%BA%BA"><span class="toc-text">🌳第 2 节 炸廐人</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E8%8A%82-%E7%81%AB%E6%9F%B4%E6%A3%8D%E7%AD%89%E5%BA%BF-67"><span class="toc-text">🌳第 3 节 火柴棍等庿 67</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E8%8A%82-%E6%95%B0%E7%9A%84%E5%85%A8%E6%8E%92%E5%88%97-70"><span class="toc-text">🌳第 4 节 数的全排列 70</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-4-%E7%AB%A0-%E4%B8%87%E8%83%BD%E7%9A%84%E6%90%9C%E7%B4%A2"><span class="toc-text">🌳第 4 章 万能的搜索</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E8%8A%82-%E4%B8%8D%E6%92%9E%E5%8D%97%E5%A2%99%E4%B8%8D%E5%9B%9E%E5%A4%B4-%E6%B7%B1%E5%BA%9E%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-73"><span class="toc-text">🌳第 1 节 不撞南墙不回头——深庞优先搜索 73</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E8%8A%82-%E8%A7%A3%E6%95%91%E5%B0%8F%E5%93%88-81"><span class="toc-text">🌳第 2 节 解救小哈 81</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E8%8A%82-%E5%B1%82%E5%B1%82%E9%80%92%E8%BF%9B-%E5%B9%BF%E5%BA%9E%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2"><span class="toc-text">🌳第 3 节 层层递进——广庞优先搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E8%8A%82-%E5%86%8D%E8%A7%A3%E7%82%B8%E5%BB%90%E4%BA%BA-95"><span class="toc-text">🌳第 4 节 再解炸廐人 95</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E8%A7%A3%E6%B3%95"><span class="toc-text">🌳广度优先搜索 解法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-%E8%A7%A3%E6%B3%95"><span class="toc-text">🌳深度优先搜索 解法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-5-%E8%8A%82-%E5%AE%9D%E5%B2%9B%E6%8E%A2%E9%99%A9"><span class="toc-text">🌳第 5 节 宝岛探险</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E6%90%9C%E7%B4%A2"><span class="toc-text">🌳广度搜索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%8E%A2%E7%B4%A2"><span class="toc-text">🌳深度探索</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-6-%E8%8A%82-%E6%B0%B4%E7%AE%A1%E5%B7%A5%E6%B8%B8%E6%88%8F-117"><span class="toc-text">🌳第 6 节 水管工游戏 117</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-5-%E7%AB%A0-%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86-128"><span class="toc-text">🌳第 5 章 图的遍历 128</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E8%8A%82-%E6%B7%B1%E5%BA%9E%E5%92%8C%E5%B9%BF%E5%BA%9E%E4%BC%98%E5%85%88%E7%A9%B6%E7%AB%9F%E6%98%AF%E6%8C%87%E5%95%A5-129"><span class="toc-text">🌳第 1 节 深庞和广庞优先究竟是指啥 129</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86%E5%9B%BE"><span class="toc-text">🌳深度优先搜索遍历图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%E9%81%8D%E5%8E%86%E5%9B%BE"><span class="toc-text">🌳广度优先搜索遍历图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E8%8A%82-%E5%9F%8E%E5%B8%82%E5%9C%B0%E5%9B%BE-%E5%9B%BE%E7%9A%84%E6%B7%B1%E5%BA%9E%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-text">🌳第 2 节 城市地图——图的深庞优先遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E8%8A%82-%E6%9C%80%E5%B0%91%E8%BD%AC%E6%9C%BA-%E5%9B%BE%E7%9A%84%E5%B9%BF%E5%BA%9E%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86"><span class="toc-text">🌳第 3 节 最少转机——图的广庞优先遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-6-%E7%AB%A0-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BB%AE"><span class="toc-text">🌳第 6 章 最短路廮</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E8%8A%82-%E5%8F%AA%E6%9C%89%E4%BA%94%E8%A1%8C%E7%9A%84%E7%AE%97%E6%B3%95-floyd-warshall"><span class="toc-text">🌳第 1 节 只有五行的算法——Floyd-Warshall</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E8%8A%82-dijkstra-%E7%AE%97%E6%B3%95-%E9%80%9A%E8%BF%87%E8%BE%B9%E5%AE%9E%E7%8E%B0%E6%9D%BE%E5%BB%85-155"><span class="toc-text">🌳第 2 节 Dijkstra 算法——通过边实现松廅 155</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-text">🌳数据结构：邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-text">🌳数据结构：邻接表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E8%8A%82-bellman-ford-%E8%A7%A3%E5%86%B3%E8%B4%9F%E6%9D%83%E8%BE%B9"><span class="toc-text">🌳第 3 节 Bellman-Ford——解决负权边</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E8%8A%82-bellman-ford-%E7%9A%84%E9%98%9F%E5%88%97%E4%BC%98%E5%8C%96"><span class="toc-text">🌳第 4 节 Bellman-Ford 的队列优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-5-%E8%8A%82-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BB%AE%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90"><span class="toc-text">🌳第 5 节 最短路廮算法对比分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-7-%E7%AB%A0-%E7%A5%9E%E5%A5%87%E7%9A%84%E6%A0%91"><span class="toc-text">🌳第 7 章 神奇的树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E8%8A%82-%E5%BA%B7%E5%90%AF-%E6%A0%91-%E4%B9%8B%E6%97%85"><span class="toc-text">🌳第 1 节 康启“树”之旅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E8%8A%82-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">🌳第 2 节 二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E8%8A%82-%E5%A0%86-%E7%A5%9E%E5%A5%87%E7%9A%84%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97"><span class="toc-text">🌳第 3 节 堆——神奇的优先队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%A0%86"><span class="toc-text">🌳最小堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%A4%A7%E5%A0%86"><span class="toc-text">🌳最大堆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E8%8A%82-%E6%93%92%E8%B4%BC%E5%85%88%E6%93%92%E7%8E%8B-%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-text">🌳第 4 节 擒贼先擒王——并查集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-8-%E7%AB%A0-%E6%9B%B4%E5%A4%9A%E7%B2%BE%E5%BB%A0%E7%AE%97%E6%B3%95"><span class="toc-text">🌳第 8 章 更多精廠算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-1-%E8%8A%82-%E9%95%96%E5%B1%80%E8%BF%90%E9%95%96-%E5%9B%BE%E7%9A%84%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">🌳第 1 节 镖局运镖——图的最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kruskal-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%B9%B6%E6%9F%A5%E9%9B%86%E8%BF%9E%E9%80%9A%E8%BF%90%E7%94%A8"><span class="toc-text">🌳kruskal 最小生成树 并查集连通运用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-2-%E8%8A%82-%E5%86%8D%E8%B0%88%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">🌳第 2 节 再谈最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#prim-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E8%B7%9D%E7%A6%BB%E6%A0%91%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E9%A1%B6%E7%82%B9%E6%90%9C%E7%B4%A2-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6-o-n%C2%B2"><span class="toc-text">🌳Prim 最小生成树 距离树最短路径的顶点搜索 时间复杂度 O(N²)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prim-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91-%E5%A0%86%E4%BC%98%E5%8C%96-%E9%82%BB%E6%8E%A5%E8%A1%A8-o-mlogn"><span class="toc-text">🌳prim 最小生成树 堆优化+邻接表 O(MlogN)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-3-%E8%8A%82-%E9%87%8D%E8%A6%81%E5%9F%8E%E5%B8%82-%E5%9B%BE%E7%9A%84%E5%89%B2%E7%82%B9"><span class="toc-text">🌳第 3 节 重要城市——图的割点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-4-%E8%8A%82-%E5%85%B3%E9%94%AE%E9%81%93%E8%B7%AF-%E5%9B%BE%E7%9A%84%E5%89%B2%E8%BE%B9"><span class="toc-text">🌳第 4 节 关键道路——图的割边</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC-5-%E8%8A%82-%E6%88%91%E8%A6%81%E5%81%9A%E6%9C%88%E8%80%81-%E4%BA%8C%E5%88%86%E5%9B%BE%E6%9C%80%E5%A4%A7%E5%8C%B9%E9%85%8D"><span class="toc-text">🌳第 5 节 我要做月老——二分图最大匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E6%80%A7%E7%9A%84%E4%B8%9C%E8%A5%BF-%E4%BA%8C%E5%88%86%E5%9B%BE-%E5%8C%88%E7%89%99%E5%88%A9%E7%AE%97%E6%B3%95-%E5%A2%9E%E5%B9%BF%E8%B7%AF%E7%AE%97%E6%B3%95"><span class="toc-text">🌳概念性的东西 二分图 匈牙利算法 增广路算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC-9-%E7%AB%A0-%E8%BF%98%E8%83%BD%E6%9B%B4%E5%A5%BD%E5%90%97-%E5%B8%81%E8%BD%AF%E4%BA%9A%E6%B4%B2%E7%A0%94%E7%A9%B6%E9%99%A2%E9%9D%A2%E8%AF%95"><span class="toc-text">🌳第 9 章 还能更好吗——币软亚洲研究院面试</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E7%AE%97%E6%B3%95%E4%B9%A6"><span class="toc-text">🌳我的第一本算法书</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright"></div>&copy;2019 - 2025 By チャン ゼプン<div class="framework-info"></div><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>