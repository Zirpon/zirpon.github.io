<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>高质量C++读书笔记 | Zepung🐉Blog</title><meta name="author" content="チャン ゼプン"><meta name="copyright" content="チャン ゼプン"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="cppreference.com 高质量C++1. C++&#x2F;C 程序 基本概念内存页缺页中断 页面调度 页面交换 动态内存分配 运行时搜索 ocrmypdf  --sidecar test4.txt -l chi_sim+eng --deskew --jobs 4 -s 高质量程序设计指南_C++_C语言_第三版_扫描版.pdf test4.pdf 内部名称 _main C的连接规范C语">
<meta property="og:type" content="article">
<meta property="og:title" content="高质量C++读书笔记">
<meta property="og:url" content="https://zirpon.github.io/2023/05/31/C++/index.html">
<meta property="og:site_name" content="Zepung🐉Blog">
<meta property="og:description" content="cppreference.com 高质量C++1. C++&#x2F;C 程序 基本概念内存页缺页中断 页面调度 页面交换 动态内存分配 运行时搜索 ocrmypdf  --sidecar test4.txt -l chi_sim+eng --deskew --jobs 4 -s 高质量程序设计指南_C++_C语言_第三版_扫描版.pdf test4.pdf 内部名称 _main C的连接规范C语">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zirpon.github.io/img/header_img/tag-bg.png">
<meta property="article:published_time" content="2023-05-30T22:25:21.000Z">
<meta property="article:modified_time" content="2025-03-17T13:55:17.116Z">
<meta property="article:author" content="チャン ゼプン">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zirpon.github.io/img/header_img/tag-bg.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "高质量C++读书笔记",
  "url": "https://zirpon.github.io/2023/05/31/C++/",
  "image": "https://zirpon.github.io/img/header_img/tag-bg.png",
  "datePublished": "2023-05-30T22:25:21.000Z",
  "dateModified": "2025-03-17T13:55:17.116Z",
  "author": [
    {
      "@type": "Person",
      "name": "チャン ゼプン",
      "url": "https://zirpon.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/timg.jpeg"><link rel="canonical" href="https://zirpon.github.io/2023/05/31/C++/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高质量C++读书笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background: linear-gradient(20deg, #0062be, #925696, #cc426e, #fb0347);"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/IMG_5015.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">70</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/header_img/tag-bg.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/img/timg.jpeg" alt="Logo"><span class="site-name">Zepung🐉Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">高质量C++读书笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">高质量C++读书笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-30T22:25:21.000Z" title="发表于 2023-05-31 06:25:21">2023-05-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-17T13:55:17.116Z" title="更新于 2025-03-17 21:55:17">2025-03-17</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">27.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>103分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5">cppreference.com</a></p>
<h1 id="高质量C"><a href="#高质量C" class="headerlink" title="高质量C++"></a>高质量C++</h1><h2 id="1-C-C-程序-基本概念"><a href="#1-C-C-程序-基本概念" class="headerlink" title="1. C++&#x2F;C 程序 基本概念"></a>1. C++&#x2F;C 程序 基本概念</h2><p>内存页<br>缺页中断 页面调度 页面交换</p>
<p>动态内存分配 运行时搜索</p>
<p><code>ocrmypdf  --sidecar test4.txt -l chi_sim+eng --deskew --jobs 4 -s 高质量程序设计指南_C++_C语言_第三版_扫描版.pdf test4.pdf</code></p>
<p>内部名称 <code>_main</code></p>
<p>C的连接规范<br>C语言中<br>编译单元（文件作用域） static函数<br>extern 连接类型 global 作用域的 全局函数</p>
<p>C++<br>作用域：编译单元 class struct union namespace<br>同一个作用域同名函数 —— 重载函数</p>
<p>name-manglin </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sample_1</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> m_name[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span>* newName)</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> age)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sample_1_foo@pch@<span class="number">1</span> </span><br><span class="line">Sample_1_foo@<span class="type">int</span>@<span class="number">1</span> </span><br><span class="line">Sample <span class="number">2</span>_foo@pch@<span class="number">1</span></span><br><span class="line">Sample_2_foo@<span class="type">int</span>@<span class="number">1</span></span><br><span class="line">Lippman的《inside The C++ object model》</span><br></pre></td></tr></table></figure>
<p>连接规范 linkage specification</p>
<p>关系到编译器采用什么样的name-mangling方案重命名这些标识符的问题</p>
<p>同一个标识符在不同的编译单元或模块中具有不一致的连接规范 就会产生不一致的内部名称 导致程序连接失败</p>
<p>通用连接规范属 C连接规范 extern “C”</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类型 函数 变量 常量 指定连接规范</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="type">void</span> <span class="title">WinMainCRTStartup</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="type">const</span> CLSID CLSID_DataConverter;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="keyword">struct</span> <span class="title class_">Student</span> &#123;......&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> Student g_Student;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码限定连接规范</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明指定某个标识符 连接规范为 exter&quot;C&quot; 其对应定义也要指定extern &quot;C&quot;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> _cdecl <span class="title">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>*, <span class="type">const</span> <span class="type">void</span>*, <span class="type">sizt_t</span>)</span></span>; <span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> _cdecl <span class="title">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span>* p, <span class="type">const</span> <span class="type">void</span>* a , <span class="type">sizt_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	....<span class="comment">//功能实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>C++&#x2F;C 中 ， 全 局 变量 (extern或 static 的 ) 存放 在 程序 的 静态数据 区<br>全 局 变量 提供 初 值 编 译器会 自动 地将 0 转换 所 需要 的 类 型 来 初始 化 它们</p>
<p>无 法 决定 当两 个 编译 单元连接 在 一 起 时 哪 一 个 的 全 局 变量 的 初始 化 于 另 一 个 编译 单元 的 全 局变量 的 初始 化</p>
<p>启动 函数 、IO 系统 函 数 存储 管理 、RTTI、 动态决议 动 态 链接 〈DLL) 等 都 会 调用 C 运行 时 库中 的 函数<br>C 运行 时 有 多 线程 和 单线 程</p>
<p>编译 预 处 理 、 编译 和 连接 器 工作 的 阶段 合 “ 编 译 ”。</p>
<p>预 编译 伪 指令 类 〈 型 定义 外部 对 象 声 、 函 数 原型、 标识符 、 各 种修饰符号 (const、static 等 ) 及 类 成 员 的访问说 明 符 (public、private、protected) 和 连接 规范 调 用 规范 等仅在 编译 器进行 语法检查 、 语 义 检查 和 生成 目标文件 〈.obj 或 .o 文件 ) 及 连接 的 时 候起 作用 的</p>
<p>容器 越界，访问 虚 函数 ，动态 决议 ，函 数 动态 连接 、 动 内 存 分 配 异 常 处 和 RTTI等则 是在 运行 时 才 会 出 和 发 作用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pInt = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line">pint += <span class="number">100</span>;                         <span class="comment">// 越界 但 是 还 没有 形成 越界 访问</span></span><br><span class="line">cout &lt;&lt; *pInt&lt;&lt;endl;          <span class="comment">// 越界 访问 ! 可 能 行 也 可 能 不 !</span></span><br><span class="line">*pInt = <span class="number">1000</span>;                      <span class="comment">// 越界访问 ! 即使偶尔 不 出问题 但 不能 确保永远不 出问题 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span> </span>&#123; cout&lt;&lt; <span class="string">&quot;Base::Say() was invoked!\n&quot;</span>; </span><br><span class="line">&#125;;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>: / 改变 访问 权限 合 法但 不 是好 风格 !</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Say</span><span class="params">()</span></span>&#123; cout &lt;&lt; “Derived::<span class="built_in">Say</span>() was invoked!\n”;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line">Base *p = <span class="keyword">new</span> Derived;</span><br><span class="line">p-&gt;<span class="built_in">Say</span>(); <span class="comment">//输出: Derived::Say() was invoked !</span></span><br><span class="line"><span class="comment">// 出 乎 意料 地绑 定 到 了 一 private 函数 身上 </span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>独立编译技术<br>每 一 个 源代| 码 文件 〈 源 文件 及 其 递归 包含 的 有 头 文件 展开 ) 就 是 一 个 最小 的 编译 单元 每 个 编译 单元 可 以独立 编译 而不 需要 知道 他 编译 单元 的 存在 及 其 编译 结果 。</p>
<p>32位 操作 系统 上 ，int 类 型 的 变量 就 拥有 4 字 节 的 内 存单 元 而 double 类 型 的 变量 占 8 字 节 的 内 存单</p>
<pre><code>标准 C 语言 支持 基本 〈 内 ) 数据 类 有 int、long、float、double、char、void， 以 及 它们 和 signed、unsigned、*、&amp; 等 的 组 《 有些组 合 是 不 支持 的 例 如 void&amp; )。 标准 C++ 在 这 些 类 型 的 基础 上 增加 了 bool 类 型 并 同时 增加 了 两 内 置 的 符号 常量 true All false (Se).
</code></pre>
<p> 标准 C 中 ，int 为 默认 类 型 也 就 是 说 如果 你 明确 指定 函数 的 形 类 型 或函数返回值类型 则它们的类型为 int,<br>标准C++不支持默认类型，但在模板中 有 “默认 类 型 参数 ”的 概念 。</p>
<p>某些 基于 RISC《〈 精 简 指令 集计 算 机 ) 的 CPU 比如 SPARC、PowerPC 等<br>对 内存 中 基本 数据类 型 变量 采用<br>高 字 节 (BYTE) 和 高 (WORD) 在 低地 址 存放 、 低字节 和 低 字 在 地 址 存放 的<br>Big Endian 存储格式 〈 即 高 字 节 、 高 字 在 前 或 地 址 大的 字 节 结尾 ),<br>并 且 把 最 高 字节 的 地 址 作为 变量 的 首 地址</p>
<p>。在 这 种 自然 的 存储 格式 中 ，<br>| 要求 变 量在 内 存 中 的 存放 位 必须 自然 对 ,否则 CPU 会 报告 异常 所 谓 自然 对齐 ，<br>| 就 基本数据 类 〈 主 要 short、int 和double) 的 变量 不 能 简单 地 存储 于 内 存 中 的<br>任意 地 址 处 它 们 的 起 地 址 必须 能 够 被 它们 的 大 小 整除</p>
<p>在 32 位 平台 下 ，int 和 指针 类 型 变量 的 地 址 应 该 能 4 整除，而 short 变量 的 地 址 都应 该 是 偶数 ，bool和 char 则 没有 特别 要 求</p>
<p><img src="/../img/C++/Pasted%20image%2020230531104928.png"></p>
<p>Intel 系列 CPU 采用 Little Endian 存储 格式 来 存放 基本 类 型 变量 即 低 字节和低字 在 低地 址 存放 、 高 字 节 和 高 字 在 地 址 存放 《〈 即 低 字 节 、 低 字 在 前 或地 址 小 的 字 节 结尾 )， 并 且 把 最低 字节 的 地 址 作为 变量 的 首 地 址</p>
<p><img src="/../img/C++/Pasted%20image%2020230531105144.png"></p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p> 显 地 使 用 强制 类 型 转换由 此 可 能 造成 的 安全 隐患 由 程序 员 负 责<br> 这 里 安全 性 主要包括 两 个 方面 内 存单 元访问 的 安全 和 转换 结果 的 安全 性<br> 主要 表现<br> 内 存 访问 范围 的 扩张<br> 内 存 的 截断<br> 尾 数 的 截断<br> 值 的 改变 和<br> 溢出<br> 一 个 低级 数据 类 型 对 象 总 是 优先 转换 为 能 够 容纳 得 下 它 的 大 值 的、 占用 内 存;最少 的 高 级 类 型 对 象</p>
<p>示例 4-5 中 的 转换 是 安全 的 并 不 需要 强制 编 译 器 </p>
<p>首先 隐 式 地 100 提升: double《〈 作 为 它 的 整数 部 分 的 一 个 临时 变量<br>然 才 将这 个 临时 变量 赋值 dl;<br>同样 ，i 也 会 首先 隐 式 地 提升 double《〈 其 值作为 它 的 整数 部 ) 的 一 个 临时 变量 ，<br>| 然后 才 赋值 d2。<br>当 编译 器 认为 这 些 临时 变量 不再 需要 时 就 适时 地 把 它们 销毁 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">4</span>-$</span><br><span class="line"><span class="type">double</span> di = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> i= <span class="number">100</span>;</span><br><span class="line"><span class="type">double</span> d2 = i</span><br></pre></td></tr></table></figure>

<p> 直接 将派生 类对 象 转换 基 类 对 ，这 虽然 会 生 内 存 截断 但 是 无 从 内 存 访问 还 从 转换 结果 来说 都是 安全 </p>
<p><img src="/../img/C++/Pasted%20image%2020230531114341.png"><br><img src="/../img/C++/Pasted%20image%2020230531114341.png"></p>
<p><a href="#%E6%96%B0%E7%89%B9%E6%80%A7.md">新特性</a></p>
<p> C 语言 环境 中 我们 可 以 先 把 一 种 具体 类 型 指针<br> 如 int* 转 换 void* 类 型 然<br> 再 把void* 类 型 转换 double* 类 型<br> 而 编译 器 不 认为 这 是错误 。 然 这样的 做 法 确实 存在 着 不 易 察 党 的 安全 问题<br> ( 内 存 扩张 和 截断 )， 这 是 标准C 语 言 的 一 个 缺陷 </p>
<h3 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h3><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> d3 = <span class="number">1.25e+20</span>;</span><br><span class="line"><span class="type">double</span> d4 = <span class="number">10.25</span>;</span><br><span class="line"><span class="type">int</span> i2 = (<span class="type">int</span>)d3;</span><br><span class="line"><span class="type">int</span> i3 = (<span class="type">int</span>)d4;</span><br><span class="line"></span><br><span class="line">按照 从 浮 点 数 到 整 型 数 的 转换 语义 结 果 应 是 截 去 浮 点 数 的 小 数部分而 保留其 整数 部分</span><br><span class="line">因 此 i 会得 到 <span class="number">10</span>，</span><br><span class="line"></span><br><span class="line">d3 的 整数 部 分远远 超 了 一 个<span class="type">int</span> 所 能 表示 的 范围 </span><br><span class="line">i2 会 溢出</span><br></pre></td></tr></table></figure>

<h3 id="指针转换"><a href="#指针转换" class="headerlink" title="指针转换"></a>指针转换</h3><p>基本 数据 类 型 间 的 <strong>指针转换</strong> 一 般 说 必然 造成 内 存 截 断 或 内 存 访问 范围扩张<br>在 32 位 系统 ，int、long、float 都 具有 4 字 节 的 空间<br>虽 然 不 会 造成 内 存 截断 内 存 扩张<br> 它们 之间 的 <strong>指针 转换</strong><br>改变 了 <strong>编译 器</strong>对 指针 所指向 的 内 存单 元 的 <strong>解释方式</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">4</span><span class="number">-8</span></span><br><span class="line"><span class="type">double</span> d5 = <span class="number">1000.25</span>;</span><br><span class="line"><span class="type">int</span> *pInt = (<span class="type">int</span>*)&amp;d5;</span><br><span class="line"><span class="type">int</span> i4 = <span class="number">100</span>;</span><br><span class="line"><span class="type">double</span> *pDbl = (<span class="type">double</span>*)&amp;i4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从 内 存 访问 角度 来 , 你 通过 pInt 访问 它 指向 <span class="type">double</span> 类 型 变量 d5 是 安全 的</span><br><span class="line">(后面的 <span class="number">4</span> 字 节 “截断 ”了 ， 可访问 内 存 范围 缩小 )，但 是 其 值 绝对 不 会 d5 的 整数部分<span class="number">1000</span>， </span><br><span class="line">而 是 位 d5 开头 <span class="number">4</span> 字节 中 的 内 容 并 解释 <span class="type">int</span> 类 型 数 </span><br><span class="line">这 个 数 是 不可预料 的 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">通过 pDbl 访问 <span class="type">int</span> 类 型 变量 这 ， 得 到 的 数据 不一 定 就 <span class="number">100</span>， 况 且造成 了 可 访问 内 存 范围 “扩张 &gt;。 </span><br><span class="line">如 果 你往 里 面 写 数据 就 会 产生 运行 时 错误</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230531131558.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Base objB2;</span><br><span class="line">Derived *pD2 = (Derived *)&amp;objB2;</span><br><span class="line"></span><br><span class="line">存在 的问题 : 通过 pD2 能 够 访问 的 内 存范围 “扩张 ”了 <span class="number">4</span> 字节 ,如果 访问 m_c可 能 引发 运行 时 错误 ,因为 pD2 指向 的 对 象 根本 就 没有 成 m_e 的 空间</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230531131959.png"></p>
<p>(1) 不 可 以 <strong>基 类</strong> 对 象 直接 转换 为 <strong>派生 类</strong> 对 象 无 论 直接 <strong>赋值</strong> 还 是<strong>强<br>制 转换</strong> 因 为 这 不 “自然 的 ”;<br>(2) 对 于 <strong>基本 类 型</strong> 的<strong>强制 转换</strong> 一 定 要 区 分 <strong>值的截断</strong> 与 <strong>内 存 截断</strong> 的 不 同;<br>(3) 如 果 你 坚持 要使 用强制 转换 必 须 同时 确保 <strong>内存访问的安全性</strong> 和 <strong>转换结果的安全性</strong> ;<br>(4) 如 果 确信 需 要 数据 类 型 转换 请 尽量使 显 式 ( 即强制 ) 数据 类型 转换 让 人 们 知道 发 了 什么 事 避 免让 编译 器 静 悄悄地 进行 隐 式 的数据 类 型 转换 。</p>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标 识 符 可 以 任意 长<br>但 是 标准 C 语言规定 编 译器 只 取 前 31 个字符 作为 有 效 的 标识符<br>而 标准 C++ 则 取 前 255 个 字符 作为 有 效 的 标识 。</p>
<p>每 一 个 标识 符 都 具有 如 下 的 几 个 属性<br>值<br>值 类 型<br>名 字 、<br>存 储 类 型<br>作 用域范围<br>连 接 类 型 （可 见 性)、<br>生 存 期 等</p>
<p>C 函数 函 数 名 其 实 就是<br>函数 代码<br>在 内 存 中 的 首 地 址 在 编译 时 就 可 以 确定 其 值 因 此 是 一 个 常量 这 是 它 的 值<br>值的 类 型 是 函数 指针 类 型<br>存 储 类 型 默认 extern， 除 非 声明 为 static;，<br>作 用 域 范围为 文件 作用域 ;<br>连接 类 型 默认 为 外 连接 , 除非 声明 为 static;<br>生存 期 为 永久 〈 即 静态 )。</p>
<h3 id="转义序列"><a href="#转义序列" class="headerlink" title="转义序列"></a>转义序列</h3><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h4 id="算术运算符-关系运算符-逻辑运算符"><a href="#算术运算符-关系运算符-逻辑运算符" class="headerlink" title="算术运算符 关系运算符 逻辑运算符"></a>算术运算符 关系运算符 逻辑运算符</h4><h4 id="函数调用-类型转换-成员选择"><a href="#函数调用-类型转换-成员选择" class="headerlink" title="函数调用 类型转换 成员选择"></a>函数调用 类型转换 成员选择</h4><p>类型转换运算符<br>运行时类型识别运算符（typeid）<br>作用域解析(::)<br>动态内存分配 释放<br>类成员指针运算符</p>
<h4 id="运算符基本特性就是优先级和结合律"><a href="#运算符基本特性就是优先级和结合律" class="headerlink" title="运算符基本特性就是优先级和结合律"></a>运算符基本特性就是优先级和结合律</h4><p><img src="/../img/C++/Pasted%20image%2020230531133944.png"></p>
<h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><h3 id="常量表达式-算术表达式-关系表达式-逻辑表达式-复合表达式-逗号表达式-条件运算符表达式-位运算表达式"><a href="#常量表达式-算术表达式-关系表达式-逻辑表达式-复合表达式-逗号表达式-条件运算符表达式-位运算表达式" class="headerlink" title="常量表达式 算术表达式 关系表达式 逻辑表达式 复合表达式 逗号表达式 条件运算符表达式 位运算表达式"></a>常量表达式 算术表达式 关系表达式 逻辑表达式 复合表达式 逗号表达式 条件运算符表达式 位运算表达式</h3><p>常量表达式在编译时就可求值</p>
<p>能 够 在 编译 时 求 的 程序 元 素 是 否需要 分 配 运行 时 的 存储 空间 呢 ?</p>
<ol>
<li><p>基本 数据 类 型 的 字面常量 枚举常量 、sizeof()、 常 量 表达 式 等 就 不需要分配存储 空间 ， 因 此 也 没有 存储 类型</p>
</li>
<li><p>字符 串 常 量 、const 常量 (尤其 ADTUDT 的 const 对 ) 都 要 分配 运行 时 的 存储 空间 即 有 特定 的 存储 类 型</p>
</li>
</ol>
<p>在 用 运算 “&amp;&amp;” 的 表达 式 ， 要 尽量 把 有 可 能 FALSE 的 表达 式 放在 “&amp;&amp;” 的 左边<br>在 用 运算 “||” 的 表达 式 中 要 尽量把 有可 能 TRUE 子表达式 “||” 左边.</p>
<h3 id="基本控制结构"><a href="#基本控制结构" class="headerlink" title="基本控制结构"></a>基本控制结构</h3><h3 id="选择判断结构"><a href="#选择判断结构" class="headerlink" title="选择判断结构"></a>选择判断结构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">假设 有 两 个浮 点 变量 x 和 y， 精 度 定义 EPSILON = le<span class="number">-6</span>， 则 错误 的 比较 方式</span><br><span class="line">如下:</span><br><span class="line">	<span class="keyword">if</span>(x = y) / 隐 含 错误 的 比较</span><br><span class="line">	<span class="keyword">if</span>(x != y) / 隐 含 错误 的 比较</span><br><span class="line">应 该 转化 为 正确 的 比较 方式 :</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span>(x - y) &lt;= EPSILON) Ux Fy</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span>(x - y) &gt; EPSILON) Ux BEF y</span><br><span class="line">同 理 ，x 与 零 值比较 的 正确 方式 :</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span> (x) &lt;= EPSILON) /x 等 <span class="number">0</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span> (x) &gt; EPSILON) Ix REF <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>if (NULL &#x3D;&#x3D; p)</p>
<p><img src="/../img/C++/Pasted%20image%2020230531135348.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230531135436.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230531135630.png"></p>
<p>数组 元 素 的 访问 是 真正 的 随机 访问 〈 直 接地 址 计算 )。 如 果 整个 数组 能 在 一<br>内 存 页 中 容纳 ， 那 么 在 对 整个 数组 进行操作 的 过 中 至少不 会 了 访问 数组 元 素<br>而 出 现 缺 页 中 断 页 面 调度 和 页 交换 等 情况 只 需要 一次 外 存 读取 操作 就 可 以<br>数组 所 在 的 整个 页 面 入 内 存 然 后 直接 访问 内 存 可 了 </p>
<p>在 示例 4-14 中 ， 左 边 的 写法 比 右边 的 写法 多 执行 Nr] 次 逻辑 判断 并 且前 者<br>的 还 辑 判断 打 了 循环 “流水 线 ” 作 ， 使 得 编译 器 不 能 对 循环 进行 优化 处 ，<br>降低 了 效率 如 果 和 非常 大 最好 采用 右边 的 写法 可 以 提高 效率 如 果 N 非常 小 ，<br>两 者 效率 差别 并不 明显 采 用 左边 的 写法比较 ， 因 为 程序 更 加 简洁 。</p>
<p><img src="/../img/C++/Pasted%20image%2020230531140922.png"></p>
<h2 id="2-第五章-常量"><a href="#2-第五章-常量" class="headerlink" title="2. 第五章 常量"></a>2. 第五章 常量</h2><h3 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-100.25f</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OPEN SUCCESS 0x00000001</span></span><br><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="type">char</span> *pChar = <span class="string">&quot;abcdef&quot;</span>; / 取 字 符 串常量的地址</span><br><span class="line">intt *pint = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">保存在符号表里 无法取地址</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译链接环境支持常量合并的 请打开</p>
<h3 id="符号常量"><a href="#符号常量" class="headerlink" title="符号常量"></a>符号常量</h3><p><code>#define</code> 预编译伪指令 字面常量<br>const 分配存储空间 外连接</p>
<h3 id="C-中-，const定义-的-常量-要-具体情况-具体-对-待"><a href="#C-中-，const定义-的-常量-要-具体情况-具体-对-待" class="headerlink" title="C++ 中 ，const定义 的 常量 要 具体情况 具体 对 待"></a>C++ 中 ，const定义 的 常量 要 具体情况 具体 对 待</h3><p>对 于 <strong>基本数据 类 型 的 常量</strong> 编 译 器 把 它 放 到 符号 表 中 而不 分 配 存 储空间 ,<br>而 ADITVUDT 的 <strong>const 对 象</strong> 则 需要 分配 存储 空间 (大对象)。<br>还 有 一 些情况 下也 需要 分 配 存储空间 ，<br>	例如 强制 声明 为 extern 的 符号常量<br>	或者 取 符号常量的地址 等 操作 ，<br>	都 将强迫 编译 器 为 这 些 常量 分 配 存储 空间 以 满足 用 户 的 要 求 </p>
<p>对于 <strong>基本 数据 类 型 const 常量</strong> 编 译器 重新 在 内 存 中 创建 它 的 一 个 <strong>拷贝</strong><br>你 通过 其 地 址 访问 到 的 就 这 个 拷贝 而 非 原始的 符号 常量</p>
<p> 对 于 构造 类 型 const 常量 实 上 它 是 编译 时不 允许修改 的 变量 ，<br>因此 如 果 你 能 绕 过 <strong>编译 器 的 静态 类 型 安全 检查机 制</strong> 就 可 以 在 运行 时 修改 内 存单 元，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">long</span> Ing = <span class="number">10</span>;</span><br><span class="line"><span class="type">long</span> *pl = (<span class="type">long</span>*)&amp;lng; / 取 常 量 的 地 址</span><br><span class="line">*pl = <span class="number">1000</span>; <span class="comment">//迂回修改</span></span><br><span class="line">cout &lt;&lt; *pl &lt;&lt; endl; / <span class="number">1000</span>， 修 改 的 是 拷贝 内 容 !</span><br><span class="line">cout &lt;&lt; Ing &lt;&lt; end]; / <span class="number">10</span>， 原 始 常量 并 没有 变 !</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">Integer</span>() : <span class="built_in">m_Ing</span>(<span class="number">100</span>) &#123; &#125;</span><br><span class="line">	<span class="type">long</span> m_Ing;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> Integer int_1;</span><br><span class="line">Integer *pInt = (Integer*)&amp;<span class="type">int</span> <span class="number">1</span>; <span class="comment">// 去除常数属性</span></span><br><span class="line">pint-&gt;m_Ing = <span class="number">1000</span>;</span><br><span class="line">cout &lt;&lt; pInt-&gt;m_Ing &lt;&lt; endl; <span class="comment">// 1000, 修改const 对象</span></span><br><span class="line">cout &lt;&lt; int_].m_Ing &lt;&lt; endl; <span class="comment">// 1000, 迂回修改成功</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<ol>
<li><p>在 标准 C 语言 中 ，const 符号 常量 默认 是 外 连 楼 〔 分 配 存储 )，<br>也 就是说你不能在两个或以上编译单元中同时定义一个同名的const符号常量<br>也不能 把 一 个const 符号 常量 定义 放 在 一 个头文件 中 而 在 多 个 编译 单元 中 同时 包含 头 文件 </p>
</li>
<li><p>但 是 在 标准 C++ const符号 常量默认 是 内 连接 的 因 此 可 以 定义 在 头 文件 。<br>当 在 不 同 的 编译单元 中 同时 包含 头 文件 时 编 译 器 认为 它们 是 不 同 的 符号 常量<br>因 此每 个 编译 单元独立 编译 时 会 分 别 为 它们 分配 存 储 空间 ，<br>而 在 连接 时 进行常量 合并</p>
</li>
</ol>
<h3 id="契约性常量"><a href="#契约性常量" class="headerlink" title="契约性常量"></a>契约性常量</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">示例 <span class="number">5</span><span class="number">-3</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n= <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">ReadValue</span>(n); <span class="comment">// 契约性 const, n 被 看 做 const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举常量"><a href="#枚举常量" class="headerlink" title="枚举常量"></a>枚举常量</h3><p>标 C++规定 枚 举 常量 的 值 可 以 扩展 的 并 非 受 限 于 一 般 的 整 数 的 范围</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gigantic</span></span><br><span class="line">&#123;</span><br><span class="line">	SMALL = <span class="number">10</span>,</span><br><span class="line">	GIGANTIC = <span class="number">300000000000</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于 底层 如 何 实现 则 依赖 于 具体 的 环境 和 编译 器 厂商 可 能 会 不 同 的 语义 ，<br>请 查看 编译 器 文档 </p>
<p>以 C++ 程序 中 应 尽量 使 const 来 定义 符号 常量 包 括 字符 串 常量 。</p>
<p>非 静态 const 数据 成 员 是 属于 每 一对 象 的 成 员 <strong>只在某个对象生存期内是常量</strong><br>而 对 于 整个 类 来 说 它 是 可 变 ，<br>除非 static const。</p>
<p>因 为 类 可 以 创建 多 个 对 象 不 同 的 对 象 const 数据 成员 的 可以 不 同</p>
<p>不 能 在类声明 中初始 化 非 静态 const 数据 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> SIZE = <span class="number">100</span>;   / 错误 企 图 在 类 声明 中初始 <span class="type">const</span> 数据 员</span><br><span class="line">	<span class="type">int</span> array[SIZE];           / /错误 未 知 SIZE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>非 静 const 数据 员 的初始化 只 能 在 类 的 构造 函数 的初始 化 列表 中 进行</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> size); / 构造 函数</span><br><span class="line">	<span class="type">const</span> <span class="type">int</span> SIZE ;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> size) : <span class="built_in">SIZE</span>(size) / 构造 函数 的初始 化 列表</span><br><span class="line">&#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">A all00);   <span class="comment">// HR a HK SIZE (AA 100</span></span><br><span class="line"><span class="function">A <span class="title">b</span><span class="params">(<span class="number">200</span>)</span>   <span class="comment">// AR b HY SIZE &#123;4% 200</span></span></span><br></pre></td></tr></table></figure>
<p>怎样才能 建立 在 整个 类 中 都 恒定 的 常量 ? 别 指望 const 数据 成员 了 ，<br>应该 用 类 中 的 枚 举 常 量 来 实现<br>枚举 常 量 不会 占用 对 象 的 存储 空间 它 们 在 编译 时 被 全 部 求 值<br>更 何况 它 定义的 是 一 个 匿名 枚 举 类 型<br>枚 举 常 量 的 缺点 是 不 能 表示 浮 点数 〈 如 PI-&#x3D;3.14159) 和 字符串</p>
<p> 可 以 用 另 一 种 方法 来 定义 类 的 有 对 象 共享 的 常量 ，即 static const，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">5</span><span class="number">-8</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">public</span>: <span class="comment">// 有 些语言 实现 可 能 不 支持 这样 的初始 化 如 Visual C++</span></span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> SIZE1 = <span class="number">100</span>; / 静态常量 员</span><br><span class="line">	<span class="type">static</span> <span class="type">const</span> <span class="type">int</span> SIZE2 = <span class="number">200</span>; / 静态 常量 员</span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">	<span class="type">int</span> array <span class="number">1</span>[SIZE1]; <span class="comment">// 普通 员</span></span><br><span class="line">	<span class="type">int</span> array2[SIZE2]; <span class="comment">// 普通 员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="实际-用-中-如-何-定-义-常量"><a href="#实际-用-中-如-何-定-义-常量" class="headerlink" title="实际 用 中 如 何 定 义 常量"></a>实际 用 中 如 何 定 义 常量</h3><h4 id="1-C程序"><a href="#1-C程序" class="headerlink" title="1. C程序"></a>1. C程序</h4><h5 id="1-1-多个编译单元或模块公用"><a href="#1-1-多个编译单元或模块公用" class="headerlink" title="1.1 多个编译单元或模块公用"></a>1.1 多个编译单元或模块公用</h5><p>1.1.1 在某个公用头文件中将符号常量<strong>定义为static并初始化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonDef.h </span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX+LENGTH =<span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>然后每一个使用它的编译单元 <code>#include</code> 该头文件即可；<br>1.1.2 在头文件中使用 <strong>宏定义</strong><br>1.1.3 在 某个公用的头文件中将符号常量声明为<strong>extern</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonDef.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> MAX_LENGTH;</span><br></pre></td></tr></table></figure>
<p>并且在某个源文件中<strong>定义一次</strong>; </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>然后每个使用它的编译单元<code>#include</code> 上述头文件即可<br>1.1.4 整形常量 在某个公用<strong>头文件</strong>定义<strong>enum</strong>类型 然 后 每 一 个使 用 它 的 编 详单 <code>#include</code> 该头 文件 即 可 </p>
<h5 id="1-2-只为一个编译单元使用"><a href="#1-2-只为一个编译单元使用" class="headerlink" title="1.2 只为一个编译单元使用"></a>1.2 只为一个编译单元使用</h5><p>1.2.1 直接于编译单元开头位置将符号常量定义为static 并初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo.c</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>1.2.2 同1.1.1<br>1.2.3 同1.1.3 或在编译单元开头定义enum类型</p>
<h4 id="2-C-程序"><a href="#2-C-程序" class="headerlink" title="2. C++程序"></a>2. C++程序</h4><h5 id="2-1-多个编译单元或模块公用"><a href="#2-1-多个编译单元或模块公用" class="headerlink" title="2.1 多个编译单元或模块公用"></a>2.1 多个编译单元或模块公用</h5><p>2.1.1 在某 个 公用 的 头 文件 中 直接 在 某 名 字 空间 中 或者 全 局 名 字 空间 中 定义 符号常量 并 初始 化 有 无static无 所 谓 )， 例 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonDef.h</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXLENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>

<p>每一个使用它的编译单元 <code>#include</code> 该 头 文件 即 可<br>2.1.2 在 某 公用 头 文件 中 并 且 在 某 名 字 空 间 中 或全 局 名 字 空 间 中 将 符号 常量 声明为 extem 的 例 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonDef.h</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">const</span> <span class="type">int</span> MAX LENGTH;</span><br></pre></td></tr></table></figure>
<p>并 且在 某 个 源 文件 中 定义 一次 并 初始 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>然后 每 一 个使 用 它 的 编 详 单元 机 nclude 上 述 头 文件即可<br>2.1.3 同1.1.3<br>2.1.4  定义 为 某 一 个 公用 类的 static const 数据成 员 并 初始<br>或 者定义为 类 内 的 枚 举 类 型 例 如 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Utility.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Utility</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAX LENGTH;</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">TIME_OUT= <span class="number">10</span></span><br><span class="line">hs</span><br><span class="line"><span class="comment">// Utility.cpp</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> Utility:: MAX LENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>然后 每 一 个使 用 它 的 编 详 单元 机 nclude 上 述 头 文件即可 </p>
<h5 id="2-2-只为一个编译单元使用"><a href="#2-2-只为一个编译单元使用" class="headerlink" title="2.2 只为一个编译单元使用"></a>2.2 只为一个编译单元使用</h5><p>2.2.1 同2.1.1<br>2.2.2 直接 于 该 编译 单元 〈 源 文件 开头 定义 符号<br>量 并 初始 〈 有 无 static 无所 谓 )， 例 如 :</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.C</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXLENGTH = <span class="number">1024</span>;</span><br></pre></td></tr></table></figure>
<p>2.2.3 同1.2.3</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在 C 程序 中 ，const 符号 常量 定义 的默认 连接 类 (Linkage) 是 extern 的 即 外连接 (external linkage)， 就 全 局 变量 一 样<br>因 此 ， 如 果 要 在 头 文件 中 定义 必 须使用 static 关键字 ，<br>这 样 每 一 包含 头 文件 的 编译 单元 就会 分 别 有 该 常量 的 一份独立定 义 实体 〈 如 同 直接 在 每 一 个源 文件 中 分 别 定义 一 )，<br>否则会 导致 “redefinition”的 编译 器诊断 信息 ;<br>如果 在源 文件 中 定义 除 非 明确 改变 它 的 连接 类 型 static 〈 实际 上 是 存储 类 型 static, 连接 类 型 内 连接 ) 的 ,<br>否则 其他 编译 单元 可 以通过 extern声明 来访问 </p>
<p> C++ 程序 ，const 符号 常量定义 的 默认 连接 类 型 却 static 的 即 内 连(Cinternal linkage)，<br> 就 class 的 定义 一 样 这就是在 头 文件 中 定义 而 不 需要 static关键 字 的 原因 </p>
<p>字符 串 常量 的 定义 和 整 型 常量 的 定义 差不多 ， 但 是其类 型 <code>const char *</code>， 因 此<br>们 常常 这样 定义 它们 ;</p>
<p>const char* const ERR_DESP NO_MEMORY &#x3D; “There is no enough memory!”;</p>
<p>可 以 在头 文件 中 定义 并初始 ， 也 可 以 在 源 文件 中 定义 并 初始 化 但 是 二 者 差别 大 :</p>
<ol>
<li><p>如 果 在 头 文 件 中 定义 并 初始 化 那 包含 了 该 头 文件 的 每 一 个 编译 单元<br>不仅 会 为 一个 常量 指针 常量 (const char * const) 创建 一 个独立 的 拷贝项 ，<br>而 且 也 会 为 那个 长长 的 字符 串 字 面 量 创建 一 个独立 的 拷贝 项<br>就 相当 于在 每 一 个 编译单元 内 分 别 定 和 初 始化每 一 个 常量 ， 一次 一 个 样<br>这是与 整 型 或浮点 型 常量 的 定义 不 同 〈 它 们 在初始化 完 后 不 再 需要 那个 字面<br>营 )。<br>因 此 ， 每 一 个 编译单元 内 访问的 字符 串 常量 都 是它 自己 单独 创建 :<br>拷贝 衬间 的 开销 就 体现 在每 一 字符 串 字 面 量 的独立拷贝 上 ;</p>
</li>
<li><p>如 果 采 用 方法 ， 在 头 文件 中 声明 所有 常量 指针 常量 而在 源 文 中 定义并初始化 它们 ，<br>则 每 一 包含 头 文件 的 编译 单元 访问 的 不 仅 是 常量 指针常量 的 唯一 实体<br>而 且 字 符 串 字面 常量 也 是 唯一 的实体<br>这就 大 节约 了内 存 而卫 不 失效 率。<br>当然 我 们 完全 可 以 把 常量 合并 的 优化 交 给 编译 和 连接 器 来 完成 但 是 我 们</p>
</li>
</ol>
<p>还 是 提倡 由 自己 来 优化 常量 的 定义 。</p>
<h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3. 函数"></a>3. 函数</h2><p>对 于** 静态 链接 库** 的 函数 库 或 类 库 如 果 你 调用 了 其 中 的 函数 《无 论 是 直接 调用<br>还 是 间接 调用 )，<br>那 么 连接 器 从 相应 的 中 提取 这 些 函数 的 实现 代码 并 把它们 连接到 你 的 用 程序 ;<br>如 果 你 没有 调用 库 中 的 某 些 函数 则 连接 器 是不 会把 它们 的 实现代 码 连接 进来 的 即 使 该 包含 了 成 上 万 个 函数</p>
<p>如 果 你 用 的 是 动态 链接(DLL)， 则 运行 时 必须 将 有 DLL 都 找 到 运行 环境 的 相应 目录 下</p>
<p>如 果 程 中 任何 地 方 都 没有 调用 你 自己 编写 的 某 个 函数 的 话<br>编译器也不 会 为 函数 生成 可 执行 代码</p>
<h3 id="函数原型-定义"><a href="#函数原型-定义" class="headerlink" title="函数原型 定义"></a>函数原型 定义</h3><p>早先 C 语言 存在 函数 <strong>前 置 声明</strong> 的 概念<br>因 为 C 语言 环境 中 同 一 作用 域中 不 能 出 现 同名 的 全 局 函数</p>
<p>有 了 函数 前 声明 ， 即 把 函数 的 定义 体 放 在 函数 调用 后 面 的 任何 地 方 也 无 ，连接 器在 连接 时 能 够 找到 。</p>
<p>是 函数 前 置 声明 并 没有 给 出 函数 可 接受 的 参数 类 型和 个 数<br>于 是 编译 器 无 法对 函数 调用 语句 执行静态 类 型 安全 检查<br>〈 即 检查 实 参与参 的 个 数 类 型 及 顺序 等 是 呈 配 )。</p>
<p>导致 正确 的 参数 传递 从 而 出 现 运行时 错误 甚至 破坏 堆栈</p>
<p>解决 这 一问题 的 方法 就 是使 用 函数 原型 (ANSIISO C 从 C++ 借鉴 了 函数 原型 )。</p>
<p>{ 作 用 域 [函数 的 连接规范 ] 返回 类 [函数 的 调用 规范 ] 函数 (类 1 [ 形 参 1]，类型 2 [形参 2], …);</p>
<p>函数调用 中 参数 传递 本 质 就 用 实参 来 <strong>初始 化 形 参</strong> 而 不 是 替换 形参</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">char</span> *p)</span></span>; dni p 是 形参</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="keyword">class</span> <span class="title class_">C</span>&#123;...&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> *q = “abcd”;</span><br><span class="line">	<span class="built_in">f</span>(<span class="number">5</span>, q); /<span class="number">5</span> 和 q 是 实参</span><br><span class="line">	C&lt;<span class="type">int</span>&gt; a; /<span class="type">int</span> 是实 参</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数堆栈"><a href="#函数堆栈" class="headerlink" title="函数堆栈"></a>函数堆栈</h3><p>函数 堆栈 实际 上 使 用 的 是 程序 的 堆栈 内 存 空间 ， 虽 然 程序 的 堆栈 段 是 系统程序 分 配 的 一 种 静态 数据 ， 但 是 函数 堆栈 却 是 在 调用 到 它 的 时 候 才 动 态 分 配 </p>
<p>函数 堆栈 却 是 在 调用 到 它 的 时 候 才 动 态 分 配</p>
<p><img src="/ebooks-copy/desktop/%E7%AC%AC5%E7%AF%87_C_C_%20%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E4%B8%8E%E7%A8%8B%E5%BA%8F%E6%A0%88%20-%20%E7%9F%A5%E4%B9%8E%20(2023_6_1%2002_50_50).html"></p>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/column/c_1277937360727257088">C&#x2F;C++ 修道院 - 知乎 (zhihu.com)</a></p>
<p><img src="/ebooks-copy/desktop/%E6%B5%85%E8%B0%88%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%20(2023_6_1%2002_57_45).html"></p>
<p><img src="/../img/C++/Pasted%20image%2020230601024956.png"></p>
<p><strong>栈段：</strong></p>
<p>　　1. 为函数内部的局部变量提供存储空间。<br>　　2. 进行函数调用时，存储“过程活动记录”。<br>　　3. 用作暂时存储区。如计算一个很长的算术表达式时，可以将部分计算结果压入堆栈。</p>
<p><strong>堆：</strong></p>
<p>　　堆能够根据需要自动增长。堆区域是用来动态分配的内存空间，用 malloc 函数申请的，用free函数释放。calloc、realloc和malloc类似：前者返回指针的之前把分配好的内存内容都清空为零；后者改变一个指针所指向的内存块的大小，可以扩大和缩小，它经常把内存拷贝到别的地方然后将新地址返回。</p>
<p><strong>数据段（静态存储区）：</strong></p>
<p>　　包括BSS段（Block Started by Symbol）的数据段。BSS段存储未初始化或初始化为0的全局变量、静态变量，具体体现为一个占位符，并不给该段的数据分配空间，只是记录数据所需空间的大小。数据段存储经过初始化的全局和静态变量。</p>
<p><strong>代码段：</strong></p>
<p>　　又称为文本段。存储可执行文件的指令；也有可能包含一些只读的常数变量，例如字符串常量等。</p>
<p>　　.**rodata段：**存放只读数据，比如printf语句中的格式字符串和开关语句的跳转表。也就是你所说的常量区。例如，全局作用域中的 const int ival &#x3D; 10，ival存放在.rodata段；再如，函数局部作用域中的printf(“Hello world %d\n”, c);语句中的格式字符串”Hello world %d\n”，也存放在.rodata段。</p>
<p>　　但是注意并不是所有的常量都是放在常量数据段的，其特殊情况如下：</p>
<p>　　1）有些立即数与指令编译在一起直接放在代码段。</p>
<p>　　2）对于字符串常量，编译器会去掉重复的常量，让程序的每个字符串常量只有一份。</p>
<p>　　3）用数组初始化的字符串常量是没有放入常量区的。</p>
<p>　　4）用const修饰的全局变量是放入常量区的，但是使用const修饰的局部变量只是设置为只读起到防止修改的效果，没有放入常量区。<br>　　5）有些系统中rodata段是多个进程共享的，目的是为了提高空间的利用率。</p>
<p>　　注意：程序加载运行时，.rodata段和.text段通常合并到一个Segment（Text Segment）中，操作系统将这个Segment的页面只读保护起来，防止意外的改写</p>
<h3 id="函数调用规范-调用约定-〈CallingConvention-。"><a href="#函数调用规范-调用约定-〈CallingConvention-。" class="headerlink" title="函数调用规范  调用约定 〈CallingConvention)。"></a>函数调用规范  调用约定 〈CallingConvention)。</h3><p>函 数 调用 规范 决定 了 函数 调用 的 **实 参 压 栈 退 栈 及 堆栈 释放 的 方式 **</p>
<p> Windows 环境 下 常用 的 调用 规范 :<br>(1) <code>_cdecl</code>: 这 是 CHHC 函数 的 默认 调用 规范 ,参数 从右 向 左 依次 传递 并 压 入<br>堆栈 由 调用 函数 负责 堆栈 的 清 退 </p>
<p>(2) <code>_stdcall</code>， 这 是 Win API 函数使 用 的 调用 规范 。 参 数 从右 向 左 依次传递 并 压 入 堆栈 外 被 调用 函数 负责 摊栈 的 清 退<br>该 规范 生成 的 函数 代码“cdecl 更 小， 但 当 函 有 可 变个 数 的 参数 时 会 转 为 <code>_cdecl</code> 规范<br>(3) <code>_thiscall</code>: 是 C++ 非 静态 员 函 数 的 默认 调用 规范 不 能 用 个 数可 变 参数<br>(4) <code>_ fastcall</code>: 该规范 所 修饰 的 函数 的 实 参 将 直接 传递 到 CPU 寄存 器 中 而 不<br>是 内 存 堆栈 不能 用 于 成 员 函 数</p>
<p>凡是 接口 函数 必须 显 式 地 指定 其 调用 规范 除 接口 函数 类 的 非态 员 函 non-static member function)。</p>
<h3 id="函数的连接规范"><a href="#函数的连接规范" class="headerlink" title="函数的连接规范"></a>函数的连接规范</h3><p>只 要 它们使 用 一 的 员 对 齐 方式 和 布局 方案 、 一 的 函数 调用 规范 、 一 致 virtual function 实现 方式 总 之就 是 一 致 C++ 对 象 模型</p>
<h3 id="参数传递规则"><a href="#参数传递规则" class="headerlink" title="参数传递规则"></a>参数传递规则</h3><p>C 语言 , 函数 的 参数 和 返回 的传递式 有 两 : 值传递 (pass by value) 和 地 址传递 〈 即 指针 传递 ，pass by pointer)</p>
<p>C++语言 中 增加 了 引用 传递 〈pass by reference)。 </p>
<p>如 果 函 数 有 参数 那使 void 而 不 要 空 着<br>这 是 因为 标准 C 把 的 参数 列表 解释 为 可 以 接受任何 类 和 个 数 的 参数<br>而 标准 C++ 则 把 空 的 参数 列表 解释 为 可 以 接受任何 参数<br>在 移植 C+HC 程序 时 尤其 要 注意 这 方面 的 不 同</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(<span class="type">int</span> width, <span class="type">int</span> height)</span></span>; / 良好 的 风格</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SetValue</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>; / 不 良 风格</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetValue</span><span class="params">(<span class="type">void</span>)</span></span>; / 良好 的 风格</span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">GetValue</span><span class="params">()</span></span>; / 不 良 的 风格</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230601050908.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230601051429.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">operator</span> + (<span class="type">const</span> String &amp;lh, <span class="type">const</span> String &amp;rh)</span><br><span class="line">| &#123;</span><br><span class="line">	| String temp;</span><br><span class="line">	temp.m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strljen</span>(s<span class="number">1.</span>m_data) + <span class="built_in">strlen</span>(s<span class="number">2.</span>m_data) + <span class="number">1</span>]];</span><br><span class="line">	<span class="built_in">strcpy</span>(temp.m_data, s<span class="number">1.</span>m_data);</span><br><span class="line">	<span class="built_in">strcat</span>(temp.m_data, s<span class="number">2.</span>m_data);</span><br><span class="line">	retumtemp; /执行 string 对 象 及 其 字符 串 内 容 的 拷贝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对 于相 加 函数 应 当 用 “返回 对 象 值 的 方式 返回 String 对 象 这 将把 局 部 对 temp 及 其 真正 的 字符 串 值 拷贝 一 给 调用 环境 的 接收 者 如 果 改 “返回 引用 ” 那 么 函数 返回值 是一 个指向 局 部 对 ttmp 的 “引用 ”( 即 地 址 )， 而 temp 在函数 结束 时 被 自动 销毁 将 导致 返回 “引用 ”无效</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">Func</span><span class="params">(<span class="type">void</span>)</span> &quot; </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">char</span> str[] = <span class="string">&quot;hello world&quot;</span>; /str 数组 创建 在 函数 堆栈 上 ， 并 用 字符 串 / 常量 来 初始 化 在 末尾 自动 添加 ^<span class="number">0</span>” </span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(str) &lt;&lt; endl; </span><br><span class="line">	HA2 cout &lt;&lt; <span class="built_in">strlen</span>(str) &lt;&lt; end]; </span><br><span class="line">	#<span class="number">11</span> <span class="keyword">return</span> str; / 该 语句 存在 隐患 ，str 指向 的 内 存单 元 将 被 释放 &#125; 但 下 程序 则 是 正确 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">Func</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *p = <span class="string">&quot;hello world&quot;</span>; / 字符 串 常量 存放 在 程序 的 静态 数据 区</span><br><span class="line">	/ 来 尾 自动 添加 \<span class="number">0</span>&#x27;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; endl; HA</span><br><span class="line">	cout &lt;&lt; <span class="built_in">strlen</span>(p) &lt;&lt; endl; HWA</span><br><span class="line">	<span class="keyword">return</span> p; / 返回 字符 串常量 的 地 址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230601053851.png"><br>“创建 一个 临时 对 并 返回 它 ” 的 过程 是 不 同 的，<strong>编 译 器</strong>可 以 直接 把 临时 对 象 创 建 并初始 化 <strong>外 部 存储 单元</strong> 中 省 了 拷贝 和 析 构 开销 提 高 了 效率 </p>
<h3 id="存储类型以及作用域规则"><a href="#存储类型以及作用域规则" class="headerlink" title="存储类型以及作用域规则"></a>存储类型以及作用域规则</h3><h3 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h3><p>extern 、auto 、static、register，</p>
<p>extern 和 static 用 来标识永久 生存 期 限 的 变量 和 函数<br>而 auto 和 register 则 用 来 标识 临时 生存 期 限 的 变量</p>
<p>全 局 变量 和 全 局 函数 的 存储 类 型 extern 能 够 定义 在 它们之 后 的 同一个 编译 单元 内 的 函数 所 调用<br>变 量和 函数 显 式 地 加 上 exterm 声明 ，那么 其他 编译 单元 中 的 函数 也 能 调用 它们</p>
<p>显式生命为static的全局变量和全局函数具有static存储类型 只能被同一个编译单元内的函数调用</p>
<p>局 部 变量 默认 具有 auto 存储 类 型 除 非 static 或 register 来 定义<br>它们 的作用 域 是程序 块作用 域 连 接 类 型 都 内 连接 在 进入 函数 的 时候 创建 ，在 函数退出 的时 候 销毁<br>register 和 auto 只 能 用 于 声明 局 部 变量 和 局 部 常量 </p>
<p>全局常量默认 存储类型 static<br>除非在定义了它的编译单元之外的其他编译单元中 显式的用extern声明 否则不能被访问<br>（就是拿过来用的时候 加个extern 声明一下）</p>
<p>局 部 符号 常量 (注意 不是 函数 内 出 现 的 字面 常量 ) 的 默认 存储 类 型 auto，<br>除非 显式 地 定义 static 或 register.</p>
<p>把 那些 经 常 用 的 变量 例如 循环 计数 器 直接 放 到 CPU 寄存 器 ， 可 以避免 在 寄存 和 内 存 之 间 频 地 交换 数据 因 此 能 提高 程序 的 运行 效率 </p>
<h3 id="作用域规则"><a href="#作用域规则" class="headerlink" title="作用域规则"></a>作用域规则</h3><p>在 标准 C 语言 ， 这 些 范围包括 文件 函 数 程 序 和 函数 原型</p>
<p>标准 C++中 除了 这 4 种 外 有 两 作用 域 类 型 类 和 名 字 空 间 其 中 名 字 空 间 是 可 以 跨 文 件 +</p>
<p>S (label) 是 具有 函数 作用 域 的 惟一 一 种 标识 符 这 就 是 说 不 论 你 的 标号定义 在 函数 中 的 哪 一行 ， 也 不 论 定义 在 函数 内 撕套得 多 么 深 的 程序 块 内 它 都能够在 函数 体内 任何 一 个地 方 访问 , 因此 也 叫做 函数 级 的 标识 。 标号 一 般 用 在 goto| 语句 ， 如 果 goto 语句 没有 使 用 到 该 标号 那 么 该 标号 将 忽略</p>
<p>即 使部 变量 的 存储 类 型 声明 static， 它 仍然 具有 程序 作 用 </p>
<p>在 函数 中 毁套 的 程序 块 可 以 定义相同 名 字 的 变量 在 内 层 的 变量 玫 蔽外 层 的 同名 变量<br>当局 部 变量 与 某一 个全 局 变量 同名 ， 在 函数 内 部将史 蔽 全 局 变量<br>如 果 某 一 个 员 函 数 内 定义 了 与 类 的 某 一 个 数据员 同 名 的 局部 变量 ， 那么 这个 局 部 变量 将 遮蔽 该 同名 数据 成 。</p>
<p>如果 一 个 标识 符 能 够 在 其他 编译 单元 中 或 者 在 定义 它 的 编译单元 中 的 其 他 范围内 被 调用 ， 那 么 它 就 外 连接 的 外 连接 的 标识 符 需要 分 配 运行 时 的 存储 空间</p>
<p>如 果 一 个标识符 能 在 定义 它 的 编译单元 中 的 其他 范围 内 被 调用 但 是 不 能 在他 编译 单元 中 被 调用 那 么 它 就 内 连接</p>
<p>一个仅 能 够 在 声明 它 的 范围 内 被 调用 的名 字 是 无 连接 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> f0</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a; /a 是 连接 的</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>&#123; ... &#125;; / 局 部 类 是 连接 的 具 有 程序 作用 域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230601062801.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230601062725.png"></p>
<p>对 ADT&#x2F;UDT 的 输入 参数 应该 “ 值 传递 改 “const 公 传 递 “， 目的 提高 效率 例 如 ， 将 void Func(Aa) 7H void Func(const A &amp;a).<br>对 于 基本 数据 类 型 的 输入 参数 不 要 “ 值 传递 ”的 方式 改 “const 信传递 “， 否 则 既 达 不 到 提高 效率 的 目的 又让 人 费解<br>例如， 不 要<br>void Func(const int x) 改 void Func(const int 人 x)。</p>
<h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func</span><span class="params">(constA &amp;a)</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OutputString</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pStr)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StringCopy</span><span class="params">(<span class="type">char</span> *strDest, <span class="type">const</span> <span class="type">char</span> *strSrc)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *str = <span class="built_in">GetString</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-指针-数组-字符串"><a href="#4-指针-数组-字符串" class="headerlink" title="4. 指针 数组 字符串"></a>4. 指针 数组 字符串</h2><p>int* a,b,c; 《&#x3D;》int <code>*a</code>, b,c;</p>
<p>取 地 址 〈&amp;) 和 反 引 用 〈(<code>*</code>)。</p>
<p>准确的说，与 编译器的目标平台 有关。<br>如果目标平台是32位的，那么sizeof (void*)就是<strong>4</strong>，<br>如果是64位的，那么sizeof就是8，<br>如果是16位的，就是2。 sizeof (void*)的含义就是获取一个指针的大小。<br>指针的本质就是内存地址，因此指针的大小和内存空间有关。<br>32位的机器内存空间是2G（windows系统），<br>因此指针的大小必须是 log_2 (2times 1024^3) &#x3D; 31 ，凑个整数那就是32bit。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在 语义 上 ， 下 标 操作 符返 回 的 是一 个 元 素 的 引用 。a[3] &#x3D; 100;<br>编译器 计算地 址 a + 3 * sizeof (inb， 得 到 0x004284FC， 并 返回 地 址 所 指 对的 引用 而不是 返回 “45” 这 个<br>a[3] &#x3D; 100; &#x2F; 转换 为 *a+ 3) &#x3D; 100;<br>cout &lt;&lt; a[3] &lt;&lt; endl， &#x2F; 转换 cout &lt;&lt; *(a + 3) &lt;&lt; endj;</p>
<p>组 名 字本 身 是 一 个 指针 ， 是 一 个 指针 常量 即 a 等价 int * const a，<br>因 此你 不 能 试图 修改 数组 名 的 值 </p>
<p>a &#x3D;&#x3D; &amp;a[0]</p>
<p>int a[10] &#x3D; {0};<br>int b[10] &#x3D;{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};<br>a&#x3D;b; &#x2F;不仅语义 不 对 何 a 也 不 能 被修改</p>
<p>int b[100]; &#x2F; sizeoftb) &#x3D; 400 bytes， 未初始<br>int c[ ]&#x3D; {1, 2,3, 4,5}; I FBP RA S, sizeof(c) &#x3D;20 bytes, 初 始<br>int d[5] &#x3D; {1, 2, 3, 4,5, 6, 7}; &#x2F; 错误 ! 初始 值 越界<br>int e[10] &#x3D; {5, 6, 7, 8, 9}; &#x2F; 元 素 个 数 10， 指 了 前 5 个 元 素 的初始 值 剩<br>VW 下 的 元 素全 部 自动 初始 化 0<br>int [10] &#x3D; {5,, 12,,2}; &#x2F; 错误 ! 不 能 跳 过 中 间 的 某些 元 素</p>
<p>C++&#x2F;C 可 以 在 运行 时 进行 数组 的 越界 访问 检查<br>这 是 因为 数组 大小 的 信息 保存 在程序 中 的 某 地 方 一 般<br>就 是 放 在 数组 第 一 个元 素 位 置 的 <strong>前 面</strong> 占用 一 int 变量 的 字节数 ,<br>它 地 址 a-sizeof(int)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] &lt;&gt; <span class="type">int</span>* <span class="type">const</span> a;</span><br><span class="line"><span class="type">int</span> b[<span class="number">3</span>][<span class="number">4</span>] &lt;&gt; <span class="built_in">int</span> (* <span class="type">const</span> b)[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> c[<span class="number">3</span>][<span class="number">4</span>][<span class="number">5</span>] &lt;&gt; <span class="built_in">int</span> (* <span class="type">const</span> c)[<span class="number">4</span>][<span class="number">5</span>]:</span><br></pre></td></tr></table></figure>

<p>数组 是 不 能 从 函数 return 语句 返回<br>数组 可 以作为 函数 的 参数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a[ ], <span class="type">int</span> Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(a)&lt;&lt;endl; <span class="comment">// 是 4 而 不 400</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">	cout &lt;&lt; a[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">100</span>] = &#123; <span class="number">0</span>&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; endl; <span class="comment">// 400</span></span><br><span class="line"><span class="built_in">output</span>( x, <span class="number">100</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a[ ][<span class="number">20</span>], <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; line; i++ ) &#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span>; | &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">			cout &lt;&lt; a[i][j] &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>][<span class="number">20</span>] = &#123; &#123; <span class="number">100</span> &#125; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; endl; <span class="comment">// 800</span></span><br><span class="line"><span class="built_in">output</span>( x, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">const</span> <span class="type">int</span> a[ ][<span class="number">20</span>], <span class="type">int</span> line)</span></span></span><br><span class="line"><span class="function">cout &lt;&lt; <span class="title">sizeof</span><span class="params">(a)</span> &lt;&lt; endl</span>; <span class="number">4</span></span><br><span class="line">	<span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span>; i &lt; line; i++ ) &#123;</span><br><span class="line">		<span class="keyword">for</span>( <span class="type">int</span> j = <span class="number">0</span>; | &lt; <span class="number">20</span>; j++) &#123;</span><br><span class="line">			cout &lt;&lt; a[i][j] &lt;&lt; endl; <span class="comment">// a 是 一 个 指向 一 维 数组 的 指针a+l 就 是 指向 二 行 的 指针</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>][<span class="number">20</span>] = &#123; &#123; <span class="number">100</span> &#125; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(x) &lt;&lt; endl; <span class="comment">// 800</span></span><br><span class="line"><span class="built_in">output</span>( x, <span class="number">10</span> );</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">(<span class="type">const</span> <span class="type">int</span> (*a)j[<span class="number">20</span>], <span class="type">int</span> line)</span> </span></span><br><span class="line"><span class="function"> a[i][j] 访问转换为 *<span class="params">(a + (i * <span class="number">20</span> + j) * <span class="keyword">sizeof</span>(<span class="type">int</span>))</span>.</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure>

<p>char *p &#x3D; new char[1025]; &#x2F; 分 配 空间<br>delete []p; &#x2F; 删除 数组 空间</p>
<p>它 不 会删除 不 属于 它 内 存单 元 也不 会 泄漏 哪怕 是 一 字 节 的 内 存单 元<br>因为你 明白 地 告诉 了 编译 : 这 是 在 释放 一 个 字符 数组 ,<br>“ 请 ” 它 去 p 指向 的 字符 数组 大小 信息 《数组 的 元 素 个 数 它 被 编译 器 保存 在 程序 的 某 个 地 方 )，<br>然 后 按照 这 个 大 小 来 释放 动态 内 存 这 就 是 数组 的 释放 (delete[]) 的语义 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> (*p3)[<span class="number">4</span>] = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">5</span>][<span class="number">4</span>]; /OK! 退化 第 一 维 语 义 等</span><br><span class="line"><span class="built_in">int</span> (*p4)[<span class="number">5</span>] = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">3</span>][<span class="number">5</span>]; /OK! 退化 第 一 维 语 义 等</span><br><span class="line"><span class="built_in">char</span> (*p5)[<span class="number">5</span>][<span class="number">7</span>] = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">20</span>][<span class="number">5</span>][<span class="number">7</span>]; OK! 退化 第 一 维 语 义 等 价</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> [jp3; <span class="comment">// 删除 p3</span></span><br><span class="line"><span class="keyword">delete</span> []p4; <span class="comment">// 删除 p4</span></span><br><span class="line"><span class="keyword">delete</span> []p5; <span class="comment">// 删除 p5</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arrChar_1[ ] = &#123;<span class="string">&#x27;a’,’b&#x27;</span>,\<span class="number">0</span><span class="string">&#x27;,&#x27;</span>d<span class="string">&#x27;,’e&quot;&#125;;</span></span><br><span class="line"><span class="string">char arrChar_2[ ] = &quot;hello&quot;;</span></span><br><span class="line"><span class="string">char *p = “hello”;</span></span><br><span class="line"><span class="string">cout &lt;&lt; sizeof(arrChar_1) &lt;&lt; endl; /S$， 表 示该 数组 $ 字 节</span></span><br><span class="line"><span class="string">cout &lt;&lt; strlen(arrChar 1) &lt;&lt; endl; 2， 表示 字符 串 长 度 2</span></span><br><span class="line"><span class="string">cout &lt;&lt; sizeof(arrChar_2) &lt;&lt; endl; /6， 表 示 数 组 6 字节</span></span><br><span class="line"><span class="string">cout &lt;&lt; strlen(arrChar_2) &lt;&lt; endl; WS, RARER BREA 5</span></span><br><span class="line"><span class="string">cout &lt;&lt; sizeof(p) &lt;&lt; endl; / 4， 表示 指针 p 占 4 字 节</span></span><br><span class="line"><span class="string">cout &lt;&lt; strlen(p) &lt;&lt; endl; /5， 表 示字符 串 长 度 $</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">默认 char * 表 示 字 符 。 例 如 :</span></span><br><span class="line"><span class="string">char ch =&#x27;</span>a’; / 用 字符 <span class="string">&#x27;a来 初始 化 字符变量 ch</span></span><br><span class="line"><span class="string">char *pChar = &amp;ch; / 字符 指针 指向 字符变量</span></span><br><span class="line"><span class="string">cout &lt;&lt; pChar &lt;&lt; endi; / 错 把 字符 指针 当做 字符 串</span></span><br><span class="line"><span class="string">正确 用 法 :</span></span><br><span class="line"><span class="string">cout &lt;&lt; *pChar &lt;&lt; endl; / 取 一 个 字符</span></span><br></pre></td></tr></table></figure>

<p>某 些 字符 串 函 数 并 不 会 自动 目标 字符 串 结 尾 追 加 ‘\0’，<br>例 如 strncpy和 strncat， 除 非你指定 于 值 比 源 串 的 长 度 大1<br>strcpy 和 strcat 会 把 源串 的 结束 符 一 并 拷贝 到 目标串 中 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> _cdecl (* FuncPtr)( <span class="type">const</span> <span class="type">char</span>*); / 定义 一 种 函数 指针 类</span><br><span class="line">FuncPtr fp_1= strlen ;</span><br><span class="line">FuncPtr fp_2 = puts ;</span><br><span class="line"><span class="type">double</span> _cdecl (*fp_3)( <span class="type">double</span> ) = sqrt ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> len = <span class="built_in">fp_1</span>(‘I am a software engineer.”) ;</span><br><span class="line"><span class="type">double</span> d = ( *fp_3 )( <span class="number">10.25</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> _cdecl (* fp[<span class="number">5</span>])( <span class="type">double</span> ) = &#123; sqrt, fabs, cos, sin, exp &#125;;</span><br><span class="line"><span class="keyword">for</span> (intk = <span class="number">0</span>;k &lt;<span class="number">5</span>; k++)</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;Result :&quot;</span> &lt;&lt; fp[k]( <span class="number">10.25</span> )&lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一般 的 函数 调用 语句 可 以 在 编译 时 就 完成 这 个 绑 定《叫做 静态 决议 或 静态 连接 )<br>运行 时 连接</p>
<p>类 的 员 函 有 4 种 类 型 inline、virtual、static、normal。</p>
<p>inline 函数 在 运行 时会 展开 ， 虽 然 语 言 允许 取 其 地 址 但 是 没有 太 大 意义 。virtual 成 员 函 数 的 地 址 指 的其 vtable 中 的 位 置 ，<br>static成员 函 数 的 地 和 普通 全 局 函数 的 地 址 没有 任何 区 别 ;<br>普通 成 员 函 数 的 地 和 一 般 函 数 的 地 址 也 没有 区 别<br>就 是 函数 代码 在 内 存 中 的 真实地址，<br>但 是 由 于它 的 调用 要绑 定到 一个 实 实在 在 的 对 象 ，<br>因 此无 论 是其 函数 指针的 声明 方式 还 是 其 地 址 的 获取 方法 都 比较 特别</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">7</span><span class="number">-14</span>。</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">( <span class="type">void</span> )</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CTest::f0&quot;</span> &lt;&lt; endl; &#125; / 普通 员 函</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">g</span><span class="params">( <span class="type">void</span> )</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CTest::2()&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// HAR RA</span></span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">h</span><span class="params">( <span class="type">void</span> )</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;CTest::hQ)&quot;</span> &lt;&lt; endl; &#125; /W 虚拟 员 函</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">///...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*GFPtr)</span><span class="params">( <span class="type">void</span> )</span></span>; / 定义 一 个全局 函数 指针 类</span><br><span class="line">	GFPtr fp = CTest::g ; </span><br><span class="line">										</span><br><span class="line">	<span class="built_in">fp</span>();                </span><br><span class="line">	<span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(CTest::*MemFuncPtr)</span><span class="params">( <span class="type">void</span>)</span></span>; <span class="comment">// 声明 类 成 员 函 数 指针 类</span></span><br><span class="line">	MemFuncPtr mfp_] = &amp;CTest::f; <span class="comment">// 声明 成 员 函 数 指 针 变 并 初始</span></span><br><span class="line">	MemFuncPtr mfp2 = &amp;CTest::h; / /注意 获取 成 员 函 数 地 址 的 方法</span><br><span class="line">	CTest theObj ;</span><br><span class="line">	(theObj .*mfp_1)() ; / 使 用 对 和 成 员 函 数 指 针 调 用 成 员 函</span><br><span class="line">	(theObj .*mfp_2)() ;</span><br><span class="line">	CTest *pTest = &amp;theObj ;</span><br><span class="line">	(pTest-&gt;*mfp_1)(); / 使 用 对象 指针 和 成 员 函 数 指针 调用 成 员 函</span><br><span class="line">	(pTest-&gt;*mfp_2)() ;</span><br><span class="line">&#125;</span><br><span class="line">输出 结果 </span><br><span class="line">CTest::<span class="built_in">g</span>()</span><br><span class="line"><span class="function">CTest::f0</span></span><br><span class="line"><span class="function">CTest::hO</span></span><br><span class="line"><span class="function">CTest::f0</span></span><br><span class="line"><span class="function"><span class="title">CTest::h</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>为 了 与 静态 员 函数 区 别<br>取 virtual 函数 和 普通 员 函 数 的 地 址 需要 使用 “&amp;” 运 算<br>〈 取 静态 成 员 函 数 地址 也 可 以 使 用 它 但 是 没有 必要 )。</p>
<p>由 于 纯 虚 函数 没有 实现 体 而 非纯 虚 函 有 实现 体<br>且 虚 函数 都是 通过 vptr 和 vtable 来 间接 调用 的<br>因 此 取 虚 函数 的 地 址 将 得 到该虚 函 数 实现体 vtable 中 的 索引号<br>要 想得到 虚 函 数 实现 体 的 真实 地 址 ,还需要 首先 从 对 象入手 ，<br>找到 vptr 的 位 置 进 而 找到 vtable 的 所 在<br>然 后 根据 函数 指针 的 大 和虚 函 数 的索引 ， 取 出 虚 函 数 的 真实 地 址 </p>
<h3 id="引用与指针"><a href="#引用与指针" class="headerlink" title="引用与指针"></a>引用与指针</h3><p>int m;<br>int&amp; n&#x3D;m;<br>n 既 不 是m 的 拷贝 也 不 是指向 m 的指针 ， 其实n 就 m 自己 </p>
<p>引用 在 创建 的 同时 必须初始 化 即 引用 到 一个 有 效 对象</p>
<p>const int&amp; rint &#x3D; 0;</p>
<p>创建 一 个 临时 的 int 对象 用 0 来 初始它 然 后 再 用 它 来 初始 化 引用 rint，<br>而 该 临时 对 象 将 一 直 保 到 rint 销毁 的 时 候 才 会 销毁。<br>所以，不 要 用 字面 常量 来 初始化引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给 引用 赋值 并 不 是 改变 和 原始 对 象 的 绑 定 关系</span><br><span class="line"><span class="type">int</span> a=<span class="number">10</span>,b= <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span>&amp; rInt =a; /rint 引用 到 a，rInt 等 <span class="number">10</span></span><br><span class="line">rInt = b; <span class="comment">// rInt Al a 都 变 成 1000</span></span><br></pre></td></tr></table></figure>

<p>引用 的 创建 和 销毁 并 不 会 调用 类 的 拷贝 构造 函数 和 析构 函 数<br>在 语言 层面 引 用 的 用 和对 象 一 样<br>在 二 进 制 层面 引 用 一 般 都 是 通过指针 来 实现 的 只 不过 编译 帮 我 们 完成 了 转换 </p>
<p>引 用 的 主要 用 途修饰 函数 的 形参 和 返回 值</p>
<h2 id="5-第八章-C-c高级数据类型"><a href="#5-第八章-C-c高级数据类型" class="headerlink" title="5. 第八章 C++&#x2F;c高级数据类型"></a>5. 第八章 C++&#x2F;c高级数据类型</h2><p> C 语言 stuct， 有 时 也 称 用户 自 定义 数据 类 (User defined Type, UDT)。<br> 抽象 数据 类 型 (Abstract Data Type, ADT)，<br> 在 C++ 环境 ， 我 们 把 C 风格 struct 叫做 POD (Plain Old Data) 对象</p>
<p> structyclass 当做 参数 传递 给 函数 ， 默 认为 值 传 递 其 中的 数组 将 全 部 拷贝 到 函数 堆栈<br> 当 你 UDTADT 中 包含 数组 员 的 时 候 最 好使 指针 或 引用传递该 类 型 对 象<br> 并 且 一 定 要 防 让 数组 元 素 越界 否 则 它 覆盖 后的 结构成 员 </p>
<p>memset (&amp;s, 0x00, sizeof (Student))<br>&#x2F;&#x2F; 可 以 仅指 定 第 一成 员 的初 值 来初始 POD 对 象 后面 的 员 将 全 部 自动初始 化 为0， 就 数组 的始 化 一样<br>Student s &#x3D; {0};</p>
<p>一</p>
<p>对 象 间 的 包含 指 一 类 型 对 象 充当 了 另 一 个 类 型 定义 的 数据 成 ，:从 而 也 就 充当 了 它 的 对 象 的 成 ， 即 两 对 象 间 存 has-a 关系<br>虽然 对 象 不 能 自 包含 但 可 以 自 引用 ， 而 且 两 个 类 型 可 以 交叉 引用 ， 这种 关系称 holds-a 关系<br>| 个 对 象 不能 自 包含 无 论 是 直接 的 还 间接 的 因 为 编译 器 无法 为 计算 sizeof 值 ， 也 就 不 知道 给这 样 对 象 分 配 多 少 存储 空间<br><img src="/../img/C++/Pasted%20image%2020230601161745.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230601161855.png"></p>
<p>而 于对 齐 〈 将 大 小 调整 到 机器 字 的 整数<br>) 的 考虑 每 对 象 的 存储 空间 中 可 能 会 存在 填补 字 节 ， 这 些 字 节 单元 不 会 初始<br>化 而 具有 上 次 用 留 下 “ 脏 值 ”( 随 机 值 )。 显 然 每 对 象填补 字节 的 内 容 是<br>,会 相同 的 这就是 说 如 果编译 器 支持使用 逐 位 比较 的默认 方法 来 比较同类型 对象<br>结果 肯 定 是 不 对</p>
<h3 id="位域"><a href="#位域" class="headerlink" title="位域"></a>位域</h3><p>C 语言 位 各成 员 的 类 型 必须 int、unsigned int、signed int 等 类 型 ，C++ 还 允 许 使 char、long 等 类 型<br>不 允许 用 指针 类 型 或 浮 点 类 型 作为 位 域 的 成 员 类 ，| 因为 它们 可 能 导致 无效 的 值 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DateTime</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> year ;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> month :<span class="number">4</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> day  :<span class="number">5</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> hour  :<span class="number">5</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> minute : <span class="number">6</span>;</span><br><span class="line"><span class="number">6u</span>nsigned <span class="type">int</span> second : <span class="number">6</span>;</span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span> (DateTime) &lt;&lt; endl; <span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<p>可 以 定义 非 具 名 的 位 域 成 ， 其 作用 是 相当 于 占 位 符 可 用 来 隔离 两 相 邻 的<br>位 域 成 。 如 示例 8-7， 由 于 第 二 个 位 域 员 没有 名 字 ， 因 此 不 能 直接访问 它 所 在 的位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct DateTime</span><br><span class="line">&#123;</span><br><span class="line">	//...</span><br><span class="line">	unsigned int day :5;</span><br><span class="line">	unsigned int :2</span><br><span class="line">	unsigned int hour :5;</span><br><span class="line">	//...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可 以 定义 长 度 0 的 位 域 成 ， 其作用是 迫使 下一 个 员 从 下 一 个 完整 机 器 字 〈Word) 开始 分 配 空间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DateTime</span></span><br><span class="line">&#123; </span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> day <span class="number">25</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> :<span class="number">0</span>;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> hour <span class="number">255</span></span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">&#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(DateTime) &lt;&lt; endl; <span class="comment">// 12</span></span><br></pre></td></tr></table></figure>

<p>即使位 域 有 成 员 的位 数总 和 达 不 到 整 字 节 的倍数 位 对 象 也会 对 齐 到 机 器 字 长<br>不 能使 用 访问 数组 元 素 的 方法(<code>[]</code>) 来访问位 域 员 的 单个 位<br>如 果 有 这 种 需要 ， 请使 用 位运算 (~、区 、|、&gt;&gt;、&lt;&lt;、^ 及 其 &#x3D; 的组 合 运算 ) 或 者使 <code>std::bitset&lt;N&gt;。</code></p>
<h3 id="成员对齐"><a href="#成员对齐" class="headerlink" title="成员对齐"></a>成员对齐</h3><p>对 于 复合 类 〈 一 般 指 结构 和 类 ) 的 对 象 如 果 它 的 起 始 地 址 能 够 满足 其 中 要求 最 严格 〈 或 最 高 的 那个 数据 员 的 自然 对齐 要 求 那 么 它 就 是 自然 对 齐 的<br>如果 那 个 数据 员 又 是一 个 复合 类 型 对 象 则 依次 类 推 直 到 最 后 都 基本 类 型数据 成 员 </p>
<p>在 C++&#x2F;C 的 基本数据 类 型 中 如 果 不 考虑 enum 可 能 的 大 值 所 需 的 内 存 字节 数 ，double 就 对 齐 要 求最 严格 的 类 型 ， 其 次 int 和 float， 然 后 short、bool 和 char。</p>
<p>直接 依照 声明 顺序 来 存放 ， 即 复合 类 型 中 存在 多 个 访问 〈 即 C++ 类 中 的 每public. private 和 protected 访问 限定 )， 至 少 也 会 保证 每 个 内 的 有 数据 员 是| 按照 声明 顺序 来 存放 </p>
<p>至 于 先 声明 的 员 会 放 在 地 址 还 是 低地 址 处 完 全 是由 编译 器 实现 来 决定 的 而且 – 般 都 采用 “按照 声明 的 先后 顺序 从 低地 址 到 高 地址 依次 放 各 个 成 ” 的 方案</p>
<p>为了对象数组 要实现自然对齐</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> BYTE;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Color</span>&#123; RED = <span class="number">0x01</span>, BLUE, GREEN, YELLOW, BLACK&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Sedan</span> <span class="comment">// 私家 车</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">bool</span> m_hasSkylight; RRARS</span><br><span class="line">	Color m_color; / 颜色</span><br><span class="line">	beol m_isAutoShift; / 是 否 是 自动 档</span><br><span class="line">	<span class="type">double</span> m_price; / 价格 〈 元 )</span><br><span class="line">	BYTE m_seatNum， / 座位数量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230601165034.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230601165745.png"></p>
<p>使 offsetof 宏 这 个 宏 专 门 用 来计算 数据 员 相 对 于 对 象 起始地址 的 真实 含 移 量 它 会 把 有 隐 含 员 也 计算 进去 比 如庶 函 表 指针vptr。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; “<span class="built_in">offsetof</span>(Sedan, m_hasSkylight) =” &lt;&lt; <span class="built_in">offsetof</span>(Sedan, m_hasSkylight) ;</span><br><span class="line">std::cout &lt;&lt; “<span class="built_in">offsetof</span>(Sedan, m_color) = ” &lt;&lt; <span class="built_in">offsetof</span>(Sedan, m_color) ;</span><br><span class="line">std::cout &lt;&lt; “<span class="built_in">offsetof</span>(Sedan, m_isAutoShift) = ” &lt;&lt; <span class="built_in">offsetof</span>(Sedan, m_isAutoShift) ;</span><br><span class="line">std::cout &lt;&lt; “<span class="built_in">offsetof</span>(Sedan, m_price) =” &lt;&lt;&lt; <span class="built_in">offsetof</span>(Sedan, m_price) ;</span><br><span class="line">std::cout &lt;&lt; “<span class="built_in">offsetof</span>(Sedan, m_seatNum) = ” &lt;&lt; <span class="built_in">offsetof</span>(Sedan, m_seatNum) ;</span><br></pre></td></tr></table></figure>

<p>编 译器 不 会 随便 地 在 任意 一 个 逻辑 内 存 地址 上来 创建 C++&#x2F;C的 变量 和 对 象<br>它们 在内 存 中 的 起 地 址 需要 满足 一 定 的 条 件 数 据 成 员 也 并 一 定 是 挨 在一起 的<br>而且每个 数据 员 的 地 址 也 不是 随便 安排 的 都 需要 经 过 编译器的 精心 规划 和 计算<br>这 才能提高 对 及 其 员 的 访问 效率</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Sedan s;</span><br><span class="line">std::cout &lt;&lt; “Address of s =” &lt;&lt; (<span class="type">void</span>* )&amp;s ;</span><br><span class="line">std::cout &lt;&lt; “offset of m_hasSkylight =” &lt;&lt; ((<span class="type">char</span>*)&amp;s.m_hasSkylight — (<span class="type">char</span>*)&amp;s) ;</span><br><span class="line">std::cout &lt;&lt; “offset of m_color = ” &lt;&lt; ((<span class="type">char</span>*)&amp;s.m_color — (<span class="type">char</span>*)&amp;s) ;</span><br><span class="line">std::cout &lt;&lt; “offset of m_isAutoShift =” &lt;&lt; ((<span class="type">char</span>*)&amp;s.m_isAutoShift — (<span class="type">char</span>*)&amp;s) ;</span><br><span class="line">std::cout &lt;&lt; “offset of m_price =” &lt;&lt; ((<span class="type">char</span>*)&amp;s.m_price — (<span class="type">char</span>*)&amp;s);</span><br><span class="line">std::cout &lt;&lt; “offset of m_seatNum = ” &lt;&lt; ((<span class="type">char</span>*)&amp;s.m_seatNum — (<span class="type">char</span>*)&amp;s);</span><br></pre></td></tr></table></figure>

<p>综上 所 述 类 的 数据 成 员 类 型 的 选择 声 明 顺 序 即 排列 采 用 的 员 对 齐 方式<br>都 将影响对 象 的 实际 大小 和 访问 效率 </p>
<h3 id="联合-union"><a href="#联合-union" class="headerlink" title="联合 union"></a>联合 union</h3><p>联合 的 另 一 个 妙用 就 用 来 解析 一 个 寄存 器 或 多 字 节 内 存 变量 的 高 字 节 的 值<br>而 不 需要 我 们 手工 用 位 运算 符 来 解析 它们 。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">KeyCode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> keyNum ;</span><br><span class="line">	<span class="type">char</span> byteArr[<span class="number">2</span>] ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>枚 举 类 型还 可 以 是 匿名</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>文件 控制 块 (FCB) 的 数组</p>
<h2 id="6-第九章-编译预处理"><a href="#6-第九章-编译预处理" class="headerlink" title="6. 第九章 编译预处理"></a>6. 第九章 编译预处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1) #include &lt; &gt;</span><br><span class="line">(2) #Hinclude &quot; &quot;</span><br></pre></td></tr></table></figure>
<p>第 一 种 形式 一 般 用 来 包含 开发 环境 提供 的 库 头 文件 它 指示 编译 预 处 理 器 开发 环境 设 定 的 搜索 路 中 查找 所 需 的 头 文件<br>第 二 种 形式 一 般 用 来 包含 自己 编写 的头 文件 它 指示 编译 预处 理 器 首先 在 当前 工作 目录 下 搜索 头 文件 如 果 找 不 到 的 话再 到 开发 环境 设 定 的 路 径 中 去 查找 。</p>
<p>内 部 包含  卫 哨<br> 为了 避免 同一 个 编译 单元 包含 同一 个 头 文件 内 容 超 过 一次</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stddef.h</span></span><br><span class="line">#ifndef_STDDEF H INCLUDED_</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STDDEF_H INCLUDED _</span></span><br><span class="line">					/ / 头 文件 内 容</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>    /!STDDEF H_INCLUDED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “stddef.h”</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> “stddef.h” /! No problem!</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>外 部 包含 卫  哨</p>
<p>当 一 个 头 文件 被 一 个源 文件 反 复 包 含 多 次 避免 多 次 查找 和 打开 头 文件 的 操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined ( INCLUDED_STDDEF_H_)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _INCLUDED_STDDEF_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//!_ INCLUDED _STDDEF_H_</span></span></span><br></pre></td></tr></table></figure>

<p>在 头 文件 中 :<br>(1) 包含 当前 工程 中 所 需要 的 自 定义 头 文件 〈 顺 序 自 );<br>(2) 包含 第 三 方程 序库 的 头 文件 ;<br>(3) 包含标准 头 文件 。<br>在 源 文 中 :<br>(1) 包含 源 文件 对 应 的 头 文件 《如 果 存 );<br>(2) 包含 当前 工程 中 所 需要 的 自 定义 头 文件 ;<br>(3) 包含 第 三 方程 序 库 的 头 文件 ;<br>(4) 包含 标准 头 文件 </p>
<p>宏 定义 具有 文件作用</p>
<p>宏定义 <code>#define</code> 关键 字 后 出现 的 第一 个 连续字符 序列 作为 宏 名<br>剩 下 的 部 作为 宏体</p>
<p>宏 不 会 进入 符号<br>即 宏替换 后 出 了 语法 错误 编 译 器 也 会 将 错误<br>定位 到 源 程序中<br>而 不 是 定位 到 具体的 某个 宏 定义 </p>
<p>定义 带 参数 的 宏 ， 宏 和 左 括号 之 间 不 能 出 现 空格 否 则 使 用 时 会 出问题<br>但 是 编译 器 不 检查 出 这 种 错误</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">define <span class="title">OUTPUT</span><span class="params">(word)</span> cout &lt;&lt; <span class="meta">#word &lt;&lt; endl</span></span></span><br><span class="line"><span class="function"><span class="title">OUTPUTI</span><span class="params">( like swimming very much.)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;I like swimming very much.&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT (str)#str</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">TEXT</span>(Hello World);</span><br><span class="line">(str)<span class="meta">#str(Hello World);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PL 2 (2 * PI)</span></span><br><span class="line"></span><br><span class="line">带 参数 的 宏 体 和 各个形 参 应 该 分 别 用 括号 括 起 来</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x)((x) * (x))</span></span><br><span class="line"></span><br><span class="line">不 要 在 引用 宏 定义 的 参数 列表 中 使 用 增 和 减 量 运算 符 否则 将 导致 变量的 多 次 求值</span><br><span class="line"><span class="type">int</span> n=<span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">SQUARE</span>(n++&#125;;</span><br><span class="line"><span class="type">int</span> x = ((n++) * (n++));</span><br><span class="line"></span><br><span class="line">其结果 将 <span class="number">30</span> 而 不 是 期 望 <span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>用 宏 来 构造 一 些 重复 、 数据 和 函数 混合 的 功 能 较 特 殊 的代码 段 时候 其 优点就显示 出 来 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE DYNAMIC(class_name) \</span></span><br><span class="line"><span class="meta">protected: \</span></span><br><span class="line"><span class="meta">static CRuntimeClass* PASCAL _GetBaseClass(); \</span></span><br><span class="line"><span class="meta">public: \</span></span><br><span class="line"><span class="meta">static const AFX_DATA CRuntimeClass class##class_name; \</span></span><br><span class="line"><span class="meta">virtual CRuntimeClass* GetRuntimeClass() const;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DECLARE _DYNCREATE(class_name) \</span></span><br><span class="line"><span class="meta">DECLARE_DYNAMIC(class_name) \</span></span><br><span class="line"><span class="meta">static CObject* PASCAL CreateObject();</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">undef</span> TEXT</span></span><br></pre></td></tr></table></figure>

<p>不 要 使 用 宏 来 定义 新 类 型 名 应 该 使 typedef， 否则 容易 造成错误<br>给 宏 加 注释 时 请 使 块 注释 〈<code>/* */</code>)， 而 要 使 用 行 注释 </p>
<p>对 于 较 长 的 用 频率 较高 的 重复 代码 片段 建 议 用 函数 或 模板<br>对 于 较 短 的 重复代码 片段 可 以 用 带 参数 的 宏 定义</p>
<h3 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#if 0</span><br><span class="line">	… / 希望 禁止 编译 的代码</span><br><span class="line">	... / 希望 禁止 编译 的 代码</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>编译 伪 指 <code>#error</code> 用 于 输出 与 平台 、 环 境 有 关 的 信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(WIN32)</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> ERROR: Only Win32 platform supported!</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> cplusplus</span></span><br><span class="line"><span class="meta">#<span class="keyword">error</span> MFC requires C++ compilation (use a .cpp suffix)</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>编译伪指令#pragma 用于执行语言实现所定义的动作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pragma <span class="title">pack</span><span class="params">(push, <span class="number">8</span>)</span> <span class="comment">/* 对 象 员 对 齐 字 节数 所</span></span></span><br><span class="line"><span class="comment"><span class="function">#pragma pack(pop)</span></span></span><br><span class="line"><span class="comment"><span class="function">#pragma warning(disable:4069)  /*不要产生C4069警告 */</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;kernel32.lib&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;user32.lib&quot;</span>)</span></span></span><br><span class="line"><span class="function"><span class="meta">#<span class="keyword">pragma</span> comment(lib, <span class="string">&quot;gdi32.lib&quot;</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>构 串 操作符 # 只 能修饰 带 参数 的 宏 的 形 参 它 将 实 参 的 字符 序列<br>转换 字符 串 常量<br>而 不 是 实 参代表 的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> STRING(x) #x #x #x</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TEXT(x) <span class="string">&quot;class&quot;</span> #x <span class="string">&quot;Info&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>合并 操作符 ## 将 出现在 其 左右 的 字符 序列 合并 成 个新 的标识</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CLASS NAME(name) class##name</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MERGE(x, y) x##y#x</span></span><br><span class="line"></span><br><span class="line">classSysTimer</span><br><span class="line">meTome</span><br></pre></td></tr></table></figure>
<p><img src="/../img/C++/Pasted%20image%2020230602074658.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> * <span class="type">const</span> pDouble = <span class="built_in">new</span>(nothrow) <span class="type">double</span>[ <span class="number">10000000</span>&#125;;</span><br><span class="line"><span class="keyword">if</span>( pDouble == <span class="literal">NULL</span> ) &#123;</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot;allocate memory failed on line&quot;</span>&lt;&lt;(_ LINE <span class="number">-2</span>)</span><br><span class="line">&lt;&lt; <span class="string">&quot;in file&quot;</span> &lt;&lt; FILE &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="C-文件结构-程序板式"><a href="#C-文件结构-程序板式" class="headerlink" title="C++文件结构 程序板式"></a>C++文件结构 程序板式</h3><p> 头 文件 的 有 内 容 最 终都 会 被 合并 到 某 一 个 或 几 个 源 文件 ，<br> 如 此 将 一 个 包含 的 头 文件 递归 地 展开 后 形成 的 源 文件 叫 编译单元<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">char</span> *name;</span><br><span class="line"><span class="type">int</span> *x，y; / 此 y 不 会 误解 为 指针</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>* PINT;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span>&amp; RINT;</span><br><span class="line">PINT pl, p2; / 两 个 指针</span><br><span class="line">RINT ril=i r2=j; /两 引用</span><br></pre></td></tr></table></figure></p>
<h3 id="C-命名规则"><a href="#C-命名规则" class="headerlink" title="C++命名规则"></a>C++命名规则</h3><h2 id="7-C-面向对象程序设计方法"><a href="#7-C-面向对象程序设计方法" class="headerlink" title="7. C++面向对象程序设计方法"></a>7. C++面向对象程序设计方法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">继承</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Funcl</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func2</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func3</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Func4</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">B b;</span><br><span class="line">b.<span class="built_in">Funcl</span>(); </span><br><span class="line">b.<span class="built_in">Func2</span>();</span><br><span class="line">b.<span class="built_in">Func3</span>();</span><br><span class="line">b.<span class="built_in">Func4</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>C++ 虚函数，抽象基类， 动态绑定 (Dynamic binding) 多态 (Polymorphism)<br>构成 了 出 色 的 动态 特性</p>
<p>为 了 使 这 种 行为 可 行 我 们 把基类 Shape 中 的 函数 Draw0O 声 明 为 虚 函 数<br>然 后在 派生 类 中 重新定义 Draw()<br>使 之绘制 正确 的 形状 这 种 方法叫覆盖 〈Override)。 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">void</span>)</span></span>; <span class="comment">// Draw() </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">void</span>)</span></span>; / /Draw0O 为 虚 函数 不写<span class="keyword">virtual</span> 也会变成虚函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽 象 类 的唯 – 目 的 是 让 其派生 类 继承 并 实现 它 的 接口 方法 (Method)，<br>因 此 它 通 也 被 称 为抽象 基 类 〈Abstract Base Class) </p>
<p>如 果 将 基 类 的 虚 函 数 声明 为 纯虚 函数 那 么 类 就 定义 了 抽象 基类 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123; <span class="comment">// Shape 是 抽象 基类</span></span><br><span class="line">ublic:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">void</span>)</span> </span>= <span class="number">0</span>; / <span class="built_in">Draw</span>(<span class="number">0</span> 为 纯 虚 函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将一 个 函数初始 化 0 意味 着 函数 地 址 将为 0，<br>这就是 在 告诉 编译 器 不 要 为 函数 编 址 从 而阻止 类 的 实例 化行为<br>C++ 中 只 有虚 函 数 才可 以 被 初始 化 0</p>
<p>一般 的 信息 隐藏 是 把类 的 有 数据 员 声 明 private 或 protected 的<br>并 提供 相应 get set 函数 来 访问 对象 的 数据</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> [Rectangle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">IRectangle</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetLength</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span> </span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetLength</span><span class="params">( <span class="type">float</span> newLength)</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">virtual</span> <span class="type">float</span> GetWidthQ <span class="type">const</span> = <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetWidth</span><span class="params">(<span class="type">float</span> <span class="keyword">new</span> Width)</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> RGB <span class="title">GetColor</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span> ; <span class="comment">// RGB : unsigned long</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">SetColor</span><span class="params">(RGB newColor)</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">CalculateArea</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">virtual</span> <span class="type">void</span> DrawQ) = <span class="number">0</span>;</span><br><span class="line"><span class="type">static</span> IRectangle* _stdcall CreateRectangleQ; /入 口 函数</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span>&#123; <span class="keyword">delete</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleImpl</span> : <span class="keyword">public</span> [Rectangle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RectangleImplQ : <span class="built_in">m_length</span>(<span class="number">1</span>), <span class="built_in">m_width</span>(<span class="number">1</span>), <span class="built_in">m_color</span>(OxOOFFEC4D)&#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">RectangleImpl</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> <span class="title">GetLength</span><span class="params">( <span class="type">const</span> &#123; <span class="keyword">return</span> m_length; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> SetLength(<span class="type">float</span> newLength) &#123; m_length = newLength; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> GetWidth() <span class="type">const</span> &#123; <span class="keyword">return</span> m_width; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> SetWidth(<span class="type">float</span> newWidth) &#123; m_width = newWidth; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> RGB GetColor() <span class="type">const</span> &#123; <span class="keyword">return</span> m_color; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> SetColor(RGB newColor) &#123; m_color = newColor; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">float</span> CalculateArea() <span class="type">const</span> &#123; <span class="keyword">return</span> m_length * m_width; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> +Draw() &#123; cout &lt;&lt; <span class="string">&quot;RectangleImpl::Draw(Q)&quot;</span> &lt;&lt; endl; &#125;</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="keyword">private</span>:</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">float</span> m_length;</span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">float</span> m_width;</span></span></span><br><span class="line"><span class="params"><span class="function">	RGB mcolor;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;;</span></span></span><br><span class="line"><span class="params"><span class="function">	IRectangle* stdcall IRectangle::CreateRectangleO</span></span></span><br><span class="line"><span class="params"><span class="function">	&#123;Return <span class="keyword">new</span>(nothrow) RectangleImpl;&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>每 一 个 具有 虚 函 数 的 类 都 叫做 多 态 类，<br>这 个 虚 函 数 或者是 从基 类 继承 来 或者是 自己 新 增加<br>C++ 编译 器 必须 为 每 一 多 态 类 至 少 创建 一 个 虚 函 数 表 (vtable )，<br>它 实 就 是一 个 函数 指针 数组<br>其 中 存放 着这 个类 所 有 的 虚 函 数 的 地 址 及 该 类 的 类、型信息<br>其 中 也 包括 那些 继承但 未 改写 《Overrides) 的 虚 函 数</p>
<p>每一 个 多 态 对有 一 个 隐 含 的 指针 成 ， 它 指向 所 属 类 型 vtable， 这就 vptr。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*(p-&gt;_vptr[slotNum]))(p, arg-list); <span class="comment">// 指针 当 作 数组 来 用 最 后 改写 为 指针 运算</span></span><br></pre></td></tr></table></figure>

<p>派生 类 定义 中 的 名 字 〈 对 象 函数 ) 将 义无反顾 地 遮 项 〈( 即 隐藏 )掉 、<br>基 类 中 任何 同名 的 对 象 函数</p>
<p>基 于 这 样 的 规则 ， 如 果 派生 类 定义 了 一 个 与 基类 的 虚 函 数 同名 的 虚 函 数<br>但 是 <strong>参数 列表 有 所 不 同</strong><br>那 这就 不 会 编译 器 认为 是对 基 类 虚 函 数 的 改写 (Overrides)， 而 是 <strong>隐藏</strong><br>所 以 也 不 可 能 生 运行 时 绑 定</p>
<p>要 想 达成 运行 时 <strong>绑 定</strong> 的 效果 ，<br>派 生 类 和 基 类 中 同名 的 虚 函 数 必须 具有 相同 的 原型 ，<br>也 即 相同 Signature〈 返 回 类 型可 以 不 同 这是 C++ 的 一 个 特征 一 协 变)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IRectangle</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">IRectangle</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">()</span> </span>= <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectangleImpl</span> : <span class="keyword">public</span> [Rectangle &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">RectangleImplQ) : <span class="built_in">m_length</span>(<span class="number">1</span>), <span class="built_in">m_width</span>(<span class="number">1</span>), <span class="built_in">m_color</span>(Ox0OFFEC4D) &#123;&#125;</span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">RectangleImpl</span>() &#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">(<span class="type">int</span> scale)</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;RectangleImpl::Draw(int)&quot;</span> &lt;&lt; endl; &#125; <span class="comment">// (1)</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">Draw</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;RectangleImpl::Draw()&quot;</span> &lt;&lt; endl; &#125; (<span class="number">2</span>)</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">float</span> m_length;</span><br><span class="line"><span class="type">float</span> m_width;</span><br><span class="line">RGB mcolor;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IRectangle *pRect = [Rectangle::<span class="built_in">CreateRectangle</span>();</span><br><span class="line"><span class="keyword">if</span> (pRect == <span class="literal">NULL</span>) <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">pRect-&gt;<span class="built_in">Draw</span>(); <span class="comment">// FA-F pRect MatAS2R HW TRectangle*, ATLAH IRectangle::</span></span><br><span class="line">/Draw0 执行 静态 类 型 检查 但 由 pRect 指向 的 对 象实际 是</span><br><span class="line">/&#123; Rectanglelmpl <span class="number">9</span>, <span class="function">FAM hse Fl <span class="title">Rectanglelmpl::Draw</span><span class="params">()</span>!</span></span><br><span class="line"><span class="function">pRect-&gt;<span class="title">Draw</span><span class="params">(<span class="number">200</span>)</span></span>; /W 同 理 由 于 下 ectangie 类 并 没有 此 类 原型 的 函数 因 此 拒绝</span><br><span class="line">/ 编译 除 pRect 的 类 型 RectangleImpl* 。 此 <span class="built_in">Draw</span>(<span class="number">0</span>) 非 彼</span><br><span class="line">/DrawgO</span><br><span class="line">pRect-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line">pRect = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如 果 RectangleImpl 不 重 定义 Draw0O 函 数 那 下 面<br>代码 ， </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RectangleImpl *pRectImpl = <span class="keyword">new</span> RectangleImpli</span><br><span class="line">pRectImpl-&gt;DrawQ); /<span class="built_in">f</span> (<span class="number">3</span>)</span><br><span class="line">pRectImpl-&gt;<span class="built_in">Draw</span>(<span class="number">200</span>); <span class="comment">// OK!</span></span><br></pre></td></tr></table></figure>
<p> 将 无法 编译 因 为 (3) 处 调用 的 Draw0 是 基 类 的 函数 它 RectangleImpl 中 的 同名<br>| BR Drawn eT, BRT!</p>
<h3 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Draw</span><span class="params">(Shape *pShape)</span> <span class="comment">// SAHA</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pShape-&gt;<span class="built_in">Draw</span>(); / 或 : (*pShapej.<span class="built_in">Draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">main</span>()</span><br><span class="line">&#123;</span><br><span class="line">Circle aCircle;</span><br><span class="line">Cube aCube;</span><br><span class="line">Sphere aSphere;</span><br><span class="line">:<span class="built_in">Draw</span>(&amp;aCircle); <span class="comment">// 绘制 一 circle</span></span><br><span class="line">:<span class="built_in">Draw</span>(&amp;aCube); /W 绘制 一 cube</span><br><span class="line">:<span class="built_in">Draw</span>(&amp;aSphere); / 绘制 一 Sphere</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RTTI也是一种运行时多态 dynamic_cast&lt;&gt; 和 typeid 运算 符<br>依赖 RTTI 会 导 致 严重 的 效率 低下</p>
<p>如 果 确 实 需要使 用 多 态 数 组 请使 STL 容器 配合 普通 指针 或者 智能 指针 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> SmartPtr&lt;Shape&gt; ShapeSmartPtr;</span><br><span class="line">ShapeSmartPtr shapes[<span class="number">3</span>];</span><br><span class="line"><span class="function">ShapeSmartPtr <span class="title">p</span><span class="params">(<span class="keyword">new</span> Shape(Point(<span class="number">1</span>, <span class="number">1</span>)))</span></span>;</span><br><span class="line"><span class="function">ShapeSmartPtr <span class="title">q</span><span class="params">(<span class="keyword">new</span> Circle(Point(<span class="number">2</span>, <span class="number">2</span>), <span class="number">5</span>))</span></span>;</span><br><span class="line"><span class="function">ShapeSmartPtr <span class="title">r</span><span class="params">(<span class="keyword">new</span> Rectangle(Point(<span class="number">3</span>, <span class="number">3</span>), Point(<span class="number">4</span>, <span class="number">4</span>)))</span></span>;</span><br><span class="line">shapes[<span class="number">0</span>] = p;</span><br><span class="line">shapes[<span class="number">1</span>] = q;</span><br><span class="line">shapes[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; <span class="number">1</span> &lt; <span class="number">3</span>; ++i)</span><br><span class="line">shapes[i]-&gt;<span class="built_in">Draw</span>();</span><br></pre></td></tr></table></figure>
<h3 id="C-对象模型"><a href="#C-对象模型" class="headerlink" title="C++对象模型"></a>C++对象模型</h3><p><img src="/../img/C++/Pasted%20image%2020230602093920.png"></p>
<p>如 果 基 类 已 经 插入 了 vptr， 则 派生 类 将 继承 和 重用 vptr;</p>
<p>如 果 派 生 类 是 从 多 个 基 类 继承 或 有 多 个 继承 分 《从 所 有根类 开始 算起 )，<br>而 中 若干 个 继承 分 上 出 了 多 态 ，<br>则 派生 类 将 从 这些 分 中 的每 个 分 上 继承 一 个vptr，<br>编 译 器 也 将 为 它 生 成 多 个 vtable，<br>有 几 vptr 就生成 几 个 vtable (每 vptr 分 别 指向 中 一 )，<br>分 别 与它 的 多 态 基 类 对 应 ;</p>
<p>vptr 在 派生 类 对 象 中 的 相对 位 置 不 会 随 着 继承层次 的 逐渐 加 深 而 改变<br>并且现在 的 编译 器 一 般 都 vptr 放 在 有 数据 员 的 最 前 </p>
<p>为 了 支持 RTTI， 为 一 多 态 类 创建 一 type_info 对 象<br>并 把 地 址 保存在 vtable 中 的 固定 位</p>
<p><img src="/../img/C++/Pasted%20image%2020230602094557.png"></p>
<p>vtable 也 是一 个 函数 指针 数组 按 理 说 也 只 能 存放 类 型 相同 的 函数 指针 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(__cdecl *PVFN)</span><span class="params">(<span class="type">void</span>)</span></span>; / 通用 的 虚 函 数 指针 类</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	type_info *_pTypelnfo;</span><br><span class="line">	PVFN _arrayOfPvfn&#123;]; / 虚 函 数 个 数 由初始 化 语句 确定</span><br><span class="line">&#125; VIABLE;</span><br></pre></td></tr></table></figure>

<p>如 果派 生 类 改写 了 基 类 的 虚 函 数<br>则 这 个 函数 的 地址 在派生 类 vtable 中 的位 置 它 在其 基类 vtable 中 的 位 置 一致<br>(覆盖)</p>
<p>虚 函 数 第一 次 出现时 它 vtable 中 的 位 置 旦 确定 就 不随 派生 层次 的 增加 而 改变<br>除 非 改 了 它 和 其 他 虚 函 数 class 中 第 一 次声明 的 顺序 </p>
<p>派生 类 没有 改写 基 类 虚 函 数 被 继承 下来并 插入派生 类 vtable 中<br>(与 该函数 所 在 基 类对 应 下 来 的 那个 vtable)，<br>且 在 派生 类 vtable 中 的 位 置 其基 类 vtable 中 的 位 相 同 </p>
<p><img src="/../img/C++/Pasted%20image%2020230602102846.png"></p>
<p> 类的 静态 数据 员 可 以 class 的 定义 中 直接 初始 化<br> 但 是要 清楚 : 这 只 是声明并 给 它 提供 了 一 个 初 值 而 已<br> 还 必须 在 某 一 个 编译 单元 中 把 它 定义 一 次〈 即 分 配 内存)。</p>
<h2 id="8-对象的初始化-拷贝-析构"><a href="#8-对象的初始化-拷贝-析构" class="headerlink" title="8. 对象的初始化 拷贝 析构"></a>8. 对象的初始化 拷贝 析构</h2><p>”初始 化 是 在 对 象 创建 的 同时 使 初 直接 填充 对 象 的 内 存单 元 因 此<br>不 有 数据 类 型 转换 中 间 过 程 也 就 不 会 产生 临时 对 象</p>
<p>赋值 则 是在 对 象 创建 好 后 任何 时 候 可 以 调用 的 而 且 可 以 多 次 调用 的 函数<br>由 于它 调用 的 “&#x3D;” 运 算 符<br>因 此 可 能 需要 进行 类 型 转换 即 会 产生 临时 对象</p>
<p>如果程序员没有为一个多态类显式地定义 默认构造函数 拷贝构造函数 析构函数或拷贝赋值函数<br>那么 编译 器会 自动 地 生成 相应 的 函数 它 们 都public inline的 ,<br>并 在 其中 插入 正确 初始 化 或 修改 vptr 数 据 员 值 代码 ，<br>从 而 确保基 类 对 和 派生 类 对 象 构造 时 及 在 它们 之 间 拷贝时<br>vptr 能 够向 重新 指向 恰当 的 vtable.<br>这样 四 个 函数 就 分 别 叫 做<br>非 平凡 默认 构造函数<br>非 平凡 拷贝 构造 函数<br>非 平凡 析 构 函数 和<br>非 平凡 拷贝 赋值 函数 </p>
<p>在 构造 函数 体内 来 初始 化 数据 不 是 真正 意义 上 的初始化 而 是 赋值</p>
<p>由 于 构造 函数 是 创建 一 对象 时 自动 调用 的 第 一 个 成员 函数<br>因 此 我 们也 愿意 把 构造 函数 体内 的 赋值 语句 当成 初始 化 来 看</p>
<p>真正 的 初始 化 是 用 所 谓 “初始 化表达式表”( 简称 初始 化 列表 ) 进行<br>初始 化 列表 位 于 构造 函数 参数 表 之 后 在 函数 {} 之 前</p>
<p>如 果 类 存在 继承 关系 派 生类可 以 直接 在其 初始 化 列表 里<br>调用 基 类 的 特定构造 函数 以 向 它 传递 参数<br>因 为 我们 不 能 在 初始 化 对 象 时 访问 基 类 的 数据 成 员</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">int</span> x); /A 的 构造 函数</span><br><span class="line">vas B : <span class="keyword">public</span> A &#123;</span><br><span class="line"><span class="built_in">B</span>(<span class="type">int</span> x, <span class="type">int</span> y); /B 的 构造函数</span><br><span class="line">Buin x, <span class="type">int</span> y) : <span class="built_in">A</span>(x) / 在 初始 化 列表 里 调用 A 的 构造 函数</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类 的 非 静 const 数据 成 和 引用 成 员 只 能 在 初始 化 列表 里 初始 化<br>因 为它们 只 存在 初始 化 语义 而 不 存在 赋值 语义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">int m;</span><br><span class="line">int &amp;n=m;</span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">A(void); BRA</span><br><span class="line">A(const A&amp; other); / 拷贝 构造 函数</span><br><span class="line">A&amp; operator =( const A&amp; other); / 赋值 函数</span><br><span class="line">&#125;;</span><br><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">B(const A&amp; a); /B 的 构造 函数</span><br><span class="line">Private:</span><br><span class="line">A ma; / 成 员 对</span><br><span class="line">&#125;;</span><br><span class="line">/ (1) 采用 初始 化 列表 的 方式初始</span><br><span class="line">B::B(const A&amp; a) : m_a(a)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">(2) 采用 函数 体内 赋值 的 方式 初始</span><br><span class="line">B::B(const A&amp; a)</span><br><span class="line">&#123;</span><br><span class="line">m_a=a; // 〈 调 了 A 的 默认 构造 函数 )， 再 调用类 A 的 赋值 函数 才 将 参数 a赋 m_a。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 对于 内 部 数据 类 型 的 数据 员 而 言 两 种 初始 化 方式 的 效率 几乎 没有 区别<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">class</span> <span class="title class_">F</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">F</span>(<span class="type">int</span> x, <span class="type">int</span> y); / 构造 函数</span><br><span class="line">Private:</span><br><span class="line"><span class="type">int</span> m_x;</span><br><span class="line"><span class="type">int</span> m_y;</span><br><span class="line">&#125;</span><br><span class="line">CL) 采用初始 化 列表 的 方式初始</span><br><span class="line">F::<span class="built_in">F</span>(<span class="type">int</span> x, <span class="type">int</span> y) : <span class="built_in">m_x</span>(x), <span class="built_in">m_y</span>(y)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">(<span class="number">2</span>) 采用 函数 体内 赋值 的 方式初始</span><br><span class="line">F::<span class="built_in">F</span>(<span class="type">int</span> x, <span class="type">int</span> y)</span><br><span class="line">&#123;</span><br><span class="line">m_x=x;</span><br><span class="line">my=y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>初始化顺序序 并不 一 定 与 你在 初始 化 列表 中 为 它们 安排 的 顺序 一 致<br>编 译 器 总 是按照 它们 在 类 中 <strong>声明 的 次序</strong> 来 初始 化 的<br>所以最 好 是 按照 它们 的 声明 顺序 书写 员 初 始 化 列表 </p>
<p>如 果 各 个 员 的 初始 化 存在依赖 关系<br>要 注意 顺序 问题<br>可 以 调整 下 数据员 的 <strong>声明 顺序</strong> 避免 这 个 问题</p>
<p>构造 函数首先 调用每 一 个基类 的 构造 函数<br>然 后 调用成 员 对 象 的 构造 函数<br>而 每 一 基类 的构造 函数 又 将 首先 调用 它们 各 自 基类 的 构造 函数 直 到 最 根 。 </p>
<p>析 构 会 严格 按照 对 象 构造 相反 的 次 序 执行 该 次 序 是 唯一 的 否 则 编译 器 将 无 法 自动 执行 析 构 过 ;</p>
<p>数据 员 的 初始 化 次 序 完全 不 受 它们 在 初始 化 列表 中 出 现 次 序 的 影响<br>只由 它们 在 类 中 声明 的 次 序 决 定 因 为 这 个 顺序 是 唯一 的</p>
<p>如 果 数 据 员 按照 初始 化 列表 的次序 进 行 构造 将 导致 析 构 函数 无法得到唯一的逆序。</p>
<p>拷贝 构造 函数 的 参数 必须 是 同类 对 象 的 引用 ， 而 不 能 是 对 象 值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line"> 拷贝构造 函数</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">A</span>(A copy)&#123;...&#125; “#Q)陷入 不 地 分 配 堆栈 的 无 限 递归</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; other) &#123;...&#125; (<span class="number">2</span>)</span><br><span class="line">MN...</span><br><span class="line">上</span><br><span class="line">Aa;</span><br><span class="line">Ab=a;</span><br></pre></td></tr></table></figure>

<p>不 主 动 编写 拷贝 构造 函数 和 拷贝 赋值 函数 编 译 器<br>将 “ 按 员 拷贝 ”的 方式 自动 生成 相应 的默认 函数<br>倘 类 中 含有 指针 员 或 引用 成员 ， 那 这 两 个默认 的 函数 可 能 隐 含错误</p>
<p><img src="/../img/C++/Pasted%20image%2020230602112452.png"></p>
<p>拷贝 构造 函数 是在对 象 被 创建 并 用 另 一 个 已 经 存在 的 对 象 来 初始 化 它 时 调用<br>赋值函数只能把一个对象 赋值 给 另 一 个 已 经 存在 的 对 象<br>使 得 经 存在 的 对 象 有 和 源 对 象 相同 的 状态 。</p>
<p><img src="/../img/C++/Pasted%20image%2020230602112740.png"></p>
<p>只 需 将 拷贝 构造 函数 和 拷贝 赋值 函数 声明 private， 并 且 不 实现 它们<br>显 式 声明 的 这两 个函数 会 阻止 编译 器 自动 生成 相应 的 默认 函数</p>
<p>甚至 可 以 把 类 的 有 构造 函数 和 赋值函数 都 声明 为 private，<br>这 样 就 彻底 阻止 了类 的 实例 化 </p>
<p>或 者 把 默认 构造 函数 声明为 private，<br>而 把 其 他 带 参 数 的 构造 函数明 public，<br>这 样 强 用 户 使 用 带 参数 的 构造 函数 来 声明 和 定义 对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">fe.</span><br><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="title">GetType</span><span class="params">()</span></span>; / 未 实现</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">A</span>(<span class="type">const</span> A&amp; a); / 私有 的 拷贝 构造 函数</span><br><span class="line">A&amp; <span class="keyword">operator</span>=(<span class="type">const</span> A&amp; a); / 私有 的 拷贝 赋值 函数</span><br><span class="line">is</span><br><span class="line">如 果 有 人 试图 编写 如下 程序 :</span><br><span class="line">A ba); UBF T AAA See DFE</span><br><span class="line">b=a; / 调用 了 私有 的 赋值 函数</span><br></pre></td></tr></table></figure>


<p>派生 类 的 构造函数 应 在其 初始 化 列表 里显式 地 调用 基 类 的 构造 函数</p>
<p>如 果 基 类 是 多 态 ， 那 么 必须 把 基 类 的 析 构 函数 定义 为 虚 函 数<br>这 样 可以 其 他虚 函 数 一 实现 动态 绑 定 否则 有可 能 造成 内 存 泄漏<br>delete 基类指针 不会释放派生类</p>
<p>基关 的 构造函数 、 析 构 函 数 赋信函 数都 不 能被 派生 类 继承<br><img src="/../img/C++/Pasted%20image%2020230602114921.png"></p>
<h2 id="9-C-函数-高级特性"><a href="#9-C-函数-高级特性" class="headerlink" title="9. C++函数 高级特性"></a>9. C++函数 高级特性</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><p>编译 器 根据 参数列表 为 个 重 载 函 数 产生 不 同的 内 部 标识 符 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> _cdeci <span class="title">foo</span><span class="params">(intx, inty)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该 函数 被 C 编译 器 编译 后 在 库 中 的 名 字 为 foo，<br>而 C++ 编译 器 则 会 产生 像 | <code>_foo_int_int</code> 之 类 的 内 部 名 字 用 来 支持 函数 重 载<br>由 于 编译 后 的 名 字 不 同 ，C++ 程 序 | 不能 直接 调用 编译 后 C 函数 。<br>C++ 提 供 了 一 C 连接交换 指示 符 extern “C” 来 解决 这 个 问题</p>
<p>这就 是连接 规范 的 概念</p>
<p>上 述代码 是 在 告诉 C++ 编译 器 函 foo 是 C 连接<br>函数 应 该 为 生成 名 字 <code>_foo</code> 而 不 <code>_foo_int_int</code>，<br>并 指示连接 器 到 C 程序 库 中 去 找该函数 的 定义</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">( intx )</span></span>; / 函数 声明</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">( <span class="type">float</span> x )</span></span>; / 函数 声明</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">( <span class="type">int</span> x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot; output int &quot;</span>&lt;&lt; x &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">output</span><span class="params">( <span class="type">float</span> x )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot; output float &quot;</span> &lt;&lt; x &lt;&lt; endl ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x=<span class="number">1</span>;</span><br><span class="line"><span class="type">float</span> y = <span class="number">1.0</span>;</span><br><span class="line"><span class="built_in">output</span>(x); <span class="comment">// output int1</span></span><br><span class="line"><span class="built_in">output</span>(y); <span class="comment">// output float 1</span></span><br><span class="line"><span class="built_in">output</span>(<span class="number">1</span>); <span class="comment">// output int 1</span></span><br><span class="line"><span class="built_in">output</span>(<span class="number">0.5</span>); / 错误 ! 不 明确 的 调用 ， 因 为 自动 类 型 转换</span><br><span class="line"><span class="built_in">output</span>(<span class="built_in">int</span>(<span class="number">0.5</span>)); <span class="comment">// output int 0</span></span><br><span class="line"><span class="built_in">output</span>(<span class="built_in">float</span>(<span class="number">0.5</span>)); /f output <span class="type">float</span> <span class="number">0.5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="成员函数的重载-覆盖与隐藏"><a href="#成员函数的重载-覆盖与隐藏" class="headerlink" title="成员函数的重载 覆盖与隐藏"></a>成员函数的重载 覆盖与隐藏</h3><p>成 员 函 数被<strong>重载</strong> 的 特征 ：<br>具 有 相同 作用域 〈 即 同一 个 类 定义 );<br>函数名字相同<br>参数 类 型 顺序 或数目 不 同〈 包 const 参数 和 非 const 参数 );<br>virtual 关键字 可有可无</p>
<p><strong>履 盖</strong> 是 指派 生 类 重新 实现 〈 或 者 改写 了 基 类 的 员 函 数 其 特征 :<br>不 同 的作用域 〈 分 别 于派生 类 和 基 类 中 );<br>函数名称相同<br>参 数列 表完 全 相同 ;<br>基 类 函数 必须 是 虚 函 数 <strong>只能覆盖 同名同参 虚函数</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream.h&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(int) &quot;</span>&lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">float</span> x)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Base::f(float) &quot;</span>&lt;&lt; x &lt;&lt; endl; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span>)</span></span>&#123; cout &lt;&lt; <span class="string">&quot;Base::g(void)&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">b</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">g</span><span class="params">(<span class="type">void</span>)</span></span>&#123; cout &lt;&lt; “Derived::<span class="built_in">g</span>(<span class="type">void</span>)<span class="string">&quot; &lt;&lt; endl; &#125;</span></span><br><span class="line"><span class="string">上</span></span><br><span class="line"><span class="string">void main(void)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">Derived d;</span></span><br><span class="line"><span class="string">Base *pb = &amp;d;</span></span><br><span class="line"><span class="string">| pb—&gt;f(42); // Base::f(int) 42</span></span><br><span class="line"><span class="string">pb 一 &gt;f3.140; ——_‘// Base::f(float) 3.14</span></span><br><span class="line"><span class="string">pb 一 &gt;gO; / Derived::g(void)</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<p>函数 Base::fint) Base::f(float)构成重载<br>Base::g(void) 被 Derived::g(void) 覆盖</p>
<p>虚 函 数 的 覆盖 有 两 种 方式 : 完全 重 和 扩展 。<br>扩展 是 指派 生 类 诬 数 首先 调用 基 类的 虚 函 数 然 后 再 增加 新 的 功能 。</p>
<p>“隐藏 ”是 指派 生 类 的 员 函 数 遮 了 与 其 同名 的 基 类 成 员 函 数：</p>
<ol>
<li>派 生 类 的 函数 基类 的 函数 同名 ， 但 是 <strong>参数 列表 有所 差异</strong><br>不轮 有无 virtual 关键 ， 基 类 的 函数 在 派生 类 中 将 隐藏</li>
<li>派生类的函数与基类的函数同名，<strong>参 数列表也相同</strong> 但 基类函数 没有virtual 关键字。<br>此 时 , 基类的函数在派生类中将隐藏 (注意 别 与 覆盖 混淆 )。</li>
</ol>
<p>解释：<br>对于第一点 同名不同参 同作用域为重载 不同作用域为隐藏<br>对于第二点 同名同参 是虚函数 则覆盖 不是虚函数则隐藏</p>
<p><img src="/../img/C++/Pasted%20image%2020230602133459.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> *str)</span></span>;</span><br><span class="line">上</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Test</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Derived *pd = <span class="keyword">new</span> Derived;</span><br><span class="line">pd—&gt;<span class="built_in">f</span>(<span class="number">10</span>);—_<span class="comment">// error!</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">char</span> *str)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; Base::<span class="built_in">f</span>(x); &#125; / 调用传递</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>void Foo(int x &#x3D; 0, int y &#x3D; 0); &#x2F; 正确 默 认值 出现在 函数 的 声明 中<br>如 果 函 有 多 个 参数 参 数 只 能 从 后 向 前 依次 默认 </p>
<p><img src="/../img/C++/Pasted%20image%2020230602134849.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230602135659.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230602135956.png"></p>
<p>C++ 标准 规定 当 为 一 类 型 重 “++”&#x2F;“–” 的 前 置 本 时 不需要 参数<br>当 为 一 个 类 型 重 “++”&#x2F;“–” 的 后 置 本 时 ， 需 要 一 int 类 型 的 参数 作为标志 〈 即 哑 元 非 具名 参数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Integer</span>(<span class="type">long</span> data) : <span class="built_in">m_data</span>(data)&#123; &#125;</span><br><span class="line">Integer&amp; <span class="keyword">operator</span>++() &#123; /W 前 置 版 : 返回 引用</span><br><span class="line">cout&lt;&lt; “Integer::<span class="keyword">operator</span>++() called!” &lt;&lt; end];</span><br><span class="line">m_datat++ ;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">Integer <span class="keyword">operator</span>++(<span class="type">int</span>) &#123; <span class="comment">// 后 置 版 : 返回 对 象 的</span></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;Integer::operator++(int) called!&quot;</span> &lt;&lt; end];</span><br><span class="line">Integer temp = *<span class="keyword">this</span> ;</span><br><span class="line">m_data++ ; <span class="comment">// BR: ++(*this) ;</span></span><br><span class="line"><span class="keyword">return</span> temp; / 返回 <span class="keyword">this</span> 对 象 的 旧 值</span><br><span class="line">&#125;</span><br><span class="line">/ 其 他 成 员</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">long</span> m_data; / 对 <span class="type">long</span> 的 封装</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Integer x = <span class="number">1</span>; <span class="comment">// call Integer(long)</span></span><br><span class="line"><span class="number">+4</span>x ; <span class="comment">// call operator++Q)</span></span><br><span class="line">xtt+ <span class="number">3</span> <span class="comment">// call operator++(int)</span></span><br><span class="line">&#125;</span><br><span class="line">输出 结果 :</span><br><span class="line">Integer::<span class="keyword">operator</span>++() called!</span><br><span class="line">Integer::operatort++(<span class="type">int</span>) called!</span><br></pre></td></tr></table></figure>

<h3 id="内联"><a href="#内联" class="headerlink" title="内联"></a>内联</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(intx, <span class="type">int</span> y)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">Foo</span><span class="params">(intx, <span class="type">int</span> y)</span> <span class="comment">// inline 与 函数 定义 体 放 在 一</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">定义 在类 声明 之 中 的 员 函 数 将 自动地 成 内 联 函数</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; ... &#125; / 自动 地 成 内 联 函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型转换函数"><a href="#类型转换函数" class="headerlink" title="类型转换函数"></a>类型转换函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">MyString</span>(<span class="type">size_t</span> size, <span class="type">char</span> c =</span><br><span class="line">fhe.</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">char</span> *m_data;</span><br><span class="line">Point pl = <span class="number">10.5</span>;</span><br><span class="line">pi = <span class="number">20.5</span>;</span><br><span class="line">\<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyString strName = <span class="number">20</span>;</span><br><span class="line">strName = <span class="number">40</span>; / 莫名 其妙 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(MyString str)</span></span>;</span><br><span class="line"><span class="built_in">f</span>(<span class="number">100</span>);</span><br><span class="line">如果 当 前程序 中 没有 其 他 重 载 恕 函数， 编译 器 就 将 它暗 中 转换 :</span><br><span class="line"><span class="built_in">f</span>(<span class="built_in">MyString</span>(<span class="number">100</span>));</span><br></pre></td></tr></table></figure>

<p>当你的类定义中出现类似的情况时，可以在构造函数前面添加关键字 explicit<br>将其 声明 为 显 式 的 意 为要 求 用 户 必须 显 式 地 调用 该 构造 函数 来 初始 对 象<br>以 明确 表明 他 的 意图 </p>
<p><img src="/../img/C++/Pasted%20image%2020230602141650.png"></p>
<ol>
<li><p><code>static_cast&lt;desttype&gt;(src_obj)</code>， 作 用 相当 于 C 风格 的强制 转换 ,<br>但 是 在 多 重继承 的情况 ， 它 会 正确 地 调整 指针 的 值<br>而 C 风格 的强制 转换 则 不 会调整<br>它 可 以 遍历继承 树 来 确定 src_obj 与 dest_type 的 关系 ,<br>但 是 只 在 编译 时进行 〈 此 所 谓 静 )，<br>如 果使 用 它 来 downcast 操作 ， 则 会 存在 隐患 。</p>
</li>
<li><p><code>const_cast&lt;dest_type&gt;(src_obj)</code>， 用 于去除 一 个对 象 const&#x2F;volatile 属性 </p>
</li>
<li><p><code>reinterpret_cast&lt;desttype&gt;(src_obj)</code>, 我 们 可 以借助 它 把 一 个 整数 转换 成 一地 址 或 者 在任何 两 种 类 型 的 指针 之闻 转 。 使 用 该 运算 符 的 结果 很 危险 ，请你 要 轻易使 </p>
</li>
<li><p><code>dynamic_cast&lt;dest_type&gt;(src_obj)</code>， 在 运行 时 台历 继承 〈 类 层次 结构 ) 来确定 src_obj 与 desttype 的 关系</p>
</li>
</ol>
<p>在 C++ 程序 中 尽量 不 要 再 使 C 风格 的 类 型 转换<br>除 非 源 对 和 目标 类型 都 <strong>基本 类 型</strong> 的对 象 指针 ， 否 则 很 不 安全 。<br>C++ 的 类 型 转换 运算 符在 需要 的 时 候 会 进行<strong>指针 调整</strong> 因 此 结果 比较 安全 。</p>
<h3 id="const成员函数"><a href="#const成员函数" class="headerlink" title="const成员函数"></a>const成员函数</h3><p>任何 不 会修改 数据 员 的 员 函 数 都应 该 声明 为 const 类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Push</span><span class="params">(<span class="type">int</span> elem)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Pop</span><span class="params">(<span class="type">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetCount</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span>; <span class="comment">// const A AB</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line"><span class="type">int</span> m_data[ <span class="number">100</span>&#125;;</span><br><span class="line"><span class="function">I</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::GetCount</span><span class="params">(<span class="type">void</span>)</span> <span class="type">const</span></span></span><br><span class="line"><span class="function">t</span></span><br><span class="line"><span class="function">++m_num</span>; / 编译 错误 企 图修改 数据 成 <span class="function">m_num</span></span><br><span class="line"><span class="function"><span class="title">Pop</span><span class="params">()</span></span>; / 编译 错误 企 图 调用非 <span class="type">const</span> 成 员 函</span><br><span class="line"><span class="keyword">return</span> m_num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Static KA BRA RANA const 的 这 是 因为 static 成 员 函 数 只 是 全 局 函 数 的 一 个 形式 上 的 封装 而 全 局 函数 不 存在 const 一 ; 何况 static 成 员 函数 不 能 访问 类 的 非 静态 成 (没有 this 指针 )， 修 改 非 静态 数据 员 又 从 何说 起 ? </p>
<h2 id="10-C-异常处理-和-RTTI"><a href="#10-C-异常处理-和-RTTI" class="headerlink" title="10. C++异常处理 和 RTTI"></a>10. C++异常处理 和 RTTI</h2><p>何 一 种 类 型 可 以 当做 异常 类 型 因 此 任何 个 对 象 可 以 当做异常 对 ，<br>包括 基本 数据 类 型 的 变量 常量、 任何 类 型 的 指针 、 引 用 、 结 构 等 甚 至 空 结构类 的 对象<br>这 是 因为 异常 仅仅通过 类 型 而不是 通过 值 来 匹配 的 否 则 就 又 退回 到<br>了 传统 的 错误 处 理 技术 上 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> x = <span class="number">100</span>, y = <span class="number">20.5</span>;</span><br><span class="line"><span class="type">int</span> x[<span class="number">20</span>] = &#123; <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">Devide</span>(x, y) &lt;&lt; endl; / 可 能 抛 出 异常 <span class="function">DevidedByZero</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(index &gt;= <span class="number">20</span>)</span> <span class="keyword">throw</span> <span class="title">OverFlow</span><span class="params">()</span></span>; <span class="number">1</span>) iE EGLF <span class="number">4</span> <span class="function">Bil <span class="keyword">try</span> RA</span></span><br><span class="line"><span class="function"><span class="title">if</span><span class="params">(index &lt; <span class="number">0</span>)</span> <span class="keyword">throw</span> <span class="title">UnderFlow</span><span class="params">()</span></span>; / 抛 出 点 位 于 当前 <span class="keyword">try</span> 块 内</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">const</span> DevidedByZero&amp; ex) &#123;</span><br><span class="line">cerr &lt;&lt; ex.<span class="built_in">description</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">const</span> OverFlow&amp;) &#123; / 省 略 参数 名 称</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot;Overflow occurred!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">const</span> UnderFlow&amp;) &#123;</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot;Underflow occurred!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...) &#123; / 捕获 他所 有 可 能 的 异常</span><br><span class="line">cerr &lt;&lt; <span class="string">&quot;Unexpected exception occurred!&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由 于 异常 处理 机 制 采用 类 型 匹配 而 不 是 值 判 断 因 此 catch 块 参数<br>可 以 没有 参数 名 称 只 需要 参数 类 型 除 非 确实 要 使 用 那个 异常 对 </p>
<p>虽然 异常 对 象 上 去 局 部 对 象 但 是 并 非 创建 在 函数 堆栈 上 ，<br>而 是创建 在 专用 的 <strong>异常 堆栈</strong> 上 ， 因 此 它 才 可 以 跨接 多 个 函数 而 传递 上 层 ，<br>否则 在 堆栈 清 退 的 过 程 中 就 会 销毁 .<br><strong>不 要</strong> 企图 把 <strong>局 部 对 象 地 址</strong> 作为异常 对 象 <strong>抛 出</strong><br>因 为 局 部 对 象 会 蜡 常 出 后 函数 堆栈 清 退 的 过 程 中销毁 </p>
<p><img src="/../img/C++/Pasted%20image%2020230602161511.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Devide</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> <span class="title">throw</span><span class="params">(DevidedByZero)</span></span>;  <span class="comment">// 只 可 能 出 一种 异常</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">func</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *)</span> <span class="title">throw</span><span class="params">(T1, T2,T3)</span></span>; <span class="comment">// 可 能 抛 3 种 异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span> <span class="title">throw</span><span class="params">()</span></span>; <span class="comment">// (3) 不抛出任何异常</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">k</span><span class="params">()</span></span>;  <span class="comment">// 可 能 出 任何 异常 也 可能 不 出 任何异常</span></span><br></pre></td></tr></table></figure>

<p>所 有从try 到 throw 语句 之间 构造 起 来 的 局 部对 象 的析 构 函数将被 自动 调用<br>(以 与构造相 反 的 顺序 )， 然 后 清 退 堆栈 (就像 函 数 正 退出 那样 )。</p>
<p>如 果 一 个 函数 在 运行 时 抛 了 异常<br>于 是 异常 处 理 机制 调用 局 部 对 象 析构 函数 〈 清退 扒 )，<br>而如 果 此 时 某 一 析 构 函 数 恰 也 要 抛 出一 个 异常 那 这个 异常 由 谁 处 理 ?<br>没有 办 法 异 常 处 理 机 制 只 好 调用;terminate0。</p>
<p>如 果 你 真 的 不 得 不 从 析 构 函数 内 抛 出 异常 的 话 你应 该<br>首先 检查一 下 看 当前 是 有 一 个 未 捕获 的 异常 要 被 处 理 如 果 没有 ，<br>说 明 该 析 构 函数 的用 并 非 由 一 外 部 异常 引起 而 是 正常 的 销毁<br>于是 你 可 以 出 一 个 异常 上 层:程序 来 捕获</p>
<p>一 些 编译 器可 以 设 异 常 处 理 支持 开关 ， 当 关闭 异常 理 支持 后 附加 的 数据 结构 查 找表 、 额 外 的 代码 都 不 生成</p>
<p>要 合理 安排 异常 处 理 的 层次 : 一 要 把 派生 类 的 异常 .<br>获 放 在 基 类 异常 捕获 的 前 面 否 则派生 类 异常 匹配 永远 也 不 会执行到 </p>
<p>如 果实 在 无 法判断 到 底 有什么 异常 抛 出 那 就 使 “一 打 尽”的 策<br>略 了 : catch(void*) 和 catch(…)。 但 要 记 住 catch(void*) 和 catch(..)<br>必须 放 在 异常 组 合 的 最 后 面 并 且 cateh(void*) 放 在 catch(…) 的 前 </p>
<p><img src="/../img/C++/Pasted%20image%2020230602165212.png"></p>
<p>为 了 支持 dynamic_cast&lt;&gt; 运 算 符 ，RTTI 机 制 必须 维 护 一 棵 继承 ，<br>即 base class table 模型 ( 或 类 似 的 索引 表格 )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">DeviceControllor::ControlThem</span><span class="params">(HomeElectricDevice&amp; device)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">Command cmd = <span class="built_in">GetCommand</span>();</span><br><span class="line"><span class="keyword">switch</span>(cmd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> OPEN:</span><br><span class="line"><span class="keyword">case</span> PLAY VCD:</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Television tv = <span class="built_in">dynamic_cast</span>&lt;Television &amp;&gt;(device);</span><br><span class="line">tv.PlayVCDQ; <span class="comment">// PRCERESE ADEE Television WRAEAIE BCH!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(std::bad_cast&amp;) &#123;</span><br><span class="line"><span class="built_in">MsgBox</span>(<span class="string">&quot;This device cannot play VCD!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<h2 id="11-16章-内存管理"><a href="#11-16章-内存管理" class="headerlink" title="11. 16章 内存管理"></a>11. 16章 内存管理</h2><p> 野 指 针<br> free 完 delete完 置NULL</p>
<p>对 于 内 部 数据 类 (如 ADT&#x2F;UDT) 的 对 象 而 言 光 用 mallocO&#x2F;free0 无 法 满足 动态 对 象 的 要 求<br>对象 在 创建 的 同时 要 <strong>自动 调用 构造 函数</strong> 对象在 销毁 的 时 候要 <strong>自动 调用 析 构 函数</strong><br>由 mallocO&#x2F;free0 是 库 函 数而 不 是 运算 符 不 在 编译 器 控制 权限<br>不 能 把调用 构造函数 和 析 构 函数 的任务强加 给 它们 。<br>因 此 C++ 语言 需要 一能 完成 动态 内 存 分 和 初始 化 工作 的运算 new,<br>以 及一 个 能 够 完成清 理与 释放 内存工作 的运算符 delete。</p>
<p>plain new、nothrow new 及 placement new.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 的 使 用 方 法 见 示 例 <span class="number">16</span><span class="number">-10</span>。</span><br><span class="line"><span class="comment">// plain new 定义</span></span><br><span class="line"><span class="type">void</span> * <span class="keyword">operator</span> <span class="built_in">new</span>(std::<span class="type">size_t</span>) <span class="built_in">throw</span>(std::bad_alloc);</span><br><span class="line">| <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Char * <span class="title">GetMemory</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span></span></span><br><span class="line"><span class="function">《</span></span><br><span class="line"><span class="function"><span class="type">char</span> *p </span>= <span class="keyword">new</span> <span class="type">char</span>[size];</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">GetMemory</span>(<span class="number">1000000</span>); / 可 能 抛 出 std::bad_alloc 异 常</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(<span class="type">const</span> std::bad_alloc&amp; ex) &#123;</span><br><span class="line">cout &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// nothrow new 定义</span></span><br><span class="line"><span class="function"><span class="type">void</span> * <span class="keyword">operator</span> <span class="title">new</span><span class="params">(std::<span class="type">size_t</span>, <span class="type">const</span> std::<span class="type">nothrow_t</span>&amp;)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span> *)</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Void <span class="title">func</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">unsigned</span> <span class="type">char</span>[length];</span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>) cout &lt;&lt; <span class="string">&quot;allocate failed!&quot;</span>&lt;&lt; endl;</span><br><span class="line">Hf...</span><br><span class="line"><span class="keyword">delete</span> []p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>placement new 不 用 担心 内 存 分配 失败 因 为 它 根本 就 不 会 分配 内 存<br>它所 做 的 唯一 一件 事情 就 是 调用 对 象 的 构造 函数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">include &lt;<span class="keyword">new</span>&gt;</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="built_in">main</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="number">4</span>]; <span class="comment">// nothrow new</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;allocate failed!&quot;</span>&lt;&lt; endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">仁 …</span><br><span class="line"><span class="type">long</span> *q = <span class="built_in">new</span>(p) <span class="built_in">long</span>(<span class="number">1000</span>); <span class="comment">// placement new</span></span><br><span class="line">Ie.</span><br><span class="line"><span class="keyword">delete</span> [ip; / 释放 内 存</span><br></pre></td></tr></table></figure>

<p>Placementnew 的 主 要 用 途 就 是 : 反 复 使 用 一 块 较 大 的 动 态 分 配 成 功 的 内 存 来 构 造 不 同 类 型 的 对 象 或 者 它 们 的 数 组 。 比 如 , 可 以 先 申 请 一 个 尸 够 大 的 字 符 数 组 , 然 后 当 需 要 时 在 它 上 面 构 造 不 同 类 型 对 象 或 其 数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> “ 使 用 placement <span class="keyword">new</span> 构 造 起 来 的 对 象 或 其 数 组 , 要 显 式 地 调 用 它 们 的 析 构 函 数 来 销 毁 ( 析 构 函 数 并 不 释 放 对 象 的 内 存 , 千 万 不 要 使 用 <span class="keyword">delete</span>。 这 是 因 为 ,placement <span class="keyword">new</span> 构 造 起 来 的 对 象 或 其 数 组 的 大 小 并 不 一 定 等 于 原 来 分 配 的 内 存 大 小 , 因 此 使 用 <span class="keyword">delete</span> 会 造 成 内 存 泄 漪 , 或 者 在 之 后 释 放 内 存 时 出 现 运 行 时 错 误 。 见 示 例 <span class="number">16</span><span class="number">-14</span> ( 假 设 ADT 表 示 任 意 复 合 数 据 类 # ).</span><br><span class="line">示 例 <span class="number">16</span><span class="number">-14</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostrem&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="built_in">main</span>(<span class="type">void</span>)</span><br><span class="line">《</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std:</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">new</span>(nothrow) <span class="type">char</span>[<span class="built_in">sizeof</span>(ADT) + <span class="number">2</span>]:; / nothrow <span class="keyword">new</span></span><br><span class="line"><span class="keyword">if</span>(p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;allocate failed!&quot;</span>&lt;&lt; endl;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">ADT *q = <span class="built_in">new</span>(p) ADT; <span class="comment">// placement new: 不 必 担 心 失 败</span></span><br><span class="line">历 .</span><br><span class="line"><span class="comment">// deleteq; / 错 误 ! 不 能 在 此 处 调 用 deleteq;</span></span><br><span class="line">q-&gt;ADT::-ADTO; / 显 示 调 用 析 构 函 数</span><br><span class="line"><span class="keyword">delete</span> []p; / 再 释 放 内 存</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">void</span> *) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h2 id="12-用对象模拟指针"><a href="#12-用对象模拟指针" class="headerlink" title="12. 用对象模拟指针"></a>12. 用对象模拟指针</h2><p> 些 软 件 库 使 用 这 种 技 术 来 封 装 指 针 , 基 本 上 分 为 如 下 几 种 情 况 。</p>
<ol>
<li>采 用 拷 贝 方 式 。 这 样 的 指 针 对 象 既 负 责 创 建 数 据 对 象 , 又 负 责 删 除 数 据 对<br>象 ,STL 容 器 对 象 采 用 的 就 是 这 种 方 式 。显 然 , 采 用 这 种 方 式 的 指 针 对 象<br>责任 最 清 晰 。</li>
<li>采 用 完 全 接 管 方 式 , 指 针 对 象 不 负 责 创 建 数 据 对 象 , 但是负责删除数据对<br>象 , 即 不 仅 接 管 了 源 指 针 指 向 的 对 象 , 而 且 接 管 了 它 的 所 有 权 。auto ptr&lt;&gt;<br>类 就 是 采 用 这 种 方 式 实 现 的 。</li>
<li>采 用 接 管 方 式 , 是 既 不 负 责 创 建 数 据 对 象 也 不 负 责 删 除 数 据 对 象 , 这 就 是<br>我 们 的 模 拟 指 针 。STL 中 的 迭 代 器 (iterator》 采 用 的 就 是 这 种 方 式 , 它们 在<br>行 为 上 与 底 层 的 指 针 变 量 没 有 什 么 太 大 区 别 , 只 是 在 使 用 方 式 上 统 一 了 起<br>来 。</li>
<li>完 全 接 管 方 式 和 深 拷 贝 方 式 结 合 。 一 般 情 况 是 : 拷 贝 构 造 和 拷 贝 赋 值 采 用<br>深拷 贝 方 式 , 而 指 针 构 造 和 指 针 赋 值 采 用 接 管 方 式 。 这 种 方 式 最 容 易 产 生<br>运 行 时 内 存 访 问 冲 突 和 内 存 泄 漏 问 题 , 因 此 建 议 不 要 使 用 。</li>
</ol>
<h3 id="泛型指针auto-ptr"><a href="#泛型指针auto-ptr" class="headerlink" title="泛型指针auto_ptr"></a>泛型指针auto_ptr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_ptr</span> 【</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">autp_ptr</span><span class="params">(T *p = <span class="number">0</span>)</span> : m_ptr(p)&#123;</span>&#125;</span><br><span class="line"><span class="built_in">auto_ptr</span>(<span class="type">const</span> auto_ptr&lt;T&gt;&amp; copy) : <span class="built_in">m_ptr</span>(copy.<span class="built_in">release</span>())&#123;&#125;</span><br><span class="line">auto_ptr&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="type">const</span> auto_ptr&lt;T&gt;&amp; assign) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;assign) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_ptr;</span><br><span class="line">m_ptr = assign.<span class="built_in">release</span>(); H 释 放 并 移 交 拥 有 权</span><br><span class="line">多</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">hs</span><br><span class="line">~<span class="built_in">auto_ptr</span>()&#123; <span class="keyword">delete</span> m_ptr; &#125; / 负 责 释 放 存 储</span><br><span class="line">T&amp; <span class="keyword">operator</span>*()&#123; <span class="keyword">return</span>.*m_p; &#125; / 重 载 “*<span class="number">2</span></span><br><span class="line">T* <span class="keyword">operator</span>-&gt;()&#123; <span class="keyword">return</span> m_p; &#125; / 重 载 “-&gt;“</span><br><span class="line"><span class="function">T* <span class="title">release</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">T *temp = m_ptr;</span><br><span class="line">(<span class="keyword">const_cast</span>&lt;auto_ptr&lt;T&gt; *&gt;(<span class="keyword">this</span>))-&gt;m_ptr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">工 * m_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使 用 auto_ptr&lt;&gt; 这 样 的 灵 巧 指 针 有 一 个 好 处 : 当 函 数 即 将 退 出 或 有 异 常 抛 出 的 时 候 ,<br>不 再 需 要 我 们 显 式 地 用 delete 来 删 除 每 一 个 动 态 创 建 起 来 的 对 象</p>
<h3 id="带引用技术的智能指针"><a href="#带引用技术的智能指针" class="headerlink" title="带引用技术的智能指针"></a>带引用技术的智能指针</h3><p>带 有 引 用 计 数 功 能 的 智 能 指 针 兼 有, 智 通 指 针 共 享 实 值 对 象 和 auto ptr 自 动 释 放 实 值 对 象 的 双 重 功 能</p>
<p><img src="/../img/C++/Pasted%20image%2020230603113212.png"></p>
<p>“auto_ptr不 满 足 STL 标 准 容 器 对 元 素 的 最 基 本 要 求<br>,auto ptr 对 象 和 它 的 拷 贝 不 会 共 享 实 值 | 对 象 , 任 何 两 个 auto_ptr 也 不 应 该 共 享 同 一 个 实 值 对 象 。 这 就 是 说 ,auto ptr 对 象 和 | 它 的 拷 贝 并 不 相 同 。 然 而 根 据 STL 容 器 “ 值 “ 语 义 的 要 求 , 可 拷 贝 构 造 意 味 着 一 个 || 对 象 必 须 和 它 的 拷 贝 相 同 ( 标 准 中 的 正 式 定 义 比 这 稍 复 杂 一 些 。 同 样 , 可 赋 值 意 味 耒萱把 个 对 象 赋 值 给 另 一 个 同 类 型 对 象 将 产 生 两 个 相 同 的 对 象 。 显 然 ,auto ptr 不 能 LK 要 求 , 它 与 上 面 的 结 论 矛 盾</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">16</span><span class="number">-23</span></span><br><span class="line">std::list&lt; std::auto_ptr&lt;<span class="type">int</span>&gt; &gt; la; / auto_ptr 列 表</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line">la.<span class="built_in">push_back</span>(p1); <span class="comment">// compiling-error!</span></span><br><span class="line">la.<span class="built_in">push_back</span>(p2); <span class="comment">// compiling-error!</span></span><br><span class="line">la.<span class="built_in">push_back</span>(p3); <span class="comment">// compiling-error!</span></span><br><span class="line">set&lt;auto_ptr&lt;<span class="type">int</span>&gt; &gt; sa; / auto_ptr RA: 假 设 为 <span class="keyword">auto</span> ptr 定 义 了 <span class="keyword">operator</span>&lt;</span><br><span class="line">sa.<span class="built_in">insert</span>(p1); <span class="comment">// compiling-error!</span></span><br><span class="line">sa.<span class="built_in">insert</span>(p2); <span class="comment">// compiling-error!</span></span><br><span class="line">sa.<span class="built_in">insert</span>(p3); <span class="comment">// compiling-error!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> list&lt;T&gt;::<span class="built_in">push_back</span>(<span class="type">const</span> T&amp; x)</span><br><span class="line">&#123;</span><br><span class="line">T *p = <span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T)); / 分 配 内 存空 间</span><br><span class="line"><span class="keyword">new</span> (p) <span class="built_in">T</span>(x); <span class="comment">// placement new, 调 用 T 的 copy constructor</span></span><br><span class="line">------ / 将 p 交 给 容 器 管 理 , 调 整 容 器 大 小</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> std::vector&lt;std::auto_ptr&lt;<span class="type">int</span>&gt; &gt; IntPtrVector;</span><br><span class="line">IntPtrVector va;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">2</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">3</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">4</span>))</span></span>;</span><br><span class="line"><span class="function">std::auto_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">5</span>))</span></span>;</span><br><span class="line">va.<span class="built_in">push_back</span>(p1);</span><br><span class="line">va.<span class="built_in">push_back</span>(p2);</span><br><span class="line">va.<span class="built_in">push_back</span>(p3);</span><br><span class="line">va.<span class="built_in">push_back</span>(p4);</span><br><span class="line">va.<span class="built_in">push_back</span>(p5);</span><br><span class="line"><span class="number">1</span> ( 注意 : 以 下 操 作 并 非 放 在 一 起 进 行 , 仅 是 示 范 )</span><br><span class="line">IntPtrVector vb = va; va 丧 失 对 所 有 实 值 对 象 的 拥 有 权 ,</span><br><span class="line">/ 元 素 成 为 <span class="literal">NULL</span> 指 针</span><br><span class="line">vb.<span class="built_in">resize</span>(<span class="number">10</span>); / 新 增 的 元 素 都 为 <span class="literal">NULL</span>指 针</span><br><span class="line">std::<span class="built_in">sort</span>(vb.<span class="built_in">begin</span>(),</span><br><span class="line">vb.end0);</span><br><span class="line"></span><br><span class="line">std::auto_ptr&lt;<span class="type">int</span>&gt;</span><br><span class="line">t</span><br><span class="line">=</span><br><span class="line">vb.<span class="built_in">front</span>();</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">改</span><br><span class="line">变</span><br><span class="line">了</span><br><span class="line">容</span><br><span class="line">器</span><br><span class="line">元</span><br><span class="line">素</span><br><span class="line">std::auto_ptr&lt;<span class="type">int</span>&gt; r = vb[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">std::list&lt;std::auto_ptr&lt;<span class="type">int</span>&gt; &gt; la;</span><br><span class="line">std::<span class="built_in">copy</span>(vb.<span class="built_in">begin</span>(), vb.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(la));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>Scott Meyers 在 《Effective STL) Item 8 中 详 细 地 分 析 了 对 auto ptr 容 器 进 行 排 序<br>| 时 可 能 会 导 致 的 问 题 。 但 是 在 MS VC++ 环 境 下 经 测 试 , 并 没 有 出 现 书 中 所 描 述 的 悲<br>| 惨 结 局 , 而 是 结 果 正 确 。 主 要 原 因 在 于 C++ 标 准 并 没 有 要 求 std::sort等 泛 型 算 法 的 实<br>现 必 须 采 用 某 一 种 方 法 , 而 是 只 规 定 了 它 们 的 接 口 、 功 能 和 应 该 达 到 的 性 能 要 求 ( 容<br>器也 是 如 此 )。 因 此 , 不 同 的 STL 实 现 可 能 采 取 不 同 的 方 法 , 比 如 有 的 sort 实 现 采 用<br>快速 排 序 法 , 而 有 的 采 用 插 入 式 排 序 法 等 。 不 同 的 排 序 方 法 在 遮遇 auto_ptr这 样 的 容<br>| 器 时 可 能 就 会 产 生 不 同 的 结 果 </p>
<p>可 见 , 督 能 指 针 “ 可 以 “ 还 是 “ 不 可 以 “ 作 为 容 器 的 元 素 并 非 绝 对 的 , 不 仅 与 ,STL 的 实 现 有 关 , 而 且 与 STL 宪 器 的 需 求 和 安 全 性 及 容 器 的 语 义 有 关</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">由于 auto_ptr 是 对 象 化 的 智 能 指 针 , 具 有 自 动 释 放 资 源 的 能 力 , 因 此 它 真 正 有 价</span><br><span class="line">, 值 的 用 途 是 在 发 生 异 常 时 避 免 资 源 泄 濡 。 比 如 , 如 果 不 使 用 <span class="keyword">auto</span> ptr, 则 下 列 代 码 在</span><br><span class="line">发 生 异 常 的 情 况 下 不 得 不 多 次 手 工 释 放 资 源 ( 见 示 例 <span class="number">16</span><span class="number">-28</span>)。</span><br><span class="line">示 例 <span class="number">16</span><span class="number">-28</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123; ... &#125;<span class="number">5</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">《</span></span><br><span class="line"><span class="function">A *pA</span>= 一 <span class="keyword">new</span> A;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">wee <span class="comment">// using *pA</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">catch</span>(...) &#123;</span><br><span class="line"><span class="keyword">delete</span> pA; MBERTAIN BE LAE IK</span><br><span class="line"><span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> pA; / 函 数 退 出 时 还 要 显 式 释 放</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">现 在 有 了 <span class="keyword">auto</span> ptr, 我 们 就 可 以 这 么 做 ( 见 示 例 <span class="number">16</span><span class="number">-29</span>).</span><br><span class="line">示 例 <span class="number">16</span><span class="number">-29</span> |</span><br><span class="line">classA&#123; ... &#125;<span class="number">5</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">auto_ptr&lt;A&gt; <span class="title">pA</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line"><span class="comment">// using *pA</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果 想 防 止 无 意 中 修 改 <span class="keyword">auto</span> ptr 对 实 值 对 象 的 拥 有 权 , 可以 使 用 <span class="type">const</span> auto_ptr,</span><br><span class="line">! 这 样 的 auto_ptr 只 能 使 用 引 用 或 指 针 传 递 , 不 能 使 用 值 传 递 , 也 不 能 赋 值 和 拷 贝 构 造 </span><br><span class="line"></span><br><span class="line">classA&#123; ... &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function"><span class="type">const</span> auto_ptr&lt;A&gt; <span class="title">pl</span><span class="params">(<span class="keyword">new</span> A)</span></span>;</span><br><span class="line">we <span class="comment">// using *pA</span></span><br><span class="line"><span class="function">auto_ptr&lt;A&gt; <span class="title">p2</span><span class="params">(p1)</span></span>; <span class="comment">// error!</span></span><br><span class="line">auto_ptr&lt;A&gt; p3;</span><br><span class="line">p3=pl; <span class="comment">// error!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// smart pointer stl</span></span><br><span class="line"></span><br><span class="line">示 例 <span class="number">16</span><span class="number">-31</span></span><br><span class="line">) <span class="keyword">typedef</span> SmartPtr&lt;Shape&gt; ShapeSmartPtr;</span><br><span class="line"><span class="keyword">typedef</span> std::list&lt;ShapeSmartPt&gt; ShapeList;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Point&amp; left, <span class="type">const</span> Point&amp; right)</span><br><span class="line">&#123; <span class="keyword">return</span> ((left.m_x &lt; right.m_x) &amp;&amp; (left.m_y &lt;right.m_y); &#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>—=(<span class="type">const</span> Point&amp; left, <span class="type">const</span> Point&amp; right)</span><br><span class="line">&#123; <span class="built_in">return</span> ((left.m_x == right.m_x) &amp;&amp; (left.m_y == right.m_y); )</span><br><span class="line">| <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> ShapeSmartPtr left, <span class="type">const</span> ShapeSmartPtr right)</span><br><span class="line">&#123; <span class="built_in">return</span> (left-&gt;GetOriginQ &lt; right-&gt;<span class="built_in">GetOrigin</span>()); 》</span><br><span class="line"><span class="number">1</span> <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> ShapeSmartPtr left, <span class="type">const</span> ShapeSmartPtr right)</span><br><span class="line">&#123; <span class="built_in">return</span> (left-&gt;GetOriginQ == right-&gt;<span class="built_in">GetOrigin</span>()); &#125;</span><br><span class="line">ShapeList shapes;</span><br><span class="line">ShapeSmartPtr <span class="built_in">p</span>(<span class="keyword">new</span> <span class="built_in">Shape</span>(<span class="built_in">Point</span>(<span class="number">1</span>, <span class="number">1</span>)));</span><br><span class="line">ShapeSmartPtr <span class="built_in">q</span>(<span class="keyword">new</span> <span class="built_in">Circle</span>(<span class="built_in">Point</span>(<span class="number">2</span>, <span class="number">2</span>), <span class="number">5</span>));</span><br><span class="line">ShapeSmartPtr <span class="built_in">r</span>(<span class="keyword">new</span> <span class="built_in">Rectangle</span>(<span class="built_in">Point</span>(<span class="number">3</span>, <span class="number">3</span>), <span class="built_in">Point</span>(<span class="number">4</span>, <span class="number">4</span>)));</span><br><span class="line">shapes.<span class="built_in">push_back</span>(p);</span><br><span class="line">shapes.<span class="built_in">push_back</span>(q);</span><br><span class="line">shapes.<span class="built_in">push_back</span>(r);</span><br><span class="line">|</span><br><span class="line">std::<span class="built_in">sort</span>(shapes.<span class="built_in">begin</span>(), shapes.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(ShapeList::const_iterator first=shapes.<span class="built_in">begin</span>();first !=shapes.<span class="built_in">end</span>();++first)</span><br><span class="line">(*first)-&gt;DrawQ);</span><br></pre></td></tr></table></figure>


<h2 id="13-17章-STL"><a href="#13-17章-STL" class="headerlink" title="13. 17章 STL"></a>13. 17章 STL</h2><p>STL 主 要 包 括 下 面 这 些 组 件<br>IO流、 string 类 、 容 器 类(Container)、 迭 代 器 熹 (Iterator)、 存 储 分 配 器 (Allocator)、<br>适 配 器 (Adapter)、 函 数 对 象 (Functor)、 泛 | 型 算 法 (Algorithm)、<br>数 值 运 算 、 国 际 化 和 本 地 化 支 持 , 以 及 标 准 异 常 类 等 。</p>
<p>C++标 准 规 定 , STL 的 头 文 件 都 不 使 用 扩 展名<br>过 去 的 C 程 序 库 头 文 件 在, 并 入 C++ 标 准 库 时 也 都 去 掉 了 .h 扩 展 名 , 同 时 增 加 了 前 缀 “c“。<br>STL 组 件 都 被 纳 入 了 名 字 空 间 std::, 所 以 在 使 用 其 中 的 组 件 之 前 需 使 用 using 声 明 或 using 指 令 ,<br>或 者 也 可 以 在 每 一 处 都 直 接 使 用 完 全 限 定 名 std::。 </p>
<p><img src="/../img/C++/Pasted%20image%2020230603051215.png"></p>
<h3 id="STL头文件分布"><a href="#STL头文件分布" class="headerlink" title="STL头文件分布"></a>STL头文件分布</h3><h3 id="容器类"><a href="#容器类" class="headerlink" title="容器类"></a>容器类</h3><p><img src="/../img/C++/Pasted%20image%2020230603050007.png"></p>
<pre><code>关 联 式 容 器 multimap 和 multiset 也 都 分 别 定 义 在 &lt;map&gt; 和 &lt;set&gt; 中 ,
hash_multimap 和 hash_multiset 定 义 在 &lt;hash_map&gt;和&lt;hash_set&gt;中
</code></pre>
<h3 id="泛型算法"><a href="#泛型算法" class="headerlink" title="泛型算法"></a>泛型算法</h3><pre><code>像 C++VC 数 组 、 字 符 留 、UO 流 等 特 殊 的 容 器 也 可 以 使 用 标 些 泛 型 算 法 一 一
它 们 定 义 在 头 文 件 &lt;algorithm&gt;和 &lt;utility&gt; 中 
</code></pre>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><pre><code>如 输 入 / 输 出 迭 代 器 、 插 入 迭 代 器 、 反 向 迭 代 器 等 都 是 迢 代 器 适 配 器 , 
定 义 在 头 文 件 &lt;iterator&gt;中 
</code></pre>
<h3 id="数学运算库"><a href="#数学运算库" class="headerlink" title="数学运算库"></a>数学运算库</h3><p><img src="/../img/C++/Pasted%20image%2020230603050515.png"></p>
<h3 id="通用工具"><a href="#通用工具" class="headerlink" title="通用工具"></a>通用工具</h3><p><img src="/../img/C++/Pasted%20image%2020230603050604.png"></p>
<h3 id="其他头文件"><a href="#其他头文件" class="headerlink" title="其他头文件"></a>其他头文件</h3><pre><code>&lt;typeinfo&gt; 、&lt;stdexcept&gt;、&lt;strsteam&gt;、&lt;string&gt;、&lt;istream&gt;、
&lt;ostream&gt;、&lt;iostream&gt;、&lt;new&gt;、&lt;iomanip&gt;、&lt;fstream&gt; 
</code></pre>
<h3 id="容器设计原理"><a href="#容器设计原理" class="headerlink" title="容器设计原理"></a>容器设计原理</h3><p>容 器 在 概 念 上 是 一 种 可 以 动 态 增 大 和 减 小 的 模 型<br>其<strong>元 素 对 象</strong> 在 实 现 上 不 可 能 直 接 保 存 在 容 器 对 象 里 面<br>应 该 保 存 在 自 由 内 存 (Free Memory) 或 堆 , CHeap)》 上</p>
<h3 id="内存映像"><a href="#内存映像" class="headerlink" title="内存映像"></a>内存映像</h3><p><img src="/../img/C++/Pasted%20image%2020230603051108.png"></p>
<p><img src="/../img/C++/Pasted%20image%2020230603052000.png"></p>
<h3 id="存储方式-访问方式"><a href="#存储方式-访问方式" class="headerlink" title="存储方式 访问方式"></a>存储方式 访问方式</h3><p>向 量 Cvector) 和 链 表 (linked list) 是 两 种 最 基 本 的 动 态 结 构 ,<br>也是 STL 中 两 种 最 基 本 的 容 器 ,<br>分 别 对 应 动 态 数 组 和 链 接 表 结 构<br>同 时 它 们 分 别 代 表 了 内 存 中 同 类型 批 量 数 据 存 放 的 两 种 基 本 方 式 , 连 续 存 储 和 随 机 存 储 ( 不 连 续 存 储 )。 </p>
<p>随 机 访 问 就 是 指 可 以 直 接 通 过 开 销 恒 定 的 算 术 运 算 来 得 到 任 一 元 素 的 内 存 地 址 的 访 问 方 法</p>
<p>顺 序 访 问 则 是 指 必 须 从 第 一 个 元 素 开 始 遍 历 , 直 到 找 到 所 需 的 元 素 对 象 为止 ,<br>而 无 法 直 接 得 到 任 一 中 间 元 素 对 象 的 地址</p>
<p><img src="/../img/C++/Pasted%20image%2020230603052600.png"></p>
<p>stack、queue 及 priorityqueue 在 概 念 和 接 口 上 都 不 支 持 随 机 访 问和 遍历 ,<br>这 是 由 它 们 的 语 义 决 定 的 , 而 不 是 由 底 层 存 储 方 式 决 定 的 , 因此 没 有 选 代 器<br>( 所 以 它 们 才 被 叫 做 容 器 近 配 器 而 不 是 归 为 容 器 类 ), </p>
<p>这 两 种 基 本 的 存 储 方 式 可 以 演 变 出 各 种 不 同 的 存 储 方 式 ,<br>比 如 分 层 连 续 存 储 、 树 (Tree)、 邻 接 表 、 图 等 , 甚 至 可 以 把 二 者 组 合 起 来 </p>
<p>就 拿 “ 树 “ 来 说 , 它 在 本 质 上 就 是 一 种 特 殊 的 链 表 结 构 , 因 此 只 能 顺 序 访 问 ,<br>即 从 某 个 节 点 开 始 搜 索 直 至 到 达 所 要 访 问 的 元 素 对 象 ,<br>或 者 采 用 深 度 优 先 、 广 度 优 先 或 者 前 序 、 中 序 、 后 序 等 方 法 遍 历 整 棵 树 ,<br>但 是 不 可 能 直 接 定 位 到 树 上 的 任 一 个 结 点 对 象 。</p>
<p>主 要 有 一 叉 搜 索 树 (binary-search)、 平 衡 二 叉 树 (balanced binary search). 红 黑 树 (red-black) 等 </p>
<p>由于 红 黑 树 ( 平 衡 二 又 搜 索 树 的 一 种 ) 在 元素 定 位 上 的 优 异 性 能 (CO(logyW),STL 通 常 使 用 它 来 实 现 关 联 式 容 器 </p>
<p>顺序 容 器 主 要 采 用 向 量 和 链 表 及 其 组 合 作 为 基 本 存 储 结 构 , 如 堆 栈 和 各 种 队 列<br>而 关 联 式 容 器 采 用 平 衡 二 叉 搜 索 树 作 为 底 层 存 储 绪 构</p>
<p>由 于 顺 序 容 器 本 来 就 有 “ 序 “, 所 以 它 是 通 过 元 素 对 象 在 容 噬 中 的位 置 来标 识 一 个 元 素 的 ,<br>而 不 是 通 过 元 素 的 值 ( 因 为 它 可 以 存 储 值 相 等 的 多 元 素 对 象 , 而 且 它 们 的 位 置 不 一 定 相 邻 ),<br>这 也 就 是 调 用 顺 序 容 器 的 insert0 函 数 和 erase0 函 数 时 必 须 指 定 插 入 位 置 和 删 除 位 置<br>而 不 能 仅 指 定 元 素 值 的 原 因 .<br>当 然 , 关 联 式 容 噩 也 能 存 储 值 相 等 的 元 素 , 比 如 multimap 和 multiset 等 ,<br>但 是 它 们 在 容 器 中 的 位 置 肯 定 是 相 邻 的</p>
<p><img src="/../img/C++/Pasted%20image%2020230603055357.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Container:iiterator first = theContainerObj.<span class="built_in">begin</span>(),</span><br><span class="line">fast = theContainerObj.<span class="built_in">end</span>(Q);</span><br><span class="line">first != last;</span><br><span class="line">++first) </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; first-&gt;.,. &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; (*first)... &lt;&lt; endl;</span><br><span class="line">/</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Inputlterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Inputlterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">Inputlterator <span class="title">find</span><span class="params">(Inputlterator first, Inputfterator last, <span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(first != last &amp;&amp; *first != value) ++first;</span><br><span class="line"><span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>hash table 及 由 它 演 化 出 来 的 hash_set&#x2F; hash_map&#x2F;hash_ multiset&#x2F;hash_multimap<br>作 为 关 联 式 容 磐 加 进来</p>
<p>STL 容 器 采 用 拷 贝 方 式 来 接 收 待 插 入 的 元 素 对 象 一 一 在 插入 的 时 候 容 器<br>自 动 新 建 等 量 的 元 素 对 象 , 并 用 待 插 入 对 象 依 次 初 始 化 它 们 ( 调 用 拷 贝 构 造 函 数 </p>
<p>在 删 除 元 素 时 , 容 器 负 责 释 放 其 内 存 资 源 ( 对 札 用 随 机 存 储 策 略 的 容 器 )<br>或者 仅 仅调 用 元 素 的 析 构 函 数 ( 对 采 用 连 续 存 储 策 略 的 容 器 </p>
<p>对 象 类 型 一 般 需 要 符 合 下 述 要 求 , 才 能 够 作 为 STL 容 器 的 元 素 。<br>(1) 可 默 认 构 造 的 。 但 不 是 在 任 何 情 况 下 都 需 要 满 足 这 一 条 , 比 如 关 联 式 容 器 ,<br>i 对 于 顺 序 容 器 , 除 非 在 初 始 化 的 时 候 需 要 插 入 默 认 构 造 的 若 干 个 对 象 , 或 者 调 用 容<br>| 器 的 resize0、assign0、insert0等 函 数 的 菜 些 版 本 , 否 则 也 不 需 要 满 足 这 – 条 。<br>(2)) 可 拷 贝 构 造 的 。<br>(3) 可 拷 贝 赋 值 的 ( 但 也 不 是 在 任 何 情 况 下 都 需 要 )。<br>这 几 条 条 对 基 本 数 据 类 型 及 不 含 指 针 成 员 和 引 用 成 员 的 类 型 都 是 适 用 的 。<br>(4) 或 者 , 具 有 public的 、 采 用 拷 贝 的 方 式 显 式 定 义 的 拷 贝 构 造 函 数 、 拷 贝 赋<br>, 值 函 数 和 析 构 函 数 。 这 一 条 适 用 于 含 有 指 针 成 员 或 引 用 成 员 的 对 象 ,<br>但 模 拟 指 针 ( 例如 迭 代 器 ) 应 该 归 入 前 面 几 条 中 </p>
<p>引 用 不 能 作 为 STL 容 噩 的 元 素 类 型 :<br>第 一 , 引用 在创 建 时 必 须 初 始 化 为 一 个 具 体 的 对 氢 , 而 STL 容 器 不 能 满 尸 这 一 要 求 ;<br>第 二 , 引 用 没 有 构 造 函 数 和 析 构 函 数 , 更 没 有 赋 值 语 义 .</p>
<h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭 代 器 是 为 了 降 低 容 器 和 泛 型 算 法 之 间 的 糖 合 性 而 设 计<br>指 针 代 表 眠 正 的 内 存 地 址 , 即 对 象 在 内 存 中 的 存 储 位 置 ;<br>而 迭 代 器 则 代 表 元 素 在 容 器 中 的 相 对 位 置<br>( 当 道 历 容 命 的 时 候 , 关 联 式 容 器 的 元 素 也 就 具 有 了 “ 相 对 位 置 “)。</p>
<p>vector, 没 有 必 要 重 新 定 义 迭 代 器 类 型 , 其 元 素 ! 的 指 针 就 可 以 直 接 充 当 迭 代 器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> T* iterator;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> T* iterator;</span><br></pre></td></tr></table></figure>

<p>采 用 不 连 续 存 储 或 其 他 存 储 方 式 的 容 器 , 例 如 ist. deque. set. map 等 ,<br>则 | 需 定 义 自 己 的 迭 代 器 类 (class), 一 般 情 况 下 它 们 是 对 元 素 指 针 的 封 装 , 即 模 拟 指 针</p>
<p>一 些 特 殊 容 器 如 <code>vector&lt;bool&gt;</code> 和 <code>bitset&lt;N&gt;</code> 等 ,</p>
<p>较 典 型 的 算 法 就 是 distance 和 advance。 这 方 面 的 知 识 涉 及 到 traits 技术<br>使 用 <code>vector&lt;int&gt;::iterator</code>, 而不是<code>int*</code> 虽然它们是等价的’,</p>
<h4 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h4><p>迭 代 器 失 效 是 指 当 <strong>容 器 底 层 存 储 发 生 变 动</strong> 时 , 原 来 指 向 容 器 中 某 个 或 某 些 元 素 的 迭 代 器<br>由 于 元 素 的 存 储 位 置 发 生 了 改 变 而 不 再 指 向 它 们 , 从 而 成 为 无 效 的 迭 代 器 。 |<br>使 用 无 效 的 迭 代 器 就 像 使 用 无 效 的 指 针 ( 野 指 针 ) 一 样 危 险 。</p>
<p>引 起 容 器 存 储 的 变 动 呢<br>主 要 有 : reserve(0、 resize(). push_back(), pop_back(). insert(). erase(). clear() 等 容 器 方 法<br>和 一 些 泛 型 算 法 , 如 sort()、copy()、 replace()、remove()、unique(),<br>以 及 集 合 操 作 ( 并 、 交 、 差 ) 算 法 等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">《</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; ages</span>; / 未 预 留 空 间</span><br><span class="line">ages.<span class="built_in">push_back</span>(<span class="number">2</span>); / 引 起 内 存 重 分 配</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator p = ages.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> Ginti=<span class="number">0</span>;i&lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">ages.<span class="built_in">push_back</span>(<span class="number">5</span>); / 会 引 起 若 干 次 内 存 重 分 配 操 作</span><br><span class="line">&#125;</span><br><span class="line">. cout &lt;&lt; “The first age :“&lt;&lt;*p &lt;&lt; endl: /p 已 经 失 效 , 危 险 !</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator p = ages.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">0</span>; i&lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">ages.<span class="built_in">push_back</span>(<span class="number">5</span>); / 会 引 起 若 干 次 内 存 重 分 配 操 作</span><br><span class="line">&#125;</span><br><span class="line">p = ages.<span class="built_in">begin</span>(); / 重 新 获 取 迭 代 器</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The first age : “&lt;&lt; *p &lt;&lt; endl; 八 ok</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>容 量 是 为 了 减 少 那 些 使 用 连 续 空 间 ( 线 性 空 间 》 存 储 元 素 的 容 器 在 增 加 元 素 时<br>重 新 分 配 内 存 的 次 数 的 一 种 机 制 , 即 当 增 加 元 素 且 剩 余 空 闲 空 间 不 足 时 ,<br>按照 一 定 比 例 ( 通 常 是 原 来 容 量 的 2 或 1.5 倍 )<br><img src="/../img/C++/Pasted%20image%2020230603075716.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我 们 可 以 从 std::vector&lt;T&gt;的 size0和 capacity0这 两 个</span><br><span class="line">成 员 函 数 的 实 现 上 看 出 容 器 所 辖 元 素 空 间 和 容 量 的 区 别 :</span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span></span>&#123; <span class="keyword">return</span> (start == <span class="number">0</span> ? <span class="number">0</span> : end_of_storage - start); &#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (start == (<span class="number">70</span>: finish - start); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="built_in">reserve</span>(size_type n);</span><br></pre></td></tr></table></figure>

<p>(1)) 如 果 n 大 于 容 器 现 有 的 容 量 ( 即 capacity0),<br>则 需 要 在 自 由 内 存 区 为 整 个 容 器 重 新 分 配 一 块 新 的 更 大 的 连 续 空 间 , 其 大 小 为 n * sizeof (T),<br>然 后 将 容 器 内 所 有有 效 元 素 从 旧 位 置 全 部 拷 贝 到 新 位 置 ( 调 用 拷 贝 构 造 函 数 ),<br>最 后 释 放 旧 位 置 的 所 有存 储 空 间 并 调 整 容 器 对 象 的 元 素 位 置 指 示 器<br>( 就 是 让 那 三 个 指 针 指 向 新 内 存 区 的 相 应 位 置 )。<br>也 就 是 说 , 如 果 请 求 容 量 比 原 有 容 量 大 的 话 , 结 果 是 容 器 的 冗 余 容 量 加 大<br>(2) &lt;&#x3D;n 什么都不做</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::list&lt;<span class="type">int</span>&gt; li;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> ¢ = <span class="number">0</span>; ¢ &lt; <span class="number">10</span>; c++)</span><br><span class="line"><span class="built_in">lipush_back</span> (c);</span><br><span class="line">vi.<span class="built_in">reserve</span>(li.<span class="built_in">size</span>());<span class="comment">// 预 留 空 间 , 但 是 并 没 有 改 变 容 器 的 大 小 , 预 留 空 间 未 初 始 化</span></span><br><span class="line">std::<span class="built_in">copy</span> (libegin0, liendO vi.<span class="built_in">begin</span>()); / 拷 贝赋 值</span><br><span class="line">std::<span class="built_in">copy</span> (vi-<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cerr, <span class="string">&quot;\t&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确使用方法</span></span><br><span class="line">vi.<span class="built_in">reserve</span> (li.<span class="built_in">size</span>()); <span class="comment">// 预留 空 间 , 但 是 并 没 有 改 </span></span><br><span class="line">std::<span class="built_in">copy</span>(t.beginO, <span class="built_in">liend</span>(), std::<span class="built_in">back_inserter</span>(vi));</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230603081048.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(size type n, <span class="type">const</span> T&amp; c = T())</span></span>;</span><br></pre></td></tr></table></figure>

<p>其 中 n 就 是 最 后 要 保 持 的 元 素 个 数 , 如 果 需 要 新 增 元 素 的 话 ,c 则 是 新 增 元 素 的 默 认<br>壹 初 始 值 。 下 面 是 resize()的 实 现 策 略 。<br>(1) 如 果 n 大 于 容 器 当 前 的 大 小 ( 即 size0), 则 在 容 器 的 末 尾 插 入 ( 追加 ) n<br>size0个 初 值 为 c 的 元 素 , 如 果 不 指 定 初 值 , 则 用 元 素 类 型 的 默 认 构 造 函 数 来 初 始 化<br>每一 个 新 元 素 〔 这 可 能 引 起 内 存 重 分 配 以 及 容 器 容 量 的 扩 张 )。<br>(2) 如 果 n 小 于 容 器 当 前 的 大 小 , 则 从 容 器 的 末 尾 删 除 size 0 ~ n 个 元 素 ,<br>但i <strong>不 释 放 元 素 本 身 的 内 存 空 间</strong>, 因 此 容 量 不 变 。<br>(3) 否 则 , 什 么 也 不 做 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">td::list&lt;<span class="type">int</span>&gt; 。 止 ;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">10</span>; c++)</span><br><span class="line">li.<span class="built_in">push_back</span> (c);</span><br><span class="line">vi-<span class="built_in">resize</span>(li.<span class="built_in">size</span>(); / 调 整 容 器 大 小</span><br><span class="line">std::<span class="built_in">copy</span> (li-<span class="built_in">begin</span>(), li.<span class="built_in">end</span>(), vi-<span class="built_in">begin</span>()); UMA</span><br><span class="line">std::<span class="built_in">copy</span> (vi-<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cerr, <span class="string">&quot;\t&quot;</span>));</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230603081829.png"></p>
<p> 压 缩 容 器的 多 余 容 量 从 而 节 省 存 储 空 间<br> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> std::vector&lt;<span class="type">int</span>&gt; — vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; <span class="number">10</span>; c++)</span><br><span class="line">vi.<span class="built_in">push_back</span> (c);</span><br><span class="line">std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(vi).<span class="built_in">swap</span>(vi); W 构 造 一 个 临 时 对 象 , 然 后 与 之 交 换 元 素</span><br></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">17</span><span class="number">-7</span> 一 个 固 定 容 量 的 循 环 队 </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T <span class="comment">/* 元 素 类 型 */</span> , <span class="type">unsigned</span> <span class="type">int</span> N <span class="comment">/* 容 量 */</span> &gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CyclicQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> T value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> T&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> T&amp; const_reference;</span><br><span class="line"><span class="built_in">CyclicQueue</span>() : <span class="built_in">m_popPos</span>(<span class="number">0</span>), <span class="built_in">m_count</span>(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">assert</span>(N &gt; <span class="number">0</span>);</span><br><span class="line">m_beginPtr = (T*)(::<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T) * N)); / 分 配 原 始 空 间</span><br><span class="line">&#125; 。</span><br><span class="line">~<span class="built_in">CyclicQueue</span>() &#123;</span><br><span class="line">_Clear(); <span class="comment">// this-&gt;_Clear(Q);</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">((<span class="type">void</span>*)m_beginPtr)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CyclicQueue</span>(<span class="type">const</span> CyclicQueue&lt;T, N&gt;&amp; copy) : <span class="built_in">m_popPos</span>(<span class="number">0</span>), <span class="built_in">m_count</span>(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">assert</span>(N &gt; <span class="number">0</span>);</span><br><span class="line">m_beginPtr = (T*)(<span class="keyword">operator</span> <span class="built_in">new</span>(<span class="built_in">sizeof</span>(T) * N)); / 分 配 原 始 空 间</span><br><span class="line"><span class="type">size_t</span> copyPos = copy.m_popPos;</span><br><span class="line"><span class="keyword">for</span> (size_type idx = <span class="number">0</span>; idx &lt; copy.m_count; ++idx) 【</span><br><span class="line">_Copy(idx, copy.m_beginPtr[copyPos&#125;); <span class="comment">// this-&gt;_Copy0Q;</span></span><br><span class="line">++copyPos; copyPos %= N; ++m_count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">CyclicQueue&amp; <span class="keyword">operator</span>=(<span class="type">const</span> CyclicQueue&lt;T, N&gt;&amp; other) &#123;</span><br><span class="line">CyclicQueue&lt;T, N&gt; <span class="built_in">temp</span>(other); W 调 用 拷 贝 构 造 函 数</span><br><span class="line"><span class="built_in">swap</span>(temp); [ff <span class="keyword">this</span>-&gt;swapQ);</span><br><span class="line"><span class="keyword">return</span> (*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_empty</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (m_count == <span class="number">0</span>); &#125;</span><br><span class="line"><span class="type">bool</span> isfulO <span class="type">const</span> &#123; <span class="keyword">return</span> (m_count == N); &#125;</span><br><span class="line"><span class="function">value_type <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(m_count != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (m_beginPtr[m_popPos&#125;);</span><br><span class="line">&#125; .</span><br><span class="line"><span class="function">value_type <span class="title">front</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(m_count != <span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> (m_beginPtr[m_popPos]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">value_type <span class="title">back</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(m_count != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">size_type pushPos = (m_popPos + m_count) % N;</span><br><span class="line"><span class="keyword">if</span> (pushPos== <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (*(m_beginPtr + N - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">return</span> (m_beginPtr[pushPos - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line">) <span class="function">value_type <span class="title">back</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line"><span class="built_in">assert</span>(m_count &#123;= <span class="number">0</span>);</span><br><span class="line">size_type pushPos = (m_popPos + m_count) % N;</span><br><span class="line"><span class="keyword">if</span> (pushPos == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> (*(m_beginPtr + N - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">return</span> (m_beginPtr[pushPos - <span class="number">1</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">; <span class="type">bool</span> <span class="built_in">push</span>(const_reference data = TO) &#123;</span><br><span class="line">| <span class="keyword">if</span> (m_count &lt;N) t / 不 满 !</span><br><span class="line">size_type pushPos = (m_popPos + m_count) % N;</span><br><span class="line">i _Copy(pushPos, data); /! <span class="keyword">this</span>-&gt;_CopyQ;</span><br><span class="line">++m_count;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">)</span><br><span class="line">) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">) <span class="function"><span class="type">bool</span> <span class="title">pop</span><span class="params">(reference data)</span> </span>&#123;</span><br><span class="line">| <span class="keyword">if</span> (m_count &gt; <span class="number">0</span>) &#123; 丫 不 宇 !</span><br><span class="line">data = m_beginPtr[m_popPos]; /f <span class="keyword">operator</span>=</span><br><span class="line">彗 _Destroy(m_popPos); <span class="comment">// this-&gt;_Destroy(Q);</span></span><br><span class="line">--m_count; ++m_popPos; m_popPos %= N; / 新 的 pop 位 置</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_count; &#125;</span><br><span class="line"><span class="function">size_type <span class="title">capacity</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> N; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;_Clear(); &#125; / <span class="keyword">this</span>-&gt;_Clear();</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(CyclicQueue&lt;T, N&gt;&amp; other)</span> </span>&#123;</span><br><span class="line">std::<span class="built_in">swap</span>(m_beginPtr, other.m_beginPtr);</span><br><span class="line">std::<span class="built_in">swap</span>(m_popPos, other.m_popPos);</span><br><span class="line">std::<span class="built_in">swap</span>(m_count, other.m_count);i|</span><br><span class="line">i</span><br><span class="line"><span class="string">&#x27; &#125;</span></span><br><span class="line"><span class="string">i</span></span><br><span class="line"><span class="string">ii private:</span></span><br><span class="line"><span class="string">void Clear() &#123;</span></span><br><span class="line"><span class="string">for (; m_count &gt; 0; --m_count) &#123;</span></span><br><span class="line"><span class="string">_Destroy(m_popPos); H this-&gt;_Destroy();</span></span><br><span class="line"><span class="string">| ++m_popPos; m_popPos %= N;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">m_popPos = 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void _Destroy(sizetype idx) &#123;</span></span><br><span class="line"><span class="string">assert(idx &lt; NJ;</span></span><br><span class="line"><span class="string">T *pTemp = (m_beginPtr + idx);</span></span><br><span class="line"><span class="string">pTemp-&gt;~TQ; W 调 用 析 构 函 数 销 毁 元 素 对 象</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">void _Copy(size_type idx, const_reference data) &#123;</span></span><br><span class="line"><span class="string">assert(idx &lt; N);</span></span><br><span class="line"><span class="string">T *pTemp = (m_beginPtr + idx);</span></span><br><span class="line"><span class="string">new ((void*)pTemp) T(data); // 调 用 placement new 和 拷 贝 构 造 函 数 拷 贝 对 象</span></span><br><span class="line"><span class="string">| &#125;|</span></span><br><span class="line"><span class="string">| value_type *m_beginPtr; / 队 列 存 储 空 间 起 始 位 置</span></span><br><span class="line"><span class="string">size_type m_popPos; / 下 次 pop 位 置</span></span><br><span class="line"><span class="string">| size_type m_count; / 有 效 元 紫 个 数</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>

<p><strong>尽 量 不 要 在 道 历 容 器 的 过 程 中 义 容 器 进 行 插 入 元 素 、 删除 元 素 等 修 改 擎作 ,</strong><br>这 和 不 要 在 for 循 环 中 修 改 计 数 器 是 一 个 道 理 , 特 别 是 连 续 存 储 的 容器 中 。<br>因 为 这 些 操 作 会 使 一 些 追 代 器 失 效 , 特 别 是 当 前 选 代 器 , 这 在 效果 上 等 价 于 修 改 了 循 环 计 数 器 。<br>更 进 一 步 的 原 因 是 下 一 次 迭 代 操 作 , 即++iterator 会 使 用 本 次 选 代 操 作 的 选 代 器 ,<br>而 当 前 迭 代 器 可 能 已 经 失 效 </p>
<p>虽然 有 些 容 器 如 list, 修 改 操 作 只 会 使 当 前 选 代 器 失 效 , 即 并 不 会 引 起 存储 空 间 重 分 配 ,<br>所 以 可 以 在 邋 历 的 过 程 中 正 确 地 删 除 当 前 元 素 ( 这 里 面有一 个 技 巧 ),<br>但 是 也 最 好 不 要 这 样 做 , 否 则 可 能 存 在 重 大 隐 惠 . 参 见 list等 的 remove(). remove_if() 成 员 函 数 的 实 现 </p>
<h3 id="存储分配器"><a href="#存储分配器" class="headerlink" title="存储分配器"></a>存储分配器</h3><p>allocator类 是 一 个 模 板 , 作 为 容 器 类 模 板 的 一 个 policy 参 数 , 它 不 仅 与 将 要 为 之<br>分 配 空 间 的 数 据 对 象 的 类 型 无 关 , 并 且 为 动 态 内 存 的 分 配 和 释 放 提 供 了 面 向 对 象 的<br>接 口 。 它 是 对 new 运 算 符 的 更 高 层 次 的 抽 象 , 即 隐 藏 了 底 层 的 内 存 模 式 〔 段 内 存 、<br>! 共享 内 存 、 分 布 式 内 存 等 ), 封 装 了 动 态 内 存 分 配 和 释 放 操 作 , 隐 藏 了 指 针 本 身 的 大<br>| 小 、 存 储 空 间 重 分 配 模 型 及 内 存 页 大 小 等 细 节 , 提 供 了 更 好 的 可 移 植 性 。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">17</span><span class="number">-8</span>  COM 环 境 下 STL 容 器 的 allocator 实 </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Ty&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">STLCOMAllocator</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">size_t</span> size_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">ptrdiff_t</span> difference_type;</span><br><span class="line"><span class="keyword">typedef</span> _Ty value_type;</span><br><span class="line"><span class="keyword">typedef</span> _Ty* pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> _Ty* const_pointer;</span><br><span class="line"><span class="keyword">typedef</span> _Ty&amp; reference;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">const</span> _Ty&amp; const_reference;</span><br><span class="line"><span class="function">pointer <span class="title">address</span><span class="params">(reference ref)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (&amp;ref); &#125;</span><br><span class="line"><span class="function">const_pointer <span class="title">address</span><span class="params">(const_reference ref)</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> (&amp;ref); &#125;</span><br><span class="line"><span class="function">_Ty* <span class="title">allocate</span><span class="params">(size_type n, <span class="type">const</span> <span class="type">void</span>* <span class="comment">/* no use */</span> )</span></span></span><br><span class="line"><span class="function">皇 </span>&#123; <span class="keyword">return</span> (pointer)(::<span class="built_in">CoTaskMemAlloc</span>(n * <span class="built_in">sizeof</span>(_Ty))); &#125; <span class="comment">// aligned!</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">deallocate</span><span class="params">(<span class="type">void</span> *p, size_type <span class="comment">/* no use */</span> )</span></span></span><br><span class="line"><span class="function"></span>&#123; ::<span class="built_in">CoTaskMemFree</span>(p); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">construct</span><span class="params">(pointer p, <span class="type">const</span> Ty&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) <span class="keyword">new</span> ((<span class="type">void</span>*)p)_Ty(v); <span class="comment">// placement new &amp; copy constructor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">destroy</span><span class="params">(pointer p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) p-&gt;~_TyQ; <span class="comment">// destructor</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">size_type <span class="title">max_size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">size_type sz = (size_type)(<span class="number">-1</span>) / <span class="built_in">sizeof</span>(_ Ty);</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span> &lt; sz? sz: <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty, <span class="keyword">typename</span> _U&gt; <span class="keyword">inline</span></span><br><span class="line"><span class="type">bool</span> __stdcall <span class="keyword">operator</span> ==(<span class="type">const</span> STLCOMAllocator&lt;_Ty&gt;&amp;,</span><br><span class="line"><span class="type">const</span> STLCOMAllocator&lt;_U&gt;&amp;)</span><br><span class="line">&#123; <span class="built_in">return</span> (<span class="literal">true</span>); &#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Ty, <span class="keyword">typename</span> _U&gt; <span class="keyword">inline</span></span><br><span class="line"><span class="type">bool</span> __stdcall <span class="keyword">operator</span> !=(<span class="type">const</span> STLCOMAIlocator&lt;_Ty&gt;&amp;,</span><br><span class="line"><span class="type">const</span> STLCOMAIlocator&lt;_U&gt;&amp;)</span><br><span class="line">&#123; <span class="built_in">return</span> (<span class="literal">false</span>); </span><br></pre></td></tr></table></figure>

<h3 id="适配器-容器适配器-stack-deque-list"><a href="#适配器-容器适配器-stack-deque-list" class="headerlink" title="适配器 容器适配器 stack deque list"></a>适配器 容器适配器 stack deque list</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; li;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; k<span class="number">+4</span>) &#123;</span><br><span class="line">li.<span class="built_in">push_back</span>(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">copy</span>(li.<span class="built_in">begin</span>(), li.endQ, ostream _iterator&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list&lt;<span class="type">int</span>&gt; list ;</span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; eos, <span class="built_in">isiter</span>(cin);</span><br><span class="line"><span class="built_in">copy</span>(isiter, eos, <span class="built_in">back_inserter</span>(li));</span><br><span class="line"><span class="built_in">copy</span>(li.<span class="built_in">begin</span>(),li.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout,<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure>


<h3 id="泛型算法-1"><a href="#泛型算法-1" class="headerlink" title="泛型算法"></a>泛型算法</h3><p>STL 提 供 的 泛 型 算 法 主 要 有 如 下 几 种 ;</p>
<blockquote>
<p>“ 查 找 算 法 , 如 find0、search0、binary search()、find_if0等 。<br>今 “ 排 序 算 法 , 如 sort)、merge0等 。<br>从 “ 数 学 计 算 , 如 accumulate0、inner product0、partial sum0 等 。</p>
</blockquote>
<ul>
<li>“ 集合 运 算 , 如 set_union0、set_intersection0、includes0等 。</li>
<li>“容器 管 理 , 如 copy0、replace0、transform0、remove()、for each() 等 。<blockquote>
<p>“ 统 计 运 算 , 如 max(0O、min0、count0、max_element0等 。<br>今 “ 堆 管 理 , 如 make_heap()、push_heap0、pop_ heap(). sort_heap().<br>“ 比 较 运 算 , 如 equal0等</p>
</blockquote>
</li>
</ul>
<p> 泛 型 算 法 一 般 接 受 下 列 参 数 类 型 的 一 种 或 几 种<br>“ 迭 代 器 , 标 示 容 器 或 区 间 的 范 围 , 以值 传 递 。<br>从 “ 谓 词 , 返 回 bool 值 的 函 数 对 象 , 指 定 算 法 的 操 作 方 式 , 例 如 find_if0的 第 三<br>个 参 数 。<br>从 函 数 对 象 , 用 户 指 定 要 做 的 操 作 , 例 如 for_ each(0)的 第 三 个 参 数 。<br>今 “ 容器 元 素 , 用 户 指 定 的 基 准 对 象 , 例 如 find0的 第 三 个 参 数 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Template&lt;<span class="keyword">typename</span> Inputlterator, <span class="keyword">typename</span> Outputlterator&gt; <span class="keyword">inline</span></span></span><br><span class="line"><span class="function">Outputlterator <span class="title">copy</span><span class="params">(Inputlterator first, InputIterator last, Outputlterator oi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(; first != last; ++first, ++oi)</span><br><span class="line">	*oi = *first;</span><br><span class="line">	<span class="keyword">return</span> Oi;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; i; vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c&lt; <span class="number">10</span>; c++) li.<span class="built_in">push_back</span>(c);</span><br><span class="line">vi.<span class="built_in">resize</span>(li.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">copy</span>(libeginO, liendO, vi.<span class="built_in">begin</span>()); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; i; vector&lt;<span class="type">int</span>&gt; vi;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c&lt; <span class="number">10</span>; c++) li.<span class="built_in">push_back</span>(c);</span><br><span class="line">/ 拷 贝 链 表 元 素 到 vi 中 , 使 用 插 入 迭 代 器</span><br><span class="line"><span class="built_in">copy</span>(<span class="built_in">libegin</span>(, li.endQ), <span class="built_in">back_inserter</span>(vi)); / 调 用 vi.<span class="built_in">push_back</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>侃 多 泛 型 算 法 总 是 假 定 容 器 的 元 素 类 型 定 义 了 operator-(、operator–0、 operatorl&#x3D;()、operator&lt;() 或 operator&gt;() 等 函 数 , 因 此 你 有 义 务 为 你 的 家 器 元 素 类 型 定 义 它 们 , 否 则 泛 型 算 法 将 采 用 元 素 类 型 的 默 认 语 义 或 者 报 错。</p>
<p>在 应 用 编 程 时 要 选 用 最 合 适 的 算法<br>,find0 算 法 的 复 杂 度 为 O(, 而 binary seareh0 算 法 的 复 杂 度 为$O(log{2}N)$当 容 器 中 的 元 素 有 序 时 , 当 然 应 选 用 binary seareh0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 <span class="number">17</span><span class="number">-15</span> 基 于 STL 框 架 实 现 的 “ 折 半 “ 查找 算法</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">RandomAccessIterator <span class="title">binary_search</span><span class="params">(RandomAccesslterator first,</span></span></span><br><span class="line"><span class="params"><span class="function">RandomAccesslterator last,</span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> T&amp; value)</span></span></span><br><span class="line"><span class="function">RandomAccesslterator mid, not_found </span>= last;</span><br><span class="line"><span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">mid = first + (last - frst) / <span class="number">2</span>:; / 注 意 : 不是 (first + last) / <span class="number">2</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">L</span>(value &lt; *mid) &amp;&amp; !(*mid &lt; value))</span><br><span class="line"><span class="keyword">return</span> mid; /! 调 用 T::<span class="keyword">operator</span>&lt;()</span><br><span class="line"><span class="keyword">if</span> (value &lt; *mid)</span><br><span class="line">last = mid; <span class="comment">// 调 用 T::operator&lt;()</span></span><br><span class="line"><span class="keyword">else</span> first = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> not_found;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="一些特殊容器"><a href="#一些特殊容器" class="headerlink" title="一些特殊容器"></a>一些特殊容器</h3><h3 id="string-类"><a href="#string-类" class="headerlink" title="string 类"></a>string 类</h3><h3 id="bitset-并非set"><a href="#bitset-并非set" class="headerlink" title="bitset 并非set"></a>bitset 并非set</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="type">size_t</span> Length&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bitset</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">reference</span>&#123; ... &#125;; / 可 以 自 动 转 换 为 <span class="type">bool</span> 变 量</span><br><span class="line"><span class="comment">// constructors...</span></span><br><span class="line">Hf accessors...</span><br><span class="line"><span class="comment">// rautators...</span></span><br><span class="line"><span class="comment">// convertors...</span></span><br><span class="line"><span class="comment">// statistics...</span></span><br><span class="line"><span class="comment">// test...</span></span><br><span class="line">I &amp;=, |=, *=, &lt;&lt;=, &gt;&gt;=, &gt;&gt;, &lt;&lt;, ==, !=, ~ overloading...</span><br><span class="line">/ &lt;&lt;(output), &gt;&gt;(input), &amp;, |, ^ <span class="keyword">friend</span> overloading...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">WORD BITS = <span class="built_in">sizeof</span>(<span class="type">unsigned</span> <span class="type">long</span>) * <span class="number">8</span>, / WORD 的 bit 数</span><br><span class="line">N_WORD= ( Length== <span class="number">0</span> ? <span class="number">0</span> : (Length - <span class="number">1</span>) /,WORD_BITS )</span><br><span class="line"><span class="comment">// Length 个 bit 折 合 多 少 个 WORD</span></span><br><span class="line">出</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> array[N_WORD + <span class="number">1</span>]; <span class="built_in">ABBA</span> ( 不 能 定 义 长 度 为 <span class="number">0</span> 的 数 组 )</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/../img/C++/Pasted%20image%2020230603090456.png"></p>
<h3 id="vector"><a href="#vector" class="headerlink" title="vector&lt;bool&gt;"></a><code>vector&lt;bool&gt;</code></h3><p><img src="/../img/C++/Pasted%20image%2020230603091045.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">typedef</span> vector&lt;<span class="type">bool</span>&gt; BoolVector; <span class="comment">// vector&lt;bool&gt;的 具 体 名 字 与 STL 实现 有 关</span></span><br><span class="line">BoolVector bvect;</span><br><span class="line">bvect.<span class="built_in">reserve</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (inti = <span class="number">0</span>; i &lt; <span class="number">100</span>; i += <span class="number">2</span>) &#123;</span><br><span class="line">bvect.<span class="built_in">insert</span>(bvect.<span class="built_in">end</span>(), <span class="literal">true</span>);</span><br><span class="line">bvect.<span class="built_in">insert</span>(bvect.<span class="built_in">end</span>(), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (BoolVector::iterator first = bvect.<span class="built_in">begin</span>(),</span><br><span class="line">last = bvect.<span class="built_in">end</span>(); first != last; ++first) &#123;</span><br><span class="line">cout &lt;&lt; *first &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; bvect.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">bvect.<span class="built_in">front</span>(). flipQ;</span><br><span class="line">bvect.<span class="built_in">back</span>().flipQ;</span><br><span class="line">bvect.flipQ;</span><br><span class="line">bvect.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空容器"><a href="#空容器" class="headerlink" title="空容器"></a>空容器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; li; / 空 容 器</span><br><span class="line">li.pop_backQ; <span class="comment">// runtime error!</span></span><br><span class="line"><span class="keyword">if</span></span><br><span class="line">(!li.<span class="built_in">empty</span>()) li.<span class="built_in">erase</span>(li.<span class="built_in">begin</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> 例 <span class="number">17</span><span class="number">-20</span>。 示 例 <span class="number">17</span><span class="number">-20</span> </span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span> / 顺 序 容 器 </span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span> / 联 合 容 器</span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> using namespace std; </span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"> </span>&#123; <span class="type">int</span> *p = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">100</span>);</span><br><span class="line">  list&lt;<span class="type">int</span>&gt; temp1;</span><br><span class="line">   temp] .<span class="built_in">insert</span>(temp<span class="number">1.</span><span class="built_in">end</span>(), <span class="number">10</span>);</span><br><span class="line">    list&lt;<span class="type">int</span>&gt; li; W 空 容 器</span><br><span class="line">liinsertdisend0, <span class="number">10</span>); / 创 建 新 对 象</span><br><span class="line">li.<span class="built_in">insert</span>(li.endQ, <span class="number">10</span>); / 创 建 新 对 象</span><br><span class="line"><span class="built_in">Iierase</span>(temp1l.begin0O); “ 丫 runtime error! 虫 然 li 中 也 有 值 为 <span class="number">10</span> 的 <span class="type">int</span> 元 素</span><br><span class="line">/ 但 是 temp<span class="number">1.</span>begin0指 向 的 元 素 对 象 并 不 属 于 li 所 有</span><br><span class="line"><span class="built_in">lierase</span>(li-<span class="built_in">begin</span>(Q)); ok! libegin0指 向 的 对 象 为 ii 所 有</span><br><span class="line">| <span class="built_in">lierase</span>(*p); W compiling error! 没 有 定 义 这 样 的 方 法 , 对象 *p 不</span><br><span class="line">W 属 于 i 所 有 。 不 能 以 元 素 的 值 来 判 断 其 是 否 属 于 一</span><br><span class="line">W 个 顺 序 容 器 , 因 为 顺 序 容 器 可 以 同 时 存 储 值 完 全 相 同</span><br><span class="line">W 的 多 个 对 象 ; 否 则 容 器 将 不 知 道 该 删 除 哪 一 个 元 素 了</span><br><span class="line"><span class="number">1</span> set&lt;<span class="type">int</span>&gt; temp2;</span><br><span class="line">| temp<span class="number">2.</span><span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">set&lt;<span class="type">int</span>&gt; si; / 空容 器</span><br><span class="line"><span class="built_in">siinsert</span>(<span class="number">10</span>); / si 包 含 一 个 值 为 <span class="number">10</span> 的元 素</span><br><span class="line"><span class="built_in">siinsert</span>(si.<span class="built_in">end</span>(<span class="number">0</span>), <span class="number">20</span>);</span><br><span class="line"><span class="built_in">siinsert</span>(<span class="built_in">sisend</span>(<span class="number">0</span>), <span class="number">20</span>); 丫 忽 略 !</span><br><span class="line">si.<span class="built_in">erase</span>(temp<span class="number">2.</span>beginQ); —_<span class="comment">// runtime error! temp2.begin0指 向 的 对 参 不 属 于 si 所 有</span></span><br><span class="line">si.<span class="built_in">erase</span>(*p); (OK! 从 si 中 删 除 值 等 于 *p 的元 素</span><br><span class="line">si.<span class="built_in">erase</span>(si.<span class="built_in">begin</span>()); OK! sitbegin0 指 向 的 对 象 为 si 所 有</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除 了 上 面 这 些 特 殊 容 器 外 , 还 有 一 些 专 用 于 数 学 运 算 的 容 器 、 算 法 和 类 型 ,<br>如 valarray、 complex 等 , 分 别 定 义 在 头 文 件 <code>&lt;valarray&gt;和 &lt;complex&gt;</code> 中 ,<br>头 文 件 <code>&lt;numeric&gt;</code> 中 定 义 了 用 于 向 量 计 算 的 算 法 </p>
<p>往 容 器 中 插 入 元 素 时 , 若 元 素 在 容 器 中 的 顺 序 无 关 紧 要 , 请 尽 量 加 在 最<br>后 面 。 若 经 常 需 要 在 序 列 容 器 的 开 头 或 中 间 增 加 或 删 除 元 素 时 , 应选 用<br>list.</p>
<p>当 容 器 作 为 参 数 被 传 递 时 , 请 采 用 引 用 传 递 方 式 。 否 则 将 调 用 容 器 的 拷<br>贝构 造 函 数 , 其 开 销 是 难 以 想 象 的 </p>
<p>当 元 素 的 有 序 比 搜 索 速 度 更 重 要 时 , 应 选 用 set. multiset.map或 multimap。<br>否 则 , 选 用 hash_set、hash_multiset、hash_map 或 hash_multimap。</p>
<p><img src="/../img/C++/Pasted%20image%2020230603100246.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">strcpy</span><span class="params">(<span class="type">char</span>* strDest, <span class="type">char</span>* strSrc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>( (strDest != <span class="literal">NULL</span>) &amp;&amp; (srtSrc != <span class="literal">NULL</span>) );</span><br><span class="line">	<span class="type">char</span>* address = strDest;</span><br><span class="line">	<span class="keyword">while</span> ( (*strDest++ = *strSrc++) != <span class="string">&#x27;\0&#x27;</span> );</span><br><span class="line">	<span class="keyword">return</span> address;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;&quot;</span>); <span class="comment">//智 通 构 造 函 数</span></span><br><span class="line">	<span class="built_in">String</span>(<span class="type">const</span> String &amp;other);  <span class="comment">// 拷 贝 构 造 函 数</span></span><br><span class="line">	~ <span class="built_in">String</span>(<span class="type">void</span>);</span><br><span class="line">	String&amp; operate =(<span class="type">const</span> String &amp;other);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="type">char</span> *m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">//String 的 普 通 构 造 函 数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> <span class="type">char</span> *str) / <span class="number">6</span> 分</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(str == <span class="literal">NULL</span>)</span><br><span class="line">	&#123; </span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[<span class="number">1</span>];</span><br><span class="line">		*m_data = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line">		m_data = <span class="keyword">new</span> <span class="type">char</span>[length<span class="number">+1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(m_data, str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// String 的 析 构 函 数</span></span><br><span class="line">String::~<span class="built_in">String</span>(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">delete</span> [] m_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷 贝 构 造 函 数</span></span><br><span class="line">String::<span class="built_in">String</span>(<span class="type">const</span> String &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> length = <span class="built_in">strlen</span>(other.m_data);</span><br><span class="line">	m_data = <span class="keyword">new</span> <span class="type">char</span>[length<span class="number">+1</span>];</span><br><span class="line">	<span class="built_in">strcpy</span>(m_data, other.m_data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值 函 数</span></span><br><span class="line">String &amp; String::operate =(<span class="type">const</span> String &amp;other)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> *temp = <span class="keyword">new</span> <span class="type">char</span>[<span class="built_in">strlen</span>(other.m_data) + <span class="number">1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(temp, other.m_data);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">delete</span> [] m_data;</span><br><span class="line">		m_data = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://zirpon.github.io">チャン ゼプン</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://zirpon.github.io/2023/05/31/C++/">https://zirpon.github.io/2023/05/31/C++/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://zirpon.github.io" target="_blank">Zepung🐉Blog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="/img/header_img/tag-bg.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2023/01/11/%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/" title="剪映"><img class="cover" src="/img/404-bg.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">剪映</div></div><div class="info-2"><div class="info-item-1">剪映 片尾预计时间  转场过渡的使用 会影响片尾的插入时间 先调试好视频前面的各种转场特效 拼接 最后再处理 片尾  片尾跟视频 声音 可以一起处理 都是留在最后 处理 跳舞视频 蒙太奇剪辑 关键动作 减速 没必要动作加速 或者保持原速 蒙太奇剪辑后 对原视频的 音频处理 剪掉 或者恢复 或者 etc. 特效的使用 学习一下 什么场景 使用什么特效 最优效果 剪辑过程中就可以选封面  </div></div></div></a><a class="pagination-related" href="/2023/06/04/C++11%E3%80%81C++14%E3%80%81C++17%E3%80%81C++20%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93%EF%BC%885%E4%B8%87%E5%AD%97%E8%AF%A6%E8%A7%A3%EF%BC%89/" title="C++11、C++14、C++17、C++20新特性总结（5万字详解）"><img class="cover" src="/img/header_img/roman.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">C++11、C++14、C++17、C++20新特性总结（5万字详解）</div></div><div class="info-2"><div class="info-item-1">C++11、C++14、C++17、C++20新特性总结（5万字详解）_c++20 c++17_小熊coder的博客-CSDN博客 C++11、C++14、C++17、C++20新特性总结（5万字详解）文章目录 C++11、C++14、C++17、C++20新特性总结（5万字详解） 文章目录 C++ 11是什么，C++ 11标准的由来 C++ auto类型推导完全攻略 auto 类型推导的语法和规则 auto 的高级用法 auto 的限制 auto 的应用 使用 auto 定义迭代器 auto 用于泛型编程     C++ decltype类型推导完全攻略 exp 注意事项   decltype 推导规则 decltype 的实际应用 汇总auto和decltype的区别 语法格式的区别 对 cv...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E8%B4%A8%E9%87%8FC"><span class="toc-text">高质量C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-C-C-%E7%A8%8B%E5%BA%8F-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1. C++&#x2F;C 程序 基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2"><span class="toc-text">隐式转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">强制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%BD%AC%E6%8D%A2"><span class="toc-text">指针转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%B9%89%E5%BA%8F%E5%88%97"><span class="toc-text">转义序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6-%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-text">算术运算符 关系运算符 逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E6%88%90%E5%91%98%E9%80%89%E6%8B%A9"><span class="toc-text">函数调用 类型转换 成员选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%E5%B0%B1%E6%98%AF%E4%BC%98%E5%85%88%E7%BA%A7%E5%92%8C%E7%BB%93%E5%90%88%E5%BE%8B"><span class="toc-text">运算符基本特性就是优先级和结合律</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E7%AE%97%E6%9C%AF%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E5%A4%8D%E5%90%88%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E9%80%97%E5%8F%B7%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%9D%A1%E4%BB%B6%E8%BF%90%E7%AE%97%E7%AC%A6%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E4%BD%8D%E8%BF%90%E7%AE%97%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-text">常量表达式 算术表达式 关系表达式 逻辑表达式 复合表达式 逗号表达式 条件运算符表达式 位运算表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-text">基本控制结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%84"><span class="toc-text">选择判断结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%B8%B8%E9%87%8F"><span class="toc-text">2. 第五章 常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E9%9D%A2%E5%B8%B8%E9%87%8F"><span class="toc-text">字面常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%B8%B8%E9%87%8F"><span class="toc-text">符号常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD-%EF%BC%8Cconst%E5%AE%9A%E4%B9%89-%E7%9A%84-%E5%B8%B8%E9%87%8F-%E8%A6%81-%E5%85%B7%E4%BD%93%E6%83%85%E5%86%B5-%E5%85%B7%E4%BD%93-%E5%AF%B9-%E5%BE%85"><span class="toc-text">C++ 中 ，const定义 的 常量 要 具体情况 具体 对 待</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A5%91%E7%BA%A6%E6%80%A7%E5%B8%B8%E9%87%8F"><span class="toc-text">契约性常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E5%B8%B8%E9%87%8F"><span class="toc-text">枚举常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85-%E7%94%A8-%E4%B8%AD-%E5%A6%82-%E4%BD%95-%E5%AE%9A-%E4%B9%89-%E5%B8%B8%E9%87%8F"><span class="toc-text">实际 用 中 如 何 定 义 常量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-C%E7%A8%8B%E5%BA%8F"><span class="toc-text">1. C程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-1-%E5%A4%9A%E4%B8%AA%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E6%88%96%E6%A8%A1%E5%9D%97%E5%85%AC%E7%94%A8"><span class="toc-text">1.1 多个编译单元或模块公用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-2-%E5%8F%AA%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E4%BD%BF%E7%94%A8"><span class="toc-text">1.2 只为一个编译单元使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-C-%E7%A8%8B%E5%BA%8F"><span class="toc-text">2. C++程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-%E5%A4%9A%E4%B8%AA%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E6%88%96%E6%A8%A1%E5%9D%97%E5%85%AC%E7%94%A8"><span class="toc-text">2.1 多个编译单元或模块公用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-%E5%8F%AA%E4%B8%BA%E4%B8%80%E4%B8%AA%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83%E4%BD%BF%E7%94%A8"><span class="toc-text">2.2 只为一个编译单元使用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E5%87%BD%E6%95%B0"><span class="toc-text">3. 函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B-%E5%AE%9A%E4%B9%89"><span class="toc-text">函数原型 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%A0%86%E6%A0%88"><span class="toc-text">函数堆栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%A7%84%E8%8C%83-%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A-%E3%80%88CallingConvention-%E3%80%82"><span class="toc-text">函数调用规范  调用约定 〈CallingConvention)。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%A7%84%E8%8C%83"><span class="toc-text">函数的连接规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99"><span class="toc-text">参数传递规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B%E4%BB%A5%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99"><span class="toc-text">存储类型以及作用域规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="toc-text">存储类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99"><span class="toc-text">作用域规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const"><span class="toc-text">const</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%8C%87%E9%92%88-%E6%95%B0%E7%BB%84-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">4. 指针 数组 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-text">数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%B8%8E%E6%8C%87%E9%92%88"><span class="toc-text">引用与指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%AC%AC%E5%85%AB%E7%AB%A0-C-c%E9%AB%98%E7%BA%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-text">5. 第八章 C++&#x2F;c高级数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8D%E5%9F%9F"><span class="toc-text">位域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%AF%B9%E9%BD%90"><span class="toc-text">成员对齐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%94%E5%90%88-union"><span class="toc-text">联合 union</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6"><span class="toc-text">文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E7%BC%96%E8%AF%91%E9%A2%84%E5%A4%84%E7%90%86"><span class="toc-text">6. 第九章 编译预处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%BC%96%E8%AF%91"><span class="toc-text">条件编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-%E7%A8%8B%E5%BA%8F%E6%9D%BF%E5%BC%8F"><span class="toc-text">C++文件结构 程序板式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99"><span class="toc-text">C++命名规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-C-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-text">7. C++面向对象程序设计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%9A%E6%80%81"><span class="toc-text">运行时多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-text">C++对象模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96-%E6%8B%B7%E8%B4%9D-%E6%9E%90%E6%9E%84"><span class="toc-text">8. 对象的初始化 拷贝 析构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-C-%E5%87%BD%E6%95%B0-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7"><span class="toc-text">9. C++函数 高级特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-text">重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E9%87%8D%E8%BD%BD-%E8%A6%86%E7%9B%96%E4%B8%8E%E9%9A%90%E8%97%8F"><span class="toc-text">成员函数的重载 覆盖与隐藏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94"><span class="toc-text">内联</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-text">类型转换函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#const%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">const成员函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-%E5%92%8C-RTTI"><span class="toc-text">10. C++异常处理 和 RTTI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-16%E7%AB%A0-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-text">11. 16章 内存管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E7%94%A8%E5%AF%B9%E8%B1%A1%E6%A8%A1%E6%8B%9F%E6%8C%87%E9%92%88"><span class="toc-text">12. 用对象模拟指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%8C%87%E9%92%88auto-ptr"><span class="toc-text">泛型指针auto_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E5%BC%95%E7%94%A8%E6%8A%80%E6%9C%AF%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="toc-text">带引用技术的智能指针</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-17%E7%AB%A0-STL"><span class="toc-text">13. 17章 STL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#STL%E5%A4%B4%E6%96%87%E4%BB%B6%E5%88%86%E5%B8%83"><span class="toc-text">STL头文件分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="toc-text">容器类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="toc-text">泛型算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">迭代器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E5%BA%93"><span class="toc-text">数学运算库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%B7%A5%E5%85%B7"><span class="toc-text">通用工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">其他头文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="toc-text">容器设计原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%83%8F"><span class="toc-text">内存映像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F-%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F"><span class="toc-text">存储方式 访问方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8-1"><span class="toc-text">迭代器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88"><span class="toc-text">迭代器失效</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-text">存储分配器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E9%85%8D%E5%99%A8-%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8-stack-deque-list"><span class="toc-text">适配器 容器适配器 stack deque list</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95-1"><span class="toc-text">泛型算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%89%B9%E6%AE%8A%E5%AE%B9%E5%99%A8"><span class="toc-text">一些特殊容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string-%E7%B1%BB"><span class="toc-text">string 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bitset-%E5%B9%B6%E9%9D%9Eset"><span class="toc-text">bitset 并非set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-text">vector&lt;bool&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E5%AE%B9%E5%99%A8"><span class="toc-text">空容器</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By チャン ゼプン</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">Search</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>